// Generated by rstantools.  Do not edit by hand.

/*
    lssm is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    lssm is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with lssm.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.21.0
#include <stan/model/model_header.hpp>
namespace model_functions_namespace {
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;
static int current_statement_begin__;
stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_functions");
    reader.add_event(3415, 3413, "end", "model_functions");
    return reader;
}
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_symmetric_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 12;
        return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(0.5, add(x, transpose(x))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_symmetric_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_symmetric_matrix(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_spd_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 25;
        return stan::math::promote_scalar<fun_return_scalar_t__>(add_diag(multiply(0.5, add(x, transpose(x))), 0.00000001));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_spd_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_spd_matrix(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_matrix_colwise(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 43;
        validate_non_negative_index("res", "m", m);
        validate_non_negative_index("res", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> res(m, n);
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 44;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 45;
        stan::math::assign(k, 1);
        current_statement_begin__ = 47;
        for (int j = 1; j <= n; ++j) {
            current_statement_begin__ = 49;
            for (int i = 1; i <= m; ++i) {
                current_statement_begin__ = 50;
                stan::model::assign(res, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            get_base1(v, k, "v", 1), 
                            "assigning variable res");
                current_statement_begin__ = 51;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 54;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_matrix_colwise_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) const {
        return to_matrix_colwise(v, m, n, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
matrix_pow(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__);
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
matrix_pow(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 73;
        local_scalar_t__ nn(DUMMY_VAR__);
        (void) nn;  // dummy to suppress unused var warning
        stan::math::initialize(nn, DUMMY_VAR__);
        stan::math::fill(nn, DUMMY_VAR__);
        current_statement_begin__ = 74;
        stan::math::assign(nn, stan::math::floor(n));
        current_statement_begin__ = 75;
        if (as_bool(logical_eq(nn, 0))) {
            current_statement_begin__ = 76;
            return stan::math::promote_scalar<fun_return_scalar_t__>(diag_matrix(rep_vector(1., rows(A))));
        } else if (as_bool(logical_eq(nn, 1))) {
            current_statement_begin__ = 78;
            return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        } else if (as_bool(logical_gt(nn, 1))) {
            current_statement_begin__ = 81;
            if (as_bool(logical_gt(fmod(nn, 2.), 0))) {
                current_statement_begin__ = 83;
                return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(A, matrix_pow(A, (nn - 1), pstream__)));
            } else {
                current_statement_begin__ = 86;
                return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(matrix_pow(A, (nn / 2), pstream__), matrix_pow(A, (nn / 2), pstream__)));
            }
        } else {
            current_statement_begin__ = 90;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Only non-negative values of n are allowed";
            throw std::domain_error(errmsg_stream__.str());
            current_statement_begin__ = 91;
            return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct matrix_pow_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__) const {
        return matrix_pow(A, n, pstream__);
    }
};
int
symmat_size(const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 126;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 129;
        stan::math::assign(sz, 0);
        current_statement_begin__ = 130;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 131;
            stan::math::assign(sz, (sz + i));
        }
        current_statement_begin__ = 133;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct symmat_size_functor__ {
            int
    operator()(const int& n, std::ostream* pstream__) const {
        return symmat_size(n, pstream__);
    }
};
int
find_symmat_dim(const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 153;
        int i(0);
        (void) i;  // dummy to suppress unused var warning
        stan::math::fill(i, std::numeric_limits<int>::min());
        current_statement_begin__ = 154;
        int remainder(0);
        (void) remainder;  // dummy to suppress unused var warning
        stan::math::fill(remainder, std::numeric_limits<int>::min());
        current_statement_begin__ = 155;
        stan::math::assign(remainder, n);
        current_statement_begin__ = 156;
        stan::math::assign(i, 0);
        current_statement_begin__ = 157;
        while (as_bool(logical_gt(remainder, 0))) {
            current_statement_begin__ = 158;
            stan::math::assign(i, (i + 1));
            current_statement_begin__ = 159;
            stan::math::assign(remainder, (remainder - i));
        }
        current_statement_begin__ = 161;
        return stan::math::promote_scalar<fun_return_scalar_t__>(i);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct find_symmat_dim_functor__ {
            int
    operator()(const int& n, std::ostream* pstream__) const {
        return find_symmat_dim(n, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
vector_to_symmat(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 178;
        validate_non_negative_index("m", "n", n);
        validate_non_negative_index("m", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> m(n, n);
        stan::math::initialize(m, DUMMY_VAR__);
        stan::math::fill(m, DUMMY_VAR__);
        current_statement_begin__ = 179;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 180;
        stan::math::assign(k, 1);
        current_statement_begin__ = 182;
        for (int j = 1; j <= n; ++j) {
            current_statement_begin__ = 184;
            for (int i = j; i <= n; ++i) {
                current_statement_begin__ = 185;
                stan::model::assign(m, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            get_base1(x, k, "x", 1), 
                            "assigning variable m");
                current_statement_begin__ = 186;
                if (as_bool(logical_neq(i, j))) {
                    current_statement_begin__ = 187;
                    stan::model::assign(m, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                get_base1(m, i, j, "m", 1), 
                                "assigning variable m");
                }
                current_statement_begin__ = 189;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 192;
        return stan::math::promote_scalar<fun_return_scalar_t__>(m);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct vector_to_symmat_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& n, std::ostream* pstream__) const {
        return vector_to_symmat(x, n, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
symmat_to_vector(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 212;
        validate_non_negative_index("v", "symmat_size(std::min(rows(x), cols(x)), pstream__)", symmat_size(std::min(rows(x), cols(x)), pstream__));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(symmat_size(std::min(rows(x), cols(x)), pstream__));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 213;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 214;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 215;
        stan::math::assign(k, 1);
        current_statement_begin__ = 216;
        stan::math::assign(m, std::min(rows(x), cols(x)));
        current_statement_begin__ = 219;
        for (int j = 1; j <= m; ++j) {
            current_statement_begin__ = 220;
            for (int i = j; i <= m; ++i) {
                current_statement_begin__ = 221;
                stan::model::assign(v, 
                            stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                            get_base1(x, i, j, "x", 1), 
                            "assigning variable v");
                current_statement_begin__ = 222;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 225;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct symmat_to_vector_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return symmat_to_vector(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_lower_triangular_matrix(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 249;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 250;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 251;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 252;
                if (as_bool(logical_gt(i, j))) {
                    current_statement_begin__ = 253;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                x, 
                                "assigning variable A");
                } else if (as_bool(logical_eq(i, j))) {
                    current_statement_begin__ = 255;
                    if (as_bool(diag)) {
                        current_statement_begin__ = 256;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    x, 
                                    "assigning variable A");
                    } else {
                        current_statement_begin__ = 258;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    0., 
                                    "assigning variable A");
                    }
                } else {
                    current_statement_begin__ = 261;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                0., 
                                "assigning variable A");
                }
            }
        }
        current_statement_begin__ = 265;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_lower_triangular_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) const {
        return rep_lower_triangular_matrix(x, m, n, diag, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_upper_triangular_matrix(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 289;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 290;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 291;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 293;
                if (as_bool(logical_lt(i, j))) {
                    current_statement_begin__ = 294;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                x, 
                                "assigning variable A");
                } else if (as_bool(logical_eq(i, j))) {
                    current_statement_begin__ = 296;
                    if (as_bool(diag)) {
                        current_statement_begin__ = 297;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    x, 
                                    "assigning variable A");
                    } else {
                        current_statement_begin__ = 299;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    0., 
                                    "assigning variable A");
                    }
                } else {
                    current_statement_begin__ = 302;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                0., 
                                "assigning variable A");
                }
            }
        }
        current_statement_begin__ = 306;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_upper_triangular_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) const {
        return rep_upper_triangular_matrix(x, m, n, diag, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_diagonal_matrix(const T0__& x,
                        const int& m,
                        const int& n,
                        const int& k, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 331;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 332;
        int mn(0);
        (void) mn;  // dummy to suppress unused var warning
        stan::math::fill(mn, std::numeric_limits<int>::min());
        current_statement_begin__ = 333;
        stan::math::assign(A, rep_matrix(0., m, n));
        current_statement_begin__ = 334;
        stan::math::assign(mn, std::min(m, n));
        current_statement_begin__ = 335;
        if (as_bool(logical_gte(k, 0))) {
            current_statement_begin__ = 336;
            for (int i = 1; i <= std::min(m, (n - k)); ++i) {
                current_statement_begin__ = 337;
                stan::model::assign(A, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni((i + k)), stan::model::nil_index_list())), 
                            x, 
                            "assigning variable A");
            }
        } else {
            current_statement_begin__ = 340;
            for (int i = 1; i <= std::min((m + k), n); ++i) {
                current_statement_begin__ = 341;
                stan::model::assign(A, 
                            stan::model::cons_list(stan::model::index_uni((i - k)), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            x, 
                            "assigning variable A");
            }
        }
        current_statement_begin__ = 344;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_diagonal_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                        const int& m,
                        const int& n,
                        const int& k, std::ostream* pstream__) const {
        return rep_diagonal_matrix(x, m, n, k, pstream__);
    }
};
template <typename T0__, typename T5__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T5__>::type, Eigen::Dynamic, Eigen::Dynamic>
fill_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x,
                const int& m,
                const int& n,
                const std::vector<int>& i,
                const std::vector<int>& j,
                const T5__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T5__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 381;
        validate_non_negative_index("ret", "m", m);
        validate_non_negative_index("ret", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ret(m, n);
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 382;
        stan::math::assign(ret, rep_matrix(a, m, n));
        current_statement_begin__ = 383;
        stan::model::assign(ret, 
                    stan::model::cons_list(stan::model::index_multi(i), stan::model::cons_list(stan::model::index_multi(j), stan::model::nil_index_list())), 
                    x, 
                    "assigning variable ret");
        current_statement_begin__ = 384;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct fill_matrix_functor__ {
    template <typename T0__, typename T5__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T5__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x,
                const int& m,
                const int& n,
                const std::vector<int>& i,
                const std::vector<int>& j,
                const T5__& a, std::ostream* pstream__) const {
        return fill_matrix(x, m, n, i, j, a, pstream__);
    }
};
template <typename T0__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T3__>::type, Eigen::Dynamic, 1>
fill_vector(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                const int& n,
                const std::vector<int>& i,
                const T3__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 415;
        validate_non_negative_index("ret", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ret(n);
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 416;
        stan::math::assign(ret, rep_vector(a, n));
        current_statement_begin__ = 417;
        stan::model::assign(ret, 
                    stan::model::cons_list(stan::model::index_multi(i), stan::model::nil_index_list()), 
                    x, 
                    "assigning variable ret");
        current_statement_begin__ = 418;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct fill_vector_functor__ {
    template <typename T0__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                const int& n,
                const std::vector<int>& i,
                const T3__& a, std::ostream* pstream__) const {
        return fill_vector(x, n, i, a, pstream__);
    }
};
int
int_sum_true(const std::vector<int>& x, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 437;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 438;
        stan::math::assign(n, 0);
        current_statement_begin__ = 439;
        for (int i = 1; i <= num_elements(x); ++i) {
            current_statement_begin__ = 440;
            if (as_bool(int_step(get_base1(x, i, "x", 1)))) {
                current_statement_begin__ = 441;
                stan::math::assign(n, (n + 1));
            }
        }
        current_statement_begin__ = 444;
        return stan::math::promote_scalar<fun_return_scalar_t__>(n);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct int_sum_true_functor__ {
            int
    operator()(const std::vector<int>& x, std::ostream* pstream__) const {
        return int_sum_true(x, pstream__);
    }
};
int
int_sum_false(const std::vector<int>& x, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 463;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 464;
        stan::math::assign(n, 0);
        current_statement_begin__ = 465;
        for (int i = 1; i <= num_elements(x); ++i) {
            current_statement_begin__ = 466;
            if (as_bool(logical_negation(int_step(get_base1(x, i, "x", 1))))) {
                current_statement_begin__ = 467;
                stan::math::assign(n, (n + 1));
            }
        }
        current_statement_begin__ = 470;
        return stan::math::promote_scalar<fun_return_scalar_t__>(n);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct int_sum_false_functor__ {
            int
    operator()(const std::vector<int>& x, std::ostream* pstream__) const {
        return int_sum_false(x, pstream__);
    }
};
std::vector<int>
mask_indexes(const std::vector<int>& x,
                 const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 496;
        validate_non_negative_index("idx", "n", n);
        std::vector<int  > idx(n, int(0));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 497;
        int j(0);
        (void) j;  // dummy to suppress unused var warning
        stan::math::fill(j, std::numeric_limits<int>::min());
        current_statement_begin__ = 498;
        stan::math::assign(j, 1);
        current_statement_begin__ = 499;
        if (as_bool(logical_gt(n, 0))) {
            current_statement_begin__ = 500;
            for (int i = 1; i <= num_elements(x); ++i) {
                current_statement_begin__ = 501;
                if (as_bool((primitive_value(logical_negation(int_step(get_base1(x, i, "x", 1)))) && primitive_value(logical_lte(j, n))))) {
                    current_statement_begin__ = 502;
                    stan::model::assign(idx, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list()), 
                                i, 
                                "assigning variable idx");
                    current_statement_begin__ = 503;
                    stan::math::assign(j, (j + 1));
                }
            }
        }
        current_statement_begin__ = 507;
        return stan::math::promote_scalar<fun_return_scalar_t__>(idx);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct mask_indexes_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& x,
                 const int& n, std::ostream* pstream__) const {
        return mask_indexes(x, n, pstream__);
    }
};
std::vector<int>
select_indexes(const std::vector<int>& x,
                   const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 533;
        validate_non_negative_index("idx", "n", n);
        std::vector<int  > idx(n, int(0));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 534;
        int j(0);
        (void) j;  // dummy to suppress unused var warning
        stan::math::fill(j, std::numeric_limits<int>::min());
        current_statement_begin__ = 535;
        stan::math::assign(j, 1);
        current_statement_begin__ = 536;
        if (as_bool(logical_gt(n, 0))) {
            current_statement_begin__ = 537;
            for (int i = 1; i <= num_elements(x); ++i) {
                current_statement_begin__ = 538;
                if (as_bool((primitive_value(int_step(get_base1(x, i, "x", 1))) && primitive_value(logical_lte(j, n))))) {
                    current_statement_begin__ = 539;
                    stan::model::assign(idx, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list()), 
                                i, 
                                "assigning variable idx");
                    current_statement_begin__ = 540;
                    stan::math::assign(j, (j + 1));
                }
            }
        }
        current_statement_begin__ = 544;
        return stan::math::promote_scalar<fun_return_scalar_t__>(idx);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct select_indexes_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& x,
                   const int& n, std::ostream* pstream__) const {
        return select_indexes(x, n, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
normal2_rng(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 566;
        local_scalar_t__ y(DUMMY_VAR__);
        (void) y;  // dummy to suppress unused var warning
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 567;
        if (as_bool(logical_lte(sigma, 0))) {
            current_statement_begin__ = 568;
            stan::math::assign(y, mu);
        } else {
            current_statement_begin__ = 570;
            stan::math::assign(y, normal_rng(mu, sigma, base_rng__));
        }
        current_statement_begin__ = 572;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct normal2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return normal2_rng(mu, sigma, base_rng__, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
cholesky_decompose2(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 591;
        validate_non_negative_index("L", "rows(A)", rows(A));
        validate_non_negative_index("L", "cols(A)", cols(A));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> L(rows(A), cols(A));
        stan::math::initialize(L, DUMMY_VAR__);
        stan::math::fill(L, DUMMY_VAR__);
        current_statement_begin__ = 592;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 593;
        validate_non_negative_index("nonzero", "rows(A)", rows(A));
        std::vector<int  > nonzero(rows(A), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 594;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 595;
        stan::math::assign(n, rows(A));
        current_statement_begin__ = 596;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 597;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(A, i, i, "A", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 599;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 600;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 601;
            stan::math::assign(L, cholesky_decompose(A));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 603;
            stan::math::assign(L, rep_matrix(0.0, n, n));
        } else {
            {
            current_statement_begin__ = 605;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 606;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 607;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 608;
            stan::math::assign(L, rep_matrix(0.0, n, n));
            current_statement_begin__ = 609;
            stan::model::assign(L, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), 
                        cholesky_decompose(stan::model::rvalue(A, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "A")), 
                        "assigning variable L");
            }
        }
        current_statement_begin__ = 611;
        return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct cholesky_decompose2_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A, std::ostream* pstream__) const {
        return cholesky_decompose2(A, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
multi_normal2_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 635;
        validate_non_negative_index("y", "num_elements(mu)", num_elements(mu));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(num_elements(mu));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 636;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 637;
        validate_non_negative_index("nonzero", "num_elements(mu)", num_elements(mu));
        std::vector<int  > nonzero(num_elements(mu), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 638;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 639;
        stan::math::assign(n, num_elements(mu));
        current_statement_begin__ = 640;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 641;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(Sigma, i, i, "Sigma", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 643;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 644;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 645;
            stan::math::assign(y, multi_normal_rng(mu, Sigma, base_rng__));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 647;
            stan::math::assign(y, mu);
        } else {
            {
            current_statement_begin__ = 649;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 650;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 651;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 652;
            stan::math::assign(eps, rep_vector(0.0, n));
            current_statement_begin__ = 653;
            stan::model::assign(eps, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                        multi_normal_rng(rep_vector(0.0, num_nonzero), stan::model::rvalue(Sigma, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "Sigma"), base_rng__), 
                        "assigning variable eps");
            current_statement_begin__ = 654;
            stan::math::assign(y, add(mu, eps));
            }
        }
        current_statement_begin__ = 656;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct multi_normal2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return multi_normal2_rng(mu, Sigma, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
multi_normal_cholesky2_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& L, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 679;
        validate_non_negative_index("y", "num_elements(mu)", num_elements(mu));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(num_elements(mu));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 680;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 681;
        validate_non_negative_index("nonzero", "num_elements(mu)", num_elements(mu));
        std::vector<int  > nonzero(num_elements(mu), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 682;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 683;
        stan::math::assign(n, num_elements(mu));
        current_statement_begin__ = 684;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 685;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(L, i, i, "L", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 687;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 688;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 689;
            stan::math::assign(y, multi_normal_cholesky_rng(mu, L, base_rng__));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 691;
            stan::math::assign(y, mu);
        } else {
            {
            current_statement_begin__ = 693;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 694;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 695;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 696;
            stan::math::assign(eps, rep_vector(0.0, n));
            current_statement_begin__ = 697;
            stan::model::assign(eps, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                        multi_normal_cholesky_rng(rep_vector(0.0, num_nonzero), stan::model::rvalue(L, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "L"), base_rng__), 
                        "assigning variable eps");
            current_statement_begin__ = 699;
            stan::math::assign(y, add(mu, eps));
            }
        }
        current_statement_begin__ = 701;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct multi_normal_cholesky2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& L, RNG& base_rng__, std::ostream* pstream__) const {
        return multi_normal_cholesky2_rng(mu, L, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, 1>
ssm_update_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& c,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& v,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 739;
        validate_non_negative_index("a_new", "num_elements(a)", num_elements(a));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_new(num_elements(a));
        stan::math::initialize(a_new, DUMMY_VAR__);
        stan::math::fill(a_new, DUMMY_VAR__);
        current_statement_begin__ = 740;
        stan::math::assign(a_new, add(add(multiply(T, a), multiply(K, v)), c));
        current_statement_begin__ = 741;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_a_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& c,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& v,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_a(a, c, T, v, K, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_P(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& RQR,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 772;
        validate_non_negative_index("P_new", "rows(P)", rows(P));
        validate_non_negative_index("P_new", "cols(P)", cols(P));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_new(rows(P), cols(P));
        stan::math::initialize(P_new, DUMMY_VAR__);
        stan::math::fill(P_new, DUMMY_VAR__);
        current_statement_begin__ = 773;
        stan::math::assign(P_new, to_symmetric_matrix(add(multiply(multiply(T, P), transpose(subtract(T, multiply(K, Z)))), RQR), pstream__));
        current_statement_begin__ = 774;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_P_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& RQR,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_P(P, Z, T, RQR, K, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
ssm_update_v(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 803;
        validate_non_negative_index("v", "num_elements(y)", num_elements(y));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(num_elements(y));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 804;
        stan::math::assign(v, subtract(subtract(y, multiply(Z, a)), d));
        current_statement_begin__ = 805;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_v_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z, std::ostream* pstream__) const {
        return ssm_update_v(y, a, d, Z, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
ssm_update_v_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const int& p_t,
                      const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 845;
        validate_non_negative_index("v", "num_elements(y)", num_elements(y));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(num_elements(y));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 846;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 847;
        stan::math::assign(p, num_elements(y));
        current_statement_begin__ = 848;
        if (as_bool(logical_lt(p_t, p))) {
            current_statement_begin__ = 849;
            stan::math::assign(v, rep_vector(0., p));
            current_statement_begin__ = 850;
            if (as_bool(logical_gt(p_t, 0))) {
                {
                current_statement_begin__ = 851;
                validate_non_negative_index("idx", "p_t", p_t);
                std::vector<int  > idx(p_t, int(0));
                stan::math::fill(idx, std::numeric_limits<int>::min());
                current_statement_begin__ = 852;
                validate_non_negative_index("y_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y_star(p_t);
                stan::math::initialize(y_star, DUMMY_VAR__);
                stan::math::fill(y_star, DUMMY_VAR__);
                current_statement_begin__ = 853;
                validate_non_negative_index("d_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_star(p_t);
                stan::math::initialize(d_star, DUMMY_VAR__);
                stan::math::fill(d_star, DUMMY_VAR__);
                current_statement_begin__ = 854;
                validate_non_negative_index("Z_star", "p_t", p_t);
                validate_non_negative_index("Z_star", "cols(Z)", cols(Z));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_star(p_t, cols(Z));
                stan::math::initialize(Z_star, DUMMY_VAR__);
                stan::math::fill(Z_star, DUMMY_VAR__);
                current_statement_begin__ = 855;
                stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
                current_statement_begin__ = 856;
                stan::math::assign(y_star, stan::model::rvalue(y, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "y"));
                current_statement_begin__ = 857;
                stan::math::assign(d_star, stan::model::rvalue(d, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "d"));
                current_statement_begin__ = 858;
                stan::math::assign(Z_star, stan::model::rvalue(Z, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "Z"));
                current_statement_begin__ = 859;
                stan::model::assign(v, 
                            stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                            ssm_update_v(y_star, a, d_star, Z_star, pstream__), 
                            "assigning variable v");
                }
            }
        } else {
            current_statement_begin__ = 862;
            stan::math::assign(v, ssm_update_v(y, a, d, Z, pstream__));
        }
        current_statement_begin__ = 864;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_v_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const int& p_t,
                      const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_v_miss(y, a, d, Z, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_F(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 891;
        validate_non_negative_index("F", "rows(H)", rows(H));
        validate_non_negative_index("F", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> F(rows(H), cols(H));
        stan::math::initialize(F, DUMMY_VAR__);
        stan::math::fill(F, DUMMY_VAR__);
        current_statement_begin__ = 892;
        stan::math::assign(F, to_symmetric_matrix(add(quad_form(P, transpose(Z)), H), pstream__));
        current_statement_begin__ = 893;
        return stan::math::promote_scalar<fun_return_scalar_t__>(F);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_F_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_F(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                    const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                    const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 917;
        validate_non_negative_index("Finv", "rows(H)", rows(H));
        validate_non_negative_index("Finv", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(rows(H), cols(H));
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 919;
        stan::math::assign(Finv, inverse_spd(to_spd_matrix(add(quad_form(P, transpose(Z)), H), pstream__)));
        current_statement_begin__ = 921;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_Finv_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                    const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                    const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_Finv(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_Finv_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                         const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                         const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H,
                         const int& p_t,
                         const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 954;
        validate_non_negative_index("Finv", "rows(H)", rows(H));
        validate_non_negative_index("Finv", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(rows(H), cols(H));
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 955;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 956;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 957;
        stan::math::assign(p, rows(H));
        current_statement_begin__ = 958;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 959;
        if (as_bool(logical_lt(p_t, p))) {
            current_statement_begin__ = 960;
            stan::math::assign(Finv, rep_matrix(0., p, p));
            current_statement_begin__ = 961;
            if (as_bool(logical_gt(p_t, 0))) {
                {
                current_statement_begin__ = 962;
                validate_non_negative_index("Z_star", "p_t", p_t);
                validate_non_negative_index("Z_star", "m", m);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_star(p_t, m);
                stan::math::initialize(Z_star, DUMMY_VAR__);
                stan::math::fill(Z_star, DUMMY_VAR__);
                current_statement_begin__ = 963;
                validate_non_negative_index("H_star", "p_t", p_t);
                validate_non_negative_index("H_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_star(p_t, p_t);
                stan::math::initialize(H_star, DUMMY_VAR__);
                stan::math::fill(H_star, DUMMY_VAR__);
                current_statement_begin__ = 964;
                validate_non_negative_index("idx", "p_t", p_t);
                std::vector<int  > idx(p_t, int(0));
                stan::math::fill(idx, std::numeric_limits<int>::min());
                current_statement_begin__ = 965;
                stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
                current_statement_begin__ = 966;
                stan::math::assign(Z_star, stan::model::rvalue(Z, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "Z"));
                current_statement_begin__ = 967;
                stan::math::assign(H_star, stan::model::rvalue(H, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "H"));
                current_statement_begin__ = 968;
                stan::model::assign(Finv, 
                            stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), 
                            ssm_update_Finv(P, Z_star, H_star, pstream__), 
                            "assigning variable Finv");
                }
            }
        } else {
            current_statement_begin__ = 971;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
        }
        current_statement_begin__ = 973;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_Finv_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                         const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                         const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H,
                         const int& p_t,
                         const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_Finv_miss(P, Z, H, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_K(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1002;
        validate_non_negative_index("K", "cols(Z)", cols(Z));
        validate_non_negative_index("K", "rows(Z)", rows(Z));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(cols(Z), rows(Z));
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1003;
        stan::math::assign(K, multiply(multiply(multiply(T, P), transpose(Z)), Finv));
        current_statement_begin__ = 1004;
        return stan::math::promote_scalar<fun_return_scalar_t__>(K);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_K_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_update_K(P, Z, T, Finv, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_L(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1031;
        validate_non_negative_index("L", "rows(T)", rows(T));
        validate_non_negative_index("L", "cols(T)", cols(T));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> L(rows(T), cols(T));
        stan::math::initialize(L, DUMMY_VAR__);
        stan::math::fill(L, DUMMY_VAR__);
        current_statement_begin__ = 1032;
        stan::math::assign(L, subtract(T, multiply(K, Z)));
        current_statement_begin__ = 1033;
        return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_L_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_L(Z, T, K, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_update_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1059;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1060;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1061;
        stan::math::assign(p, num_elements(v));
        current_statement_begin__ = 1063;
        stan::math::assign(ll, (-(0.5) * (((p * stan::math::log((2 * stan::math::pi()))) - log_determinant(Finv)) + quad_form_sym(Finv, v))));
        current_statement_begin__ = 1068;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_loglik_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_update_loglik(v, Finv, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_update_loglik_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv,
                           const int& p_t,
                           const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1095;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1096;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1097;
        stan::math::assign(p, num_elements(v));
        current_statement_begin__ = 1098;
        if (as_bool(logical_eq(p_t, 0))) {
            current_statement_begin__ = 1099;
            stan::math::assign(ll, 0.);
        } else if (as_bool(logical_eq(p_t, p))) {
            current_statement_begin__ = 1101;
            stan::math::assign(ll, ssm_update_loglik(v, Finv, pstream__));
        } else {
            {
            current_statement_begin__ = 1103;
            validate_non_negative_index("idx", "p_t", p_t);
            std::vector<int  > idx(p_t, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 1104;
            validate_non_negative_index("Finv_star", "p_t", p_t);
            validate_non_negative_index("Finv_star", "p_t", p_t);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv_star(p_t, p_t);
            stan::math::initialize(Finv_star, DUMMY_VAR__);
            stan::math::fill(Finv_star, DUMMY_VAR__);
            current_statement_begin__ = 1105;
            validate_non_negative_index("v_star", "p_t", p_t);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v_star(p_t);
            stan::math::initialize(v_star, DUMMY_VAR__);
            stan::math::fill(v_star, DUMMY_VAR__);
            current_statement_begin__ = 1106;
            stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
            current_statement_begin__ = 1107;
            stan::math::assign(Finv_star, stan::model::rvalue(Finv, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "Finv"));
            current_statement_begin__ = 1108;
            stan::math::assign(v_star, stan::model::rvalue(v, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "v"));
            current_statement_begin__ = 1109;
            stan::math::assign(ll, ssm_update_loglik(v_star, Finv_star, pstream__));
            }
        }
        current_statement_begin__ = 1111;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_loglik_miss_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv,
                           const int& p_t,
                           const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_loglik_miss(v, Finv, p_t, y_idx, pstream__);
    }
};
std::vector<std::vector<int> >
ssm_filter_idx(const int& m,
                   const int& p, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1150;
        validate_non_negative_index("sz", "6", 6);
        validate_non_negative_index("sz", "3", 3);
        std::vector<std::vector<int  >  > sz(6, std::vector<int>(3, int(0)));
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 1152;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 1154;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    p, 
                    "assigning variable sz");
        current_statement_begin__ = 1156;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(3), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    symmat_size(p, pstream__), 
                    "assigning variable sz");
        current_statement_begin__ = 1158;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(4), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    (m * p), 
                    "assigning variable sz");
        current_statement_begin__ = 1160;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(5), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    m, 
                    "assigning variable sz");
        current_statement_begin__ = 1162;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(6), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    symmat_size(m, pstream__), 
                    "assigning variable sz");
        current_statement_begin__ = 1164;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 1165;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 1, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 1, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 1166;
        for (int i = 2; i <= 6; ++i) {
            current_statement_begin__ = 1167;
            stan::model::assign(sz, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                        (get_base1(get_base1(sz, (i - 1), "sz", 1), 3, "sz", 2) + 1), 
                        "assigning variable sz");
            current_statement_begin__ = 1168;
            stan::model::assign(sz, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                        ((get_base1(get_base1(sz, i, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, i, "sz", 1), 1, "sz", 2)) - 1), 
                        "assigning variable sz");
        }
        current_statement_begin__ = 1170;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_idx_functor__ {
            std::vector<std::vector<int> >
    operator()(const int& m,
                   const int& p, std::ostream* pstream__) const {
        return ssm_filter_idx(m, p, pstream__);
    }
};
int
ssm_filter_size(const int& m,
                    const int& p, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1190;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 1191;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1192;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1193;
        stan::math::assign(sz, get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2));
        current_statement_begin__ = 1194;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_size_functor__ {
            int
    operator()(const int& m,
                    const int& p, std::ostream* pstream__) const {
        return ssm_filter_size(m, p, pstream__);
    }
};
template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
ssm_filter_get_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1216;
        local_scalar_t__ y(DUMMY_VAR__);
        (void) y;  // dummy to suppress unused var warning
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1217;
        stan::math::assign(y, get_base1(x, 1, "x", 1));
        current_statement_begin__ = 1218;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_loglik_functor__ {
    template <typename T0__>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_loglik(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_filter_get_v(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1240;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1241;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1242;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1243;
        stan::math::assign(y, segment(x, get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 1, "idx", 2)));
        current_statement_begin__ = 1244;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_v_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_v(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1266;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(p, p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1267;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1268;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1269;
        stan::math::assign(y, vector_to_symmat(segment(x, get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 1, "idx", 2)), p, pstream__));
        current_statement_begin__ = 1270;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_Finv_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_Finv(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_K(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1292;
        validate_non_negative_index("y", "m", m);
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(m, p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1293;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1294;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1295;
        stan::math::assign(y, to_matrix_colwise(segment(x, get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 1, "idx", 2)), m, p, pstream__));
        current_statement_begin__ = 1296;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_K_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_K(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_filter_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1318;
        validate_non_negative_index("y", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(m);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1319;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1320;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1321;
        stan::math::assign(y, segment(x, get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 1, "idx", 2)));
        current_statement_begin__ = 1322;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_a_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_a(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_P(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1344;
        validate_non_negative_index("y", "m", m);
        validate_non_negative_index("y", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(m, m);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1345;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1346;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1347;
        stan::math::assign(y, vector_to_symmat(segment(x, get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 1, "idx", 2)), m, pstream__));
        current_statement_begin__ = 1348;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_P_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_P(x, m, p, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_filter(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1408;
        validate_non_negative_index("res", "ssm_filter_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), pstream__)", ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__));
        validate_non_negative_index("res", "size(y)", size(y));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > res(size(y), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__)));
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 1409;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1410;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1411;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1412;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1415;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1416;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1417;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1418;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1423;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1424;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1425;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1426;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1427;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1428;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1429;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1430;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1432;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1433;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1434;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1435;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1436;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1437;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1438;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1440;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1442;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1443;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1444;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1445;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1446;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1447;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1448;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1449;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1450;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1451;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1452;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1453;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1454;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1455;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1457;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1458;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1460;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1461;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1463;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 1464;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 1466;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 1467;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 1469;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 1470;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 1472;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 1473;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                }
                current_statement_begin__ = 1475;
                if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                    current_statement_begin__ = 1476;
                    stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                }
            }
            current_statement_begin__ = 1480;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d_t, Z_t, pstream__));
            current_statement_begin__ = 1481;
            stan::math::assign(Finv, ssm_update_Finv(P, Z_t, H_t, pstream__));
            current_statement_begin__ = 1482;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1483;
            stan::math::assign(ll, ssm_update_loglik(v, Finv, pstream__));
            current_statement_begin__ = 1485;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        ll, 
                        "assigning variable res");
            current_statement_begin__ = 1486;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        v, 
                        "assigning variable res");
            current_statement_begin__ = 1487;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(Finv, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1488;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        to_vector(K), 
                        "assigning variable res");
            current_statement_begin__ = 1489;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable res");
            current_statement_begin__ = 1490;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(P, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1492;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1493;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1494;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        }
        current_statement_begin__ = 1498;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_filter_miss(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                    const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                    const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                    const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                    const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                    const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                    const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                    const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                    const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                    const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                    const std::vector<int>& p_t,
                    const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1561;
        validate_non_negative_index("res", "ssm_filter_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), pstream__)", ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__));
        validate_non_negative_index("res", "size(y)", size(y));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > res(size(y), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__)));
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 1562;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1563;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1564;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1565;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1568;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1569;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1570;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1571;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1576;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1577;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1578;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1579;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1580;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1581;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1582;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1583;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1585;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1586;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1587;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1588;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1589;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1590;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1591;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1592;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1593;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1594;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1595;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1596;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1597;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1598;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1599;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1600;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1601;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1602;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1603;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1604;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1605;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1606;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1608;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1609;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1611;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1612;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1614;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 1615;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 1617;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 1618;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 1620;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 1621;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 1623;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 1624;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                }
                current_statement_begin__ = 1626;
                if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                    current_statement_begin__ = 1627;
                    stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                }
            }
            current_statement_begin__ = 1631;
            stan::math::assign(v, ssm_update_v_miss(get_base1(y, t, "y", 1), a, d_t, Z_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1632;
            stan::math::assign(Finv, ssm_update_Finv_miss(P, Z_t, H_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1633;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1634;
            stan::math::assign(ll, ssm_update_loglik_miss(v, Finv, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1636;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        ll, 
                        "assigning variable res");
            current_statement_begin__ = 1637;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        v, 
                        "assigning variable res");
            current_statement_begin__ = 1638;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(Finv, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1639;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        to_vector(K), 
                        "assigning variable res");
            current_statement_begin__ = 1640;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable res");
            current_statement_begin__ = 1641;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(P, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1643;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1644;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1645;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        }
        current_statement_begin__ = 1649;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                    const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                    const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                    const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                    const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                    const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                    const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                    const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                    const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                    const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                    const std::vector<int>& p_t,
                    const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) const {
        return ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1707;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1708;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1709;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1710;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1711;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1712;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1713;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1714;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1715;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1718;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1719;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1720;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1721;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1722;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1723;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1724;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1725;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1727;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1728;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1729;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1730;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1731;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1732;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1734;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1735;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1736;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1737;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1738;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1739;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1740;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1741;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1743;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1744;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1745;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1746;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1747;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1748;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1750;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1751;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1753;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1754;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1756;
                if (as_bool(logical_lt(t, n))) {
                    current_statement_begin__ = 1757;
                    if (as_bool(logical_gt(size(c), 1))) {
                        current_statement_begin__ = 1758;
                        stan::math::assign(c_t, get_base1(c, t, "c", 1));
                    }
                    current_statement_begin__ = 1760;
                    if (as_bool(logical_gt(size(T), 1))) {
                        current_statement_begin__ = 1761;
                        stan::math::assign(T_t, get_base1(T, t, "T", 1));
                    }
                    current_statement_begin__ = 1763;
                    if (as_bool(logical_gt(size(R), 1))) {
                        current_statement_begin__ = 1764;
                        stan::math::assign(R_t, get_base1(R, t, "R", 1));
                    }
                    current_statement_begin__ = 1766;
                    if (as_bool(logical_gt(size(Q), 1))) {
                        current_statement_begin__ = 1767;
                        stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    }
                    current_statement_begin__ = 1769;
                    if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                        current_statement_begin__ = 1770;
                        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                    }
                }
            }
            current_statement_begin__ = 1774;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d_t, Z_t, pstream__));
            current_statement_begin__ = 1775;
            stan::math::assign(Finv, ssm_update_Finv(P, Z_t, H_t, pstream__));
            current_statement_begin__ = 1776;
            stan::math::assign(K, ssm_update_K(P, T_t, Z_t, Finv, pstream__));
            current_statement_begin__ = 1777;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik(v, Finv, pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 1779;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1780;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1781;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        current_statement_begin__ = 1784;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 1786;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}
struct ssm_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_miss_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1825;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1826;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1827;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1828;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1829;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1830;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1831;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1832;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1833;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1836;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1837;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1838;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1839;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1840;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1841;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1842;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1843;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1845;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1846;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1847;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1848;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1849;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1850;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1852;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1853;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1854;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1855;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1856;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1857;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1858;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1859;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1861;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1862;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1863;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1864;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1865;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1866;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1868;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1869;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1871;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1872;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1874;
                if (as_bool(logical_lt(t, n))) {
                    current_statement_begin__ = 1875;
                    if (as_bool(logical_gt(size(c), 1))) {
                        current_statement_begin__ = 1876;
                        stan::math::assign(c_t, get_base1(c, t, "c", 1));
                    }
                    current_statement_begin__ = 1878;
                    if (as_bool(logical_gt(size(T), 1))) {
                        current_statement_begin__ = 1879;
                        stan::math::assign(T_t, get_base1(T, t, "T", 1));
                    }
                    current_statement_begin__ = 1881;
                    if (as_bool(logical_gt(size(R), 1))) {
                        current_statement_begin__ = 1882;
                        stan::math::assign(R_t, get_base1(R, t, "R", 1));
                    }
                    current_statement_begin__ = 1884;
                    if (as_bool(logical_gt(size(Q), 1))) {
                        current_statement_begin__ = 1885;
                        stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    }
                    current_statement_begin__ = 1887;
                    if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                        current_statement_begin__ = 1888;
                        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                    }
                }
            }
            current_statement_begin__ = 1892;
            stan::math::assign(v, ssm_update_v_miss(get_base1(y, t, "y", 1), a, d_t, Z_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1893;
            stan::math::assign(Finv, ssm_update_Finv_miss(P, Z_t, H_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1894;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1895;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik_miss(v, Finv, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 1897;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1898;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1899;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        current_statement_begin__ = 1902;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 1904;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_miss_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    return ssm_miss_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1,p_t,y_idx, pstream__);
}
struct ssm_miss_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) const {
        return ssm_miss_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
matrix_diff(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1932;
        local_scalar_t__ eps(DUMMY_VAR__);
        (void) eps;  // dummy to suppress unused var warning
        stan::math::initialize(eps, DUMMY_VAR__);
        stan::math::fill(eps, DUMMY_VAR__);
        current_statement_begin__ = 1933;
        local_scalar_t__ norm_AB(DUMMY_VAR__);
        (void) norm_AB;  // dummy to suppress unused var warning
        stan::math::initialize(norm_AB, DUMMY_VAR__);
        stan::math::fill(norm_AB, DUMMY_VAR__);
        current_statement_begin__ = 1934;
        local_scalar_t__ norm_A(DUMMY_VAR__);
        (void) norm_A;  // dummy to suppress unused var warning
        stan::math::initialize(norm_A, DUMMY_VAR__);
        stan::math::fill(norm_A, DUMMY_VAR__);
        current_statement_begin__ = 1935;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1936;
        local_scalar_t__ ab(DUMMY_VAR__);
        (void) ab;  // dummy to suppress unused var warning
        stan::math::initialize(ab, DUMMY_VAR__);
        stan::math::fill(ab, DUMMY_VAR__);
        current_statement_begin__ = 1937;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1938;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1939;
        stan::math::assign(m, rows(A));
        current_statement_begin__ = 1940;
        stan::math::assign(n, cols(A));
        current_statement_begin__ = 1941;
        stan::math::assign(eps, 0.0);
        current_statement_begin__ = 1942;
        stan::math::assign(norm_A, 0.0);
        current_statement_begin__ = 1943;
        stan::math::assign(norm_AB, 0.0);
        current_statement_begin__ = 1944;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 1945;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 1946;
                stan::math::assign(a, stan::math::fabs(get_base1(A, i, j, "A", 1)));
                current_statement_begin__ = 1947;
                stan::math::assign(ab, stan::math::fabs((get_base1(A, i, j, "A", 1) - get_base1(B, i, j, "B", 1))));
                current_statement_begin__ = 1948;
                if (as_bool(logical_gt(a, norm_A))) {
                    current_statement_begin__ = 1949;
                    stan::math::assign(norm_A, a);
                }
                current_statement_begin__ = 1951;
                if (as_bool(logical_gt(ab, norm_AB))) {
                    current_statement_begin__ = 1952;
                    stan::math::assign(norm_AB, ab);
                }
            }
        }
        current_statement_begin__ = 1956;
        stan::math::assign(eps, (norm_AB / norm_A));
        current_statement_begin__ = 1957;
        return stan::math::promote_scalar<fun_return_scalar_t__>(eps);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct matrix_diff_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return matrix_diff(A, B, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2002;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 2003;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2004;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2005;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2007;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 2008;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 2009;
        stan::math::assign(p, rows(Z));
        {
        current_statement_begin__ = 2011;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 2012;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2013;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2014;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2015;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2016;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2017;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2020;
        int converged(0);
        (void) converged;  // dummy to suppress unused var warning
        stan::math::fill(converged, std::numeric_limits<int>::min());
        current_statement_begin__ = 2021;
        validate_non_negative_index("P_old", "m", m);
        validate_non_negative_index("P_old", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_old(m, m);
        stan::math::initialize(P_old, DUMMY_VAR__);
        stan::math::fill(P_old, DUMMY_VAR__);
        current_statement_begin__ = 2022;
        local_scalar_t__ tol(DUMMY_VAR__);
        (void) tol;  // dummy to suppress unused var warning
        stan::math::initialize(tol, DUMMY_VAR__);
        stan::math::fill(tol, DUMMY_VAR__);
        current_statement_begin__ = 2023;
        local_scalar_t__ matdiff(DUMMY_VAR__);
        (void) matdiff;  // dummy to suppress unused var warning
        stan::math::initialize(matdiff, DUMMY_VAR__);
        stan::math::fill(matdiff, DUMMY_VAR__);
        current_statement_begin__ = 2024;
        stan::math::assign(converged, 0);
        current_statement_begin__ = 2025;
        stan::math::assign(tol, 1e-7);
        current_statement_begin__ = 2027;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2028;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2029;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2030;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2031;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2032;
            if (as_bool(logical_lt(converged, 1))) {
                current_statement_begin__ = 2033;
                stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
                current_statement_begin__ = 2034;
                stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            }
            current_statement_begin__ = 2036;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik(v, Finv, pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 2038;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 2039;
                stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
                current_statement_begin__ = 2042;
                if (as_bool(logical_lt(converged, 1))) {
                    current_statement_begin__ = 2043;
                    stan::math::assign(P_old, P);
                    current_statement_begin__ = 2044;
                    stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
                    current_statement_begin__ = 2045;
                    stan::math::assign(matdiff, matrix_diff(P, P_old, pstream__));
                    current_statement_begin__ = 2046;
                    if (as_bool(logical_lt(matdiff, tol))) {
                        current_statement_begin__ = 2047;
                        stan::math::assign(converged, 1);
                    }
                }
            }
        }
        current_statement_begin__ = 2052;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 2054;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_constant_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}
struct ssm_constant_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_constant_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_predicted_cov(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                             const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                             const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2073;
        validate_non_negative_index("cov_new", "rows(H)", rows(H));
        validate_non_negative_index("cov_new", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> cov_new(rows(H), cols(H));
        stan::math::initialize(cov_new, DUMMY_VAR__);
        stan::math::fill(cov_new, DUMMY_VAR__);
        current_statement_begin__ = 2074;
        stan::math::assign(cov_new, ssm_update_F(P, Z, H, pstream__));
        current_statement_begin__ = 2075;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cov_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_cov_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                             const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                             const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_predicted_cov(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
ssm_update_predicted_mean(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& d,
                              const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                              const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2094;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2095;
        validate_non_negative_index("mean_new", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> mean_new(p);
        stan::math::initialize(mean_new, DUMMY_VAR__);
        stan::math::fill(mean_new, DUMMY_VAR__);
        current_statement_begin__ = 2096;
        stan::math::assign(mean_new, add(d, multiply(Z, a)));
        current_statement_begin__ = 2097;
        return stan::math::promote_scalar<fun_return_scalar_t__>(mean_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_mean_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& d,
                              const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                              const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) const {
        return ssm_update_predicted_mean(d, Z, a, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
ssm_update_predicted_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2116;
        validate_non_negative_index("a_new", "num_elements(a)", num_elements(a));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_new(num_elements(a));
        stan::math::initialize(a_new, DUMMY_VAR__);
        stan::math::fill(a_new, DUMMY_VAR__);
        current_statement_begin__ = 2117;
        stan::math::assign(a_new, add(c, multiply(T, a)));
        current_statement_begin__ = 2118;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_a_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) const {
        return ssm_update_predicted_a(c, T, a, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_predicted_P(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2137;
        validate_non_negative_index("P_new", "rows(P)", rows(P));
        validate_non_negative_index("P_new", "cols(P)", cols(P));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_new(rows(P), cols(P));
        stan::math::initialize(P_new, DUMMY_VAR__);
        stan::math::fill(P_new, DUMMY_VAR__);
        current_statement_begin__ = 2138;
        stan::math::assign(P_new, to_symmetric_matrix(add(quad_form_sym(P, transpose(T)), RQR), pstream__));
        current_statement_begin__ = 2139;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_P_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) const {
        return ssm_update_predicted_P(P, T, RQR, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
predict(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
            const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
            const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
            const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
            const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
            const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
            const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
            const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
            const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
            const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
            const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2177;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2178;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2179;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2181;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2182;
        validate_non_negative_index("F", "p", p);
        validate_non_negative_index("F", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> F(p, p);
        stan::math::initialize(F, DUMMY_VAR__);
        stan::math::fill(F, DUMMY_VAR__);
        current_statement_begin__ = 2183;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2184;
        validate_non_negative_index("prediction", "p", p);
        validate_non_negative_index("prediction", "(p + 1)", (p + 1));
        validate_non_negative_index("prediction", "horizon", horizon);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > prediction(horizon, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(p, (p + 1)));
        stan::math::initialize(prediction, DUMMY_VAR__);
        stan::math::fill(prediction, DUMMY_VAR__);
        {
        current_statement_begin__ = 2186;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2187;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2188;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2189;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2191;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2192;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2193;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2195;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2196;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2197;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2198;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2199;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2200;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        current_statement_begin__ = 2205;
        stan::model::assign(prediction, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                    "assigning variable prediction");
        current_statement_begin__ = 2207;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2208;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2209;
                stan::math::assign(a, ssm_update_predicted_a(c, T, a, pstream__));
                current_statement_begin__ = 2210;
                stan::math::assign(P, ssm_update_predicted_P(P, T, RQR, pstream__));
                current_statement_begin__ = 2211;
                stan::model::assign(prediction, 
                            stan::model::cons_list(stan::model::index_uni(h), stan::model::nil_index_list()), 
                            append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                            "assigning variable prediction");
            }
        }
        }
        current_statement_begin__ = 2216;
        return stan::math::promote_scalar<fun_return_scalar_t__>(prediction);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct predict_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
            const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
            const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
            const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
            const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
            const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
            const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
            const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
            const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
            const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
            const int& horizon, std::ostream* pstream__) const {
        return predict(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
predict_given_one_step(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                           const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                           const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                           const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                           const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                           const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                           const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2224;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2225;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2226;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2228;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        stan::math::assign(a,a1);
        current_statement_begin__ = 2229;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        stan::math::assign(P,P1);
        current_statement_begin__ = 2230;
        validate_non_negative_index("prediction", "p", p);
        validate_non_negative_index("prediction", "(p + 1)", (p + 1));
        validate_non_negative_index("prediction", "horizon", horizon);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > prediction(horizon, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(p, (p + 1)));
        stan::math::initialize(prediction, DUMMY_VAR__);
        stan::math::fill(prediction, DUMMY_VAR__);
        {
        current_statement_begin__ = 2232;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2234;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2237;
        stan::model::assign(prediction, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                    "assigning variable prediction");
        current_statement_begin__ = 2239;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2240;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2241;
                stan::math::assign(a, ssm_update_predicted_a(c, T, a, pstream__));
                current_statement_begin__ = 2242;
                stan::math::assign(P, ssm_update_predicted_P(P, T, RQR, pstream__));
                current_statement_begin__ = 2243;
                stan::model::assign(prediction, 
                            stan::model::cons_list(stan::model::index_uni(h), stan::model::nil_index_list()), 
                            append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                            "assigning variable prediction");
            }
        }
        }
        current_statement_begin__ = 2248;
        return stan::math::promote_scalar<fun_return_scalar_t__>(prediction);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct predict_given_one_step_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                           const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                           const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                           const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                           const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                           const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                           const int& horizon, std::ostream* pstream__) const {
        return predict_given_one_step(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_constant_joint_predict(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2289;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2290;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2291;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2293;
        validate_non_negative_index("d_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_tilde((p * horizon));
        stan::math::initialize(d_tilde, DUMMY_VAR__);
        stan::math::fill(d_tilde, DUMMY_VAR__);
        current_statement_begin__ = 2294;
        validate_non_negative_index("a_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_star((m * horizon));
        stan::math::initialize(a_star, DUMMY_VAR__);
        stan::math::fill(a_star, DUMMY_VAR__);
        stan::math::assign(a_star,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2295;
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_tilde((p * horizon), (p * horizon));
        stan::math::initialize(H_tilde, DUMMY_VAR__);
        stan::math::fill(H_tilde, DUMMY_VAR__);
        stan::math::assign(H_tilde,rep_matrix(0, (p * horizon), (p * horizon)));
        current_statement_begin__ = 2297;
        validate_non_negative_index("c_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_tilde((m * horizon));
        stan::math::initialize(c_tilde, DUMMY_VAR__);
        stan::math::fill(c_tilde, DUMMY_VAR__);
        stan::math::assign(c_tilde,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2298;
        validate_non_negative_index("ZT_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("ZT_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT_tilde((p * horizon), (m * horizon));
        stan::math::initialize(ZT_tilde, DUMMY_VAR__);
        stan::math::fill(ZT_tilde, DUMMY_VAR__);
        stan::math::assign(ZT_tilde,rep_matrix(0, (p * horizon), (m * horizon)));
        current_statement_begin__ = 2300;
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_star((m * horizon), (m * horizon));
        stan::math::initialize(Q_star, DUMMY_VAR__);
        stan::math::fill(Q_star, DUMMY_VAR__);
        stan::math::assign(Q_star,rep_matrix(0, (m * horizon), (m * horizon)));
        current_statement_begin__ = 2302;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        stan::math::assign(RQR,quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2306;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2307;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        {
        current_statement_begin__ = 2309;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2310;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2311;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2313;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2314;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2315;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2316;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2317;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2318;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2319;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2320;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        }
        {
        current_statement_begin__ = 2326;
        validate_non_negative_index("ZT", "p", p);
        validate_non_negative_index("ZT", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT(p, m);
        stan::math::initialize(ZT, DUMMY_VAR__);
        stan::math::fill(ZT, DUMMY_VAR__);
        stan::math::assign(ZT,Z);
        current_statement_begin__ = 2328;
        stan::model::assign(a_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list()), 
                    a, 
                    "assigning variable a_star");
        current_statement_begin__ = 2330;
        for (int h = 1; h <= horizon; ++h) {
            current_statement_begin__ = 2331;
            stan::model::assign(d_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list()), 
                        d, 
                        "assigning variable d_tilde");
            current_statement_begin__ = 2332;
            if (as_bool(logical_gt(h, 1))) {
                current_statement_begin__ = 2333;
                stan::model::assign(c_tilde, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list()), 
                            c, 
                            "assigning variable c_tilde");
                current_statement_begin__ = 2334;
                stan::math::assign(ZT, multiply(ZT, T));
            }
            current_statement_begin__ = 2337;
            stan::model::assign(H_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list())), 
                        H, 
                        "assigning variable H_tilde");
            current_statement_begin__ = 2339;
            for (int i = 1; i <= ((horizon - h) + 1); ++i) {
                current_statement_begin__ = 2340;
                stan::model::assign(ZT_tilde, 
                            stan::model::cons_list(stan::model::index_min_max(((((i + h) - 2) * p) + 1), (((i + h) - 1) * p)), stan::model::cons_list(stan::model::index_min_max((((i - 1) * m) + 1), (i * m)), stan::model::nil_index_list())), 
                            ZT, 
                            "assigning variable ZT_tilde");
            }
        }
        }
        current_statement_begin__ = 2345;
        stan::model::assign(Q_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list())), 
                    P, 
                    "assigning variable Q_star");
        current_statement_begin__ = 2346;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2347;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2348;
                stan::model::assign(Q_star, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list())), 
                            RQR, 
                            "assigning variable Q_star");
            }
        }
        current_statement_begin__ = 2354;
        return stan::math::promote_scalar<fun_return_scalar_t__>(append_col(add(to_matrix(d_tilde), multiply(ZT_tilde, to_matrix(add(c_tilde, a_star)))), add(quad_form_sym(Q_star, transpose(ZT_tilde)), H_tilde)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_constant_joint_predict_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) const {
        return ssm_constant_joint_predict(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_constant_joint_predict_given_one_step(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                                              const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                                              const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                                              const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                                              const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                                              const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                                              const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                                              const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                                              const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                                              const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                                              const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2366;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2367;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2368;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2370;
        validate_non_negative_index("d_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_tilde((p * horizon));
        stan::math::initialize(d_tilde, DUMMY_VAR__);
        stan::math::fill(d_tilde, DUMMY_VAR__);
        current_statement_begin__ = 2371;
        validate_non_negative_index("a_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_star((m * horizon));
        stan::math::initialize(a_star, DUMMY_VAR__);
        stan::math::fill(a_star, DUMMY_VAR__);
        stan::math::assign(a_star,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2372;
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_tilde((p * horizon), (p * horizon));
        stan::math::initialize(H_tilde, DUMMY_VAR__);
        stan::math::fill(H_tilde, DUMMY_VAR__);
        stan::math::assign(H_tilde,rep_matrix(0, (p * horizon), (p * horizon)));
        current_statement_begin__ = 2374;
        validate_non_negative_index("c_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_tilde((m * horizon));
        stan::math::initialize(c_tilde, DUMMY_VAR__);
        stan::math::fill(c_tilde, DUMMY_VAR__);
        stan::math::assign(c_tilde,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2375;
        validate_non_negative_index("ZT_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("ZT_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT_tilde((p * horizon), (m * horizon));
        stan::math::initialize(ZT_tilde, DUMMY_VAR__);
        stan::math::fill(ZT_tilde, DUMMY_VAR__);
        stan::math::assign(ZT_tilde,rep_matrix(0, (p * horizon), (m * horizon)));
        current_statement_begin__ = 2377;
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_star((m * horizon), (m * horizon));
        stan::math::initialize(Q_star, DUMMY_VAR__);
        stan::math::fill(Q_star, DUMMY_VAR__);
        stan::math::assign(Q_star,rep_matrix(0, (m * horizon), (m * horizon)));
        current_statement_begin__ = 2379;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        stan::math::assign(RQR,quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2383;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2384;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        {
        current_statement_begin__ = 2386;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2387;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2388;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2390;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2391;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2392;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2393;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2394;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2395;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2396;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2397;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        }
        {
        current_statement_begin__ = 2403;
        validate_non_negative_index("ZT", "p", p);
        validate_non_negative_index("ZT", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT(p, m);
        stan::math::initialize(ZT, DUMMY_VAR__);
        stan::math::fill(ZT, DUMMY_VAR__);
        stan::math::assign(ZT,Z);
        current_statement_begin__ = 2405;
        stan::model::assign(a_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list()), 
                    a, 
                    "assigning variable a_star");
        current_statement_begin__ = 2407;
        for (int h = 1; h <= horizon; ++h) {
            current_statement_begin__ = 2408;
            stan::model::assign(d_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list()), 
                        d, 
                        "assigning variable d_tilde");
            current_statement_begin__ = 2409;
            if (as_bool(logical_gt(h, 1))) {
                current_statement_begin__ = 2410;
                stan::model::assign(c_tilde, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list()), 
                            c, 
                            "assigning variable c_tilde");
                current_statement_begin__ = 2411;
                stan::math::assign(ZT, multiply(ZT, T));
            }
            current_statement_begin__ = 2414;
            stan::model::assign(H_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list())), 
                        H, 
                        "assigning variable H_tilde");
            current_statement_begin__ = 2416;
            for (int i = 1; i <= ((horizon - h) + 1); ++i) {
                current_statement_begin__ = 2417;
                stan::model::assign(ZT_tilde, 
                            stan::model::cons_list(stan::model::index_min_max(((((i + h) - 2) * p) + 1), (((i + h) - 1) * p)), stan::model::cons_list(stan::model::index_min_max((((i - 1) * m) + 1), (i * m)), stan::model::nil_index_list())), 
                            ZT, 
                            "assigning variable ZT_tilde");
            }
        }
        }
        current_statement_begin__ = 2422;
        stan::model::assign(Q_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list())), 
                    P, 
                    "assigning variable Q_star");
        current_statement_begin__ = 2423;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2424;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2425;
                stan::model::assign(Q_star, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list())), 
                            RQR, 
                            "assigning variable Q_star");
            }
        }
        current_statement_begin__ = 2431;
        return stan::math::promote_scalar<fun_return_scalar_t__>(append_col(add(to_matrix(d_tilde), multiply(ZT_tilde, to_matrix(add(c_tilde, a_star)))), add(quad_form_sym(Q_star, transpose(ZT_tilde)), H_tilde)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_constant_joint_predict_given_one_step_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                                              const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                                              const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                                              const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                                              const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                                              const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                                              const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                                              const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                                              const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                                              const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                                              const int& horizon, std::ostream* pstream__) const {
        return ssm_constant_joint_predict_given_one_step(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_forecast_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2480;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        stan::math::assign(ll,0.0);
        current_statement_begin__ = 2481;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2482;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2483;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2485;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 2486;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 2487;
        stan::math::assign(p, rows(Z));
        {
        current_statement_begin__ = 2489;
        validate_non_negative_index("ll_pred", "(n - horizon)", (n - horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_pred((n - horizon));
        stan::math::initialize(ll_pred, DUMMY_VAR__);
        stan::math::fill(ll_pred, DUMMY_VAR__);
        current_statement_begin__ = 2490;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2491;
        validate_non_negative_index("a_temp", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_temp(m);
        stan::math::initialize(a_temp, DUMMY_VAR__);
        stan::math::fill(a_temp, DUMMY_VAR__);
        current_statement_begin__ = 2492;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2493;
        validate_non_negative_index("P_temp", "m", m);
        validate_non_negative_index("P_temp", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_temp(m, m);
        stan::math::initialize(P_temp, DUMMY_VAR__);
        stan::math::fill(P_temp, DUMMY_VAR__);
        current_statement_begin__ = 2494;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2495;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2496;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2497;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2498;
        validate_non_negative_index("full_prediction", "p", p);
        validate_non_negative_index("full_prediction", "(p + 1)", (p + 1));
        validate_non_negative_index("full_prediction", "horizon", horizon);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > full_prediction(horizon, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(p, (p + 1)));
        stan::math::initialize(full_prediction, DUMMY_VAR__);
        stan::math::fill(full_prediction, DUMMY_VAR__);
        current_statement_begin__ = 2501;
        int converged(0);
        (void) converged;  // dummy to suppress unused var warning
        stan::math::fill(converged, std::numeric_limits<int>::min());
        current_statement_begin__ = 2502;
        validate_non_negative_index("P_old", "m", m);
        validate_non_negative_index("P_old", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_old(m, m);
        stan::math::initialize(P_old, DUMMY_VAR__);
        stan::math::fill(P_old, DUMMY_VAR__);
        current_statement_begin__ = 2503;
        local_scalar_t__ tol(DUMMY_VAR__);
        (void) tol;  // dummy to suppress unused var warning
        stan::math::initialize(tol, DUMMY_VAR__);
        stan::math::fill(tol, DUMMY_VAR__);
        current_statement_begin__ = 2504;
        local_scalar_t__ matdiff(DUMMY_VAR__);
        (void) matdiff;  // dummy to suppress unused var warning
        stan::math::initialize(matdiff, DUMMY_VAR__);
        stan::math::fill(matdiff, DUMMY_VAR__);
        current_statement_begin__ = 2505;
        stan::math::assign(converged, 0);
        current_statement_begin__ = 2506;
        stan::math::assign(tol, 1e-7);
        current_statement_begin__ = 2508;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2509;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2510;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2511;
        for (int t = 1; t <= (n - horizon); ++t) {
            current_statement_begin__ = 2512;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2513;
            if (as_bool(logical_lt(converged, 1))) {
                current_statement_begin__ = 2514;
                stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
                current_statement_begin__ = 2515;
                stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            }
            current_statement_begin__ = 2529;
            stan::math::assign(full_prediction, predict_given_one_step(y, d, Z, H, c, T, R, Q, a, P, horizon, pstream__));
            current_statement_begin__ = 2530;
            stan::math::assign(ll, (ll + multi_normal_log(get_base1(y, (t + horizon), "y", 1), stan::model::rvalue(full_prediction, stan::model::cons_list(stan::model::index_uni(horizon), stan::model::cons_list(stan::model::index_min_max(1, p), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()))), "full_prediction"), stan::model::rvalue(full_prediction, stan::model::cons_list(stan::model::index_uni(horizon), stan::model::cons_list(stan::model::index_min_max(1, p), stan::model::cons_list(stan::model::index_min_max(2, (p + 1)), stan::model::nil_index_list()))), "full_prediction"))));
            current_statement_begin__ = 2531;
            if (pstream__) {
                stan_print(pstream__,"t = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2532;
            if (pstream__) {
                stan_print(pstream__,t);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2533;
            if (pstream__) {
                stan_print(pstream__,"mean = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2534;
            if (pstream__) {
                stan_print(pstream__,stan::model::rvalue(full_prediction, stan::model::cons_list(stan::model::index_uni(horizon), stan::model::cons_list(stan::model::index_min_max(1, p), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()))), "full_prediction"));
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2535;
            if (pstream__) {
                stan_print(pstream__,"cov = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2536;
            if (pstream__) {
                stan_print(pstream__,stan::model::rvalue(full_prediction, stan::model::cons_list(stan::model::index_uni(horizon), stan::model::cons_list(stan::model::index_min_max(1, p), stan::model::cons_list(stan::model::index_min_max(2, (p + 1)), stan::model::nil_index_list()))), "full_prediction"));
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2537;
            if (pstream__) {
                stan_print(pstream__,"ls = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2538;
            if (pstream__) {
                stan_print(pstream__,multi_normal_log(get_base1(y, (t + horizon), "y", 1), stan::model::rvalue(full_prediction, stan::model::cons_list(stan::model::index_uni(horizon), stan::model::cons_list(stan::model::index_min_max(1, p), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()))), "full_prediction"), stan::model::rvalue(full_prediction, stan::model::cons_list(stan::model::index_uni(horizon), stan::model::cons_list(stan::model::index_min_max(1, p), stan::model::cons_list(stan::model::index_min_max(2, (p + 1)), stan::model::nil_index_list()))), "full_prediction")));
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2541;
            if (as_bool(logical_lt(t, (n - horizon)))) {
                current_statement_begin__ = 2542;
                stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
                current_statement_begin__ = 2545;
                if (as_bool(logical_lt(converged, 1))) {
                    current_statement_begin__ = 2546;
                    stan::math::assign(P_old, P);
                    current_statement_begin__ = 2547;
                    stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
                    current_statement_begin__ = 2548;
                    stan::math::assign(matdiff, matrix_diff(P, P_old, pstream__));
                    current_statement_begin__ = 2549;
                    if (as_bool(logical_lt(matdiff, tol))) {
                        current_statement_begin__ = 2550;
                        stan::math::assign(converged, 1);
                    }
                }
            }
        }
        }
        current_statement_begin__ = 2556;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_forecast_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) {
    return ssm_constant_forecast_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1,horizon, pstream__);
}
struct ssm_constant_forecast_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) const {
        return ssm_constant_forecast_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic, 1> >
ssm_smooth_states_mean(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                           const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                           const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, 1> >& c,
                           const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                           const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                           const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& Q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2604;
        validate_non_negative_index("alpha", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("alpha", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(alpha, DUMMY_VAR__);
        stan::math::fill(alpha, DUMMY_VAR__);
        current_statement_begin__ = 2605;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2606;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2607;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2608;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2609;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 2610;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2611;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2612;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2614;
        validate_non_negative_index("r", "m", m);
        validate_non_negative_index("r", "(n + 1)", (n + 1));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > r((n + 1), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 2615;
        validate_non_negative_index("u", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> u(p);
        stan::math::initialize(u, DUMMY_VAR__);
        stan::math::fill(u, DUMMY_VAR__);
        current_statement_begin__ = 2616;
        validate_non_negative_index("a1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a1(m);
        stan::math::initialize(a1, DUMMY_VAR__);
        stan::math::fill(a1, DUMMY_VAR__);
        current_statement_begin__ = 2617;
        validate_non_negative_index("P1", "m", m);
        validate_non_negative_index("P1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
        stan::math::initialize(P1, DUMMY_VAR__);
        stan::math::fill(P1, DUMMY_VAR__);
        current_statement_begin__ = 2619;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2620;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2621;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2623;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 2624;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 2625;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 2626;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 2627;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 2628;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2630;
        if (as_bool(logical_eq(size(c), 1))) {
            current_statement_begin__ = 2631;
            stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        }
        current_statement_begin__ = 2633;
        if (as_bool(logical_eq(size(Z), 1))) {
            current_statement_begin__ = 2634;
            stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        }
        current_statement_begin__ = 2636;
        if (as_bool(logical_eq(size(T), 1))) {
            current_statement_begin__ = 2637;
            stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        }
        current_statement_begin__ = 2639;
        if (as_bool(logical_eq(size(R), 1))) {
            current_statement_begin__ = 2640;
            stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        }
        current_statement_begin__ = 2642;
        if (as_bool(logical_eq(size(Q), 1))) {
            current_statement_begin__ = 2643;
            stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        }
        current_statement_begin__ = 2645;
        if (as_bool((primitive_value(logical_eq(size(Q), 1)) && primitive_value(logical_eq(size(R), 1))))) {
            current_statement_begin__ = 2646;
            stan::math::assign(RQR, quad_form_sym(get_base1(Q, 1, "Q", 1), transpose(get_base1(R, 1, "R", 1))));
        }
        current_statement_begin__ = 2655;
        stan::model::assign(r, 
                    stan::model::cons_list(stan::model::index_uni((n + 1)), stan::model::nil_index_list()), 
                    rep_vector(0.0, m), 
                    "assigning variable r");
        current_statement_begin__ = 2656;
        for (int s = 0; s <= (n - 1); ++s) {
            {
            current_statement_begin__ = 2657;
            int t(0);
            (void) t;  // dummy to suppress unused var warning
            stan::math::fill(t, std::numeric_limits<int>::min());
            current_statement_begin__ = 2659;
            stan::math::assign(t, (n - s));
            current_statement_begin__ = 2661;
            if (as_bool(logical_gt(size(Z), 1))) {
                current_statement_begin__ = 2662;
                stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
            }
            current_statement_begin__ = 2664;
            if (as_bool(logical_gt(size(T), 1))) {
                current_statement_begin__ = 2665;
                stan::math::assign(T_t, get_base1(T, t, "T", 1));
            }
            current_statement_begin__ = 2668;
            stan::math::assign(K, ssm_filter_get_K(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2669;
            stan::math::assign(v, ssm_filter_get_v(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2670;
            stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2672;
            stan::math::assign(u, subtract(multiply(Finv, v), multiply(transpose(K), get_base1(r, (t + 1), "r", 1))));
            current_statement_begin__ = 2674;
            stan::model::assign(r, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        add(multiply(transpose(Z_t), u), multiply(transpose(T_t), get_base1(r, (t + 1), "r", 1))), 
                        "assigning variable r");
            }
        }
        current_statement_begin__ = 2677;
        stan::math::assign(a1, ssm_filter_get_a(get_base1(filter, 1, "filter", 1), m, p, pstream__));
        current_statement_begin__ = 2678;
        stan::math::assign(P1, ssm_filter_get_P(get_base1(filter, 1, "filter", 1), m, p, pstream__));
        current_statement_begin__ = 2680;
        stan::model::assign(alpha, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    add(a1, multiply(P1, get_base1(r, 1, "r", 1))), 
                    "assigning variable alpha");
        current_statement_begin__ = 2682;
        for (int t = 1; t <= (n - 1); ++t) {
            current_statement_begin__ = 2683;
            if (as_bool(logical_gt(size(c), 1))) {
                current_statement_begin__ = 2684;
                stan::math::assign(c_t, get_base1(c, t, "c", 1));
            }
            current_statement_begin__ = 2686;
            if (as_bool(logical_gt(size(T), 1))) {
                current_statement_begin__ = 2687;
                stan::math::assign(T_t, get_base1(T, t, "T", 1));
            }
            current_statement_begin__ = 2689;
            if (as_bool(logical_gt(size(Q), 1))) {
                current_statement_begin__ = 2690;
                stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
            }
            current_statement_begin__ = 2692;
            if (as_bool(logical_gt(size(R), 1))) {
                current_statement_begin__ = 2693;
                stan::math::assign(R_t, get_base1(R, t, "R", 1));
            }
            current_statement_begin__ = 2695;
            if (as_bool((primitive_value(logical_gt(size(Q), 1)) || primitive_value(logical_gt(size(R), 1))))) {
                current_statement_begin__ = 2696;
                stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
            }
            current_statement_begin__ = 2700;
            stan::model::assign(alpha, 
                        stan::model::cons_list(stan::model::index_uni((t + 1)), stan::model::nil_index_list()), 
                        add(add(c_t, multiply(T_t, get_base1(alpha, t, "alpha", 1))), multiply(RQR, get_base1(r, (t + 1), "r", 1))), 
                        "assigning variable alpha");
        }
        }
        current_statement_begin__ = 2703;
        return stan::math::promote_scalar<fun_return_scalar_t__>(alpha);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_smooth_states_mean_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                           const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                           const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, 1> >& c,
                           const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                           const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                           const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& Q, std::ostream* pstream__) const {
        return ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__);
    }
};
std::vector<std::vector<int> >
ssm_sim_idx(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2734;
        validate_non_negative_index("sz", "2", 2);
        validate_non_negative_index("sz", "3", 3);
        std::vector<std::vector<int  >  > sz(2, std::vector<int>(3, int(0)));
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 2736;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    p, 
                    "assigning variable sz");
        current_statement_begin__ = 2738;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    m, 
                    "assigning variable sz");
        current_statement_begin__ = 2740;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 2741;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 1, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 1, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2742;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    (get_base1(get_base1(sz, (2 - 1), "sz", 1), 3, "sz", 2) + 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2743;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 2, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 2, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2744;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_idx_functor__ {
            std::vector<std::vector<int> >
    operator()(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) const {
        return ssm_sim_idx(m, p, q, pstream__);
    }
};
int
ssm_sim_size(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2767;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 2768;
        stan::math::assign(sz, get_base1(get_base1(ssm_sim_idx(m, p, q, pstream__), 2, "ssm_sim_idx(m, p, q, pstream__)", 1), 3, "ssm_sim_idx(m, p, q, pstream__)", 2));
        current_statement_begin__ = 2769;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_size_functor__ {
            int
    operator()(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) const {
        return ssm_sim_size(m, p, q, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_sim_get_y(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2792;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2793;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2794;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2795;
        stan::math::assign(y, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 1, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 1, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list()), "x"));
        current_statement_begin__ = 2796;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_get_y_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_y(x, m, p, q, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_sim_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2819;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2820;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2821;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2822;
        stan::math::assign(a, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list()), "x"));
        current_statement_begin__ = 2823;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_get_a_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_a(x, m, p, q, pstream__);
    }
};
template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_sim_rng(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2889;
        validate_non_negative_index("ret", "ssm_sim_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), get_base1(dims(Q), 2, \"dims(Q)\", 1), pstream__)", ssm_sim_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), get_base1(dims(Q), 2, "dims(Q)", 1), pstream__));
        validate_non_negative_index("ret", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > ret(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), get_base1(dims(Q), 2, "dims(Q)", 1), pstream__)));
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 2890;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2891;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2892;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2893;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2894;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2895;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2898;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 2899;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 2900;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 2901;
        validate_non_negative_index("HL", "p", p);
        validate_non_negative_index("HL", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> HL(p, p);
        stan::math::initialize(HL, DUMMY_VAR__);
        stan::math::fill(HL, DUMMY_VAR__);
        current_statement_begin__ = 2902;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 2903;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 2904;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 2905;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 2906;
        validate_non_negative_index("QL", "q", q);
        validate_non_negative_index("QL", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> QL(q, q);
        stan::math::initialize(QL, DUMMY_VAR__);
        stan::math::fill(QL, DUMMY_VAR__);
        current_statement_begin__ = 2908;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2909;
        validate_non_negative_index("eps", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(p);
        stan::math::initialize(eps, DUMMY_VAR__);
        stan::math::fill(eps, DUMMY_VAR__);
        current_statement_begin__ = 2910;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2911;
        validate_non_negative_index("eta", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eta(q);
        stan::math::initialize(eta, DUMMY_VAR__);
        stan::math::fill(eta, DUMMY_VAR__);
        current_statement_begin__ = 2913;
        validate_non_negative_index("zero_p", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_p(p);
        stan::math::initialize(zero_p, DUMMY_VAR__);
        stan::math::fill(zero_p, DUMMY_VAR__);
        current_statement_begin__ = 2914;
        validate_non_negative_index("zero_q", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_q(q);
        stan::math::initialize(zero_q, DUMMY_VAR__);
        stan::math::fill(zero_q, DUMMY_VAR__);
        current_statement_begin__ = 2915;
        validate_non_negative_index("zero_m", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_m(m);
        stan::math::initialize(zero_m, DUMMY_VAR__);
        stan::math::fill(zero_m, DUMMY_VAR__);
        current_statement_begin__ = 2916;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2918;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 2919;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 2920;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 2921;
        stan::math::assign(HL, cholesky_decompose2(H_t, pstream__));
        current_statement_begin__ = 2922;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 2923;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 2924;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 2925;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 2926;
        stan::math::assign(QL, cholesky_decompose2(Q_t, pstream__));
        current_statement_begin__ = 2928;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2929;
        stan::math::assign(zero_p, rep_vector(0.0, p));
        current_statement_begin__ = 2930;
        stan::math::assign(zero_q, rep_vector(0.0, q));
        current_statement_begin__ = 2931;
        stan::math::assign(zero_m, rep_vector(0.0, m));
        current_statement_begin__ = 2932;
        stan::math::assign(a, multi_normal2_rng(a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 2933;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2935;
            stan::model::assign(ret, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable ret");
            current_statement_begin__ = 2937;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 2938;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 2939;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 2941;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 2942;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 2944;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 2945;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                    current_statement_begin__ = 2946;
                    stan::math::assign(HL, cholesky_decompose2(H_t, pstream__));
                }
            }
            current_statement_begin__ = 2950;
            stan::math::assign(eps, multi_normal_cholesky2_rng(zero_p, HL, base_rng__, pstream__));
            current_statement_begin__ = 2951;
            stan::math::assign(y, add(add(d_t, multiply(Z_t, a)), eps));
            current_statement_begin__ = 2953;
            stan::model::assign(ret, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 1, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 1, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        y, 
                        "assigning variable ret");
            current_statement_begin__ = 2955;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 2956;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 2957;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 2959;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 2960;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 2962;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 2963;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 2965;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 2966;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    current_statement_begin__ = 2967;
                    stan::math::assign(QL, cholesky_decompose2(Q_t, pstream__));
                }
                current_statement_begin__ = 2969;
                stan::math::assign(eta, multi_normal_cholesky2_rng(zero_q, QL, base_rng__, pstream__));
                current_statement_begin__ = 2970;
                stan::math::assign(a, add(add(c_t, multiply(T_t, a)), multiply(R_t, eta)));
            }
        }
        }
        current_statement_begin__ = 2974;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_rng_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_simsmo_states_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3028;
        validate_non_negative_index("draws", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("draws", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > draws(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(draws, DUMMY_VAR__);
        stan::math::fill(draws, DUMMY_VAR__);
        current_statement_begin__ = 3029;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3030;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3031;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3032;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 3033;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 3034;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 3035;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 3036;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 3038;
        validate_non_negative_index("filter_plus", "ssm_filter_size(m, p, pstream__)", ssm_filter_size(m, p, pstream__));
        validate_non_negative_index("filter_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > filter_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(m, p, pstream__)));
        stan::math::initialize(filter_plus, DUMMY_VAR__);
        stan::math::fill(filter_plus, DUMMY_VAR__);
        current_statement_begin__ = 3039;
        validate_non_negative_index("sims", "ssm_sim_size(m, p, q, pstream__)", ssm_sim_size(m, p, q, pstream__));
        validate_non_negative_index("sims", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > sims(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(m, p, q, pstream__)));
        stan::math::initialize(sims, DUMMY_VAR__);
        stan::math::fill(sims, DUMMY_VAR__);
        current_statement_begin__ = 3040;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > y(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(p));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 3041;
        validate_non_negative_index("alpha_hat_plus", "m", m);
        validate_non_negative_index("alpha_hat_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat_plus, DUMMY_VAR__);
        stan::math::fill(alpha_hat_plus, DUMMY_VAR__);
        current_statement_begin__ = 3042;
        validate_non_negative_index("alpha_hat", "m", m);
        validate_non_negative_index("alpha_hat", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat, DUMMY_VAR__);
        stan::math::fill(alpha_hat, DUMMY_VAR__);
        current_statement_begin__ = 3044;
        stan::math::assign(alpha_hat, ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 3046;
        stan::math::assign(sims, ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 3047;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3048;
            stan::model::assign(y, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ssm_sim_get_y(get_base1(sims, i, "sims", 1), m, p, q, pstream__), 
                        "assigning variable y");
        }
        current_statement_begin__ = 3051;
        stan::math::assign(filter_plus, ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__));
        current_statement_begin__ = 3053;
        stan::math::assign(alpha_hat_plus, ssm_smooth_states_mean(filter_plus, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 3054;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3055;
            stan::model::assign(draws, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        add(subtract(ssm_sim_get_a(get_base1(sims, i, "sims", 1), m, p, q, pstream__), get_base1(alpha_hat_plus, i, "alpha_hat_plus", 1)), get_base1(alpha_hat, i, "alpha_hat", 1)), 
                        "assigning variable draws");
        }
        }
        current_statement_begin__ = 3060;
        return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_simsmo_states_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_rng(filter, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_simsmo_states_miss_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const std::vector<int>& p_t,
                               const std::vector<std::vector<int> >& y_idx, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3106;
        validate_non_negative_index("draws", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("draws", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > draws(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(draws, DUMMY_VAR__);
        stan::math::fill(draws, DUMMY_VAR__);
        current_statement_begin__ = 3107;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3108;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3109;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3110;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 3111;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 3112;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 3113;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 3114;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 3116;
        validate_non_negative_index("filter_plus", "ssm_filter_size(m, p, pstream__)", ssm_filter_size(m, p, pstream__));
        validate_non_negative_index("filter_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > filter_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(m, p, pstream__)));
        stan::math::initialize(filter_plus, DUMMY_VAR__);
        stan::math::fill(filter_plus, DUMMY_VAR__);
        current_statement_begin__ = 3117;
        validate_non_negative_index("sims", "ssm_sim_size(m, p, q, pstream__)", ssm_sim_size(m, p, q, pstream__));
        validate_non_negative_index("sims", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > sims(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(m, p, q, pstream__)));
        stan::math::initialize(sims, DUMMY_VAR__);
        stan::math::fill(sims, DUMMY_VAR__);
        current_statement_begin__ = 3118;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > y(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(p));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 3119;
        validate_non_negative_index("alpha_hat_plus", "m", m);
        validate_non_negative_index("alpha_hat_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat_plus, DUMMY_VAR__);
        stan::math::fill(alpha_hat_plus, DUMMY_VAR__);
        current_statement_begin__ = 3120;
        validate_non_negative_index("alpha_hat", "m", m);
        validate_non_negative_index("alpha_hat", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat, DUMMY_VAR__);
        stan::math::fill(alpha_hat, DUMMY_VAR__);
        current_statement_begin__ = 3122;
        stan::math::assign(alpha_hat, ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 3124;
        stan::math::assign(sims, ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 3125;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3126;
            stan::model::assign(y, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ssm_sim_get_y(get_base1(sims, i, "sims", 1), m, p, q, pstream__), 
                        "assigning variable y");
        }
        current_statement_begin__ = 3129;
        stan::math::assign(filter_plus, ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__));
        current_statement_begin__ = 3132;
        stan::math::assign(alpha_hat_plus, ssm_smooth_states_mean(filter_plus, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 3133;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3134;
            stan::model::assign(draws, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        add(subtract(ssm_sim_get_a(get_base1(sims, i, "sims", 1), m, p, q, pstream__), get_base1(alpha_hat_plus, i, "alpha_hat_plus", 1)), get_base1(alpha_hat, i, "alpha_hat", 1)), 
                        "assigning variable draws");
        }
        }
        current_statement_begin__ = 3139;
        return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_simsmo_states_miss_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const std::vector<int>& p_t,
                               const std::vector<std::vector<int> >& y_idx, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_miss_rng(filter, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, base_rng__, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
pacf_to_acf(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3164;
        validate_non_negative_index("x_new", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> x_new(num_elements(x));
        stan::math::initialize(x_new, DUMMY_VAR__);
        stan::math::fill(x_new, DUMMY_VAR__);
        current_statement_begin__ = 3165;
        validate_non_negative_index("work", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> work(num_elements(x));
        stan::math::initialize(work, DUMMY_VAR__);
        stan::math::fill(work, DUMMY_VAR__);
        current_statement_begin__ = 3166;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 3167;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3168;
        stan::math::assign(p, num_elements(x));
        current_statement_begin__ = 3169;
        stan::math::assign(work, x);
        current_statement_begin__ = 3170;
        stan::math::assign(x_new, x);
        current_statement_begin__ = 3171;
        if (as_bool(logical_gt(p, 1))) {
            current_statement_begin__ = 3172;
            for (int j = 2; j <= p; ++j) {
                current_statement_begin__ = 3173;
                stan::math::assign(a, get_base1(x_new, j, "x_new", 1));
                current_statement_begin__ = 3174;
                for (int k = 1; k <= (j - 1); ++k) {
                    current_statement_begin__ = 3175;
                    stan::model::assign(work, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                (get_base1(work, k, "work", 1) - (a * get_base1(x_new, (j - k), "x_new", 1))), 
                                "assigning variable work");
                }
                current_statement_begin__ = 3177;
                for (int k = 1; k <= j; ++k) {
                    current_statement_begin__ = 3178;
                    stan::model::assign(x_new, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                get_base1(work, k, "work", 1), 
                                "assigning variable x_new");
                }
            }
        }
        current_statement_begin__ = 3182;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct pacf_to_acf_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return pacf_to_acf(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
constrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3222;
        validate_non_negative_index("r", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r(num_elements(x));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 3223;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3224;
        stan::math::assign(n, num_elements(x));
        current_statement_begin__ = 3226;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3227;
            stan::model::assign(r, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        stan::math::tanh(get_base1(x, i, "x", 1)), 
                        "assigning variable r");
        }
        current_statement_begin__ = 3230;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pacf_to_acf(r, pstream__));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct constrain_stationary_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return constrain_stationary(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
acf_to_pacf(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3251;
        validate_non_negative_index("x_new", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> x_new(num_elements(x));
        stan::math::initialize(x_new, DUMMY_VAR__);
        stan::math::fill(x_new, DUMMY_VAR__);
        current_statement_begin__ = 3252;
        validate_non_negative_index("work", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> work(num_elements(x));
        stan::math::initialize(work, DUMMY_VAR__);
        stan::math::fill(work, DUMMY_VAR__);
        current_statement_begin__ = 3253;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 3254;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3255;
        stan::math::assign(p, num_elements(x));
        current_statement_begin__ = 3256;
        stan::math::assign(work, x);
        current_statement_begin__ = 3257;
        stan::math::assign(x_new, x);
        current_statement_begin__ = 3259;
        if (as_bool(logical_gt(p, 1))) {
            current_statement_begin__ = 3260;
            for (int i = 0; i <= (p - 2); ++i) {
                {
                current_statement_begin__ = 3261;
                int j(0);
                (void) j;  // dummy to suppress unused var warning
                stan::math::fill(j, std::numeric_limits<int>::min());
                current_statement_begin__ = 3262;
                stan::math::assign(j, (p - i));
                current_statement_begin__ = 3263;
                stan::math::assign(a, get_base1(x_new, j, "x_new", 1));
                current_statement_begin__ = 3264;
                for (int k = 1; k <= (j - 1); ++k) {
                    current_statement_begin__ = 3265;
                    stan::model::assign(work, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                ((get_base1(x_new, k, "x_new", 1) + (a * get_base1(x_new, (j - k), "x_new", 1))) / (1 - pow(a, 2))), 
                                "assigning variable work");
                }
                current_statement_begin__ = 3267;
                for (int k = 1; k <= j; ++k) {
                    current_statement_begin__ = 3268;
                    stan::model::assign(x_new, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                get_base1(work, k, "work", 1), 
                                "assigning variable x_new");
                }
                }
            }
        }
        current_statement_begin__ = 3272;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct acf_to_pacf_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return acf_to_pacf(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
unconstrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3289;
        validate_non_negative_index("y", "num_elements(x)", num_elements(x));
        validate_non_negative_index("y", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(num_elements(x), num_elements(x));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 3290;
        validate_non_negative_index("r", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r(num_elements(x));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 3291;
        validate_non_negative_index("z", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> z(num_elements(x));
        stan::math::initialize(z, DUMMY_VAR__);
        stan::math::fill(z, DUMMY_VAR__);
        current_statement_begin__ = 3292;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3293;
        stan::math::assign(n, num_elements(x));
        current_statement_begin__ = 3295;
        stan::math::assign(r, acf_to_pacf(x, pstream__));
        current_statement_begin__ = 3297;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3298;
            stan::model::assign(z, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        stan::math::atanh(get_base1(r, i, "r", 1)), 
                        "assigning variable z");
        }
        current_statement_begin__ = 3300;
        return stan::math::promote_scalar<fun_return_scalar_t__>(z);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct unconstrain_stationary_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return unconstrain_stationary(x, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
kronecker_prod(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3327;
        validate_non_negative_index("C", "(rows(A) * rows(B))", (rows(A) * rows(B)));
        validate_non_negative_index("C", "(cols(A) * cols(B))", (cols(A) * cols(B)));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> C((rows(A) * rows(B)), (cols(A) * cols(B)));
        stan::math::initialize(C, DUMMY_VAR__);
        stan::math::fill(C, DUMMY_VAR__);
        current_statement_begin__ = 3328;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3329;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3330;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3331;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 3332;
        stan::math::assign(m, rows(A));
        current_statement_begin__ = 3333;
        stan::math::assign(n, cols(A));
        current_statement_begin__ = 3334;
        stan::math::assign(p, rows(B));
        current_statement_begin__ = 3335;
        stan::math::assign(q, cols(B));
        current_statement_begin__ = 3336;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 3337;
            for (int j = 1; j <= n; ++j) {
                {
                current_statement_begin__ = 3338;
                int row_start(0);
                (void) row_start;  // dummy to suppress unused var warning
                stan::math::fill(row_start, std::numeric_limits<int>::min());
                current_statement_begin__ = 3339;
                int row_end(0);
                (void) row_end;  // dummy to suppress unused var warning
                stan::math::fill(row_end, std::numeric_limits<int>::min());
                current_statement_begin__ = 3340;
                int col_start(0);
                (void) col_start;  // dummy to suppress unused var warning
                stan::math::fill(col_start, std::numeric_limits<int>::min());
                current_statement_begin__ = 3341;
                int col_end(0);
                (void) col_end;  // dummy to suppress unused var warning
                stan::math::fill(col_end, std::numeric_limits<int>::min());
                current_statement_begin__ = 3342;
                stan::math::assign(row_start, (((i - 1) * p) + 1));
                current_statement_begin__ = 3343;
                stan::math::assign(row_end, (((i - 1) * p) + p));
                current_statement_begin__ = 3344;
                stan::math::assign(col_start, (((j - 1) * q) + 1));
                current_statement_begin__ = 3345;
                stan::math::assign(col_end, (((j - 1) * q) + q));
                current_statement_begin__ = 3346;
                stan::model::assign(C, 
                            stan::model::cons_list(stan::model::index_min_max(row_start, row_end), stan::model::cons_list(stan::model::index_min_max(col_start, col_end), stan::model::nil_index_list())), 
                            multiply(get_base1(A, i, j, "A", 1), B), 
                            "assigning variable C");
                }
            }
        }
        current_statement_begin__ = 3349;
        return stan::math::promote_scalar<fun_return_scalar_t__>(C);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct kronecker_prod_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return kronecker_prod(A, B, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
stationary_cov(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& T,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3391;
        validate_non_negative_index("P", "rows(T)", rows(T));
        validate_non_negative_index("P", "cols(T)", cols(T));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(rows(T), cols(T));
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 3392;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3393;
        stan::math::assign(m, rows(T));
        current_statement_begin__ = 3396;
        if (as_bool(logical_eq(m, 1))) {
            current_statement_begin__ = 3397;
            stan::model::assign(P, 
                        stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        (get_base1(RQR, 1, 1, "RQR", 1) / (1.0 - pow(get_base1(T, 1, 1, "T", 1), 2))), 
                        "assigning variable P");
        } else {
            {
            current_statement_begin__ = 3399;
            validate_non_negative_index("TT", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            validate_non_negative_index("TT", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> TT((rows(T) * rows(T)), (rows(T) * rows(T)));
            stan::math::initialize(TT, DUMMY_VAR__);
            stan::math::fill(TT, DUMMY_VAR__);
            current_statement_begin__ = 3400;
            validate_non_negative_index("RQR_vec", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> RQR_vec((rows(T) * rows(T)));
            stan::math::initialize(RQR_vec, DUMMY_VAR__);
            stan::math::fill(RQR_vec, DUMMY_VAR__);
            current_statement_begin__ = 3401;
            int m2(0);
            (void) m2;  // dummy to suppress unused var warning
            stan::math::fill(m2, std::numeric_limits<int>::min());
            current_statement_begin__ = 3402;
            stan::math::assign(m2, (m * m));
            current_statement_begin__ = 3403;
            stan::math::assign(RQR_vec, to_vector(RQR));
            current_statement_begin__ = 3405;
            stan::math::assign(TT, minus(kronecker_prod(T, T, pstream__)));
            current_statement_begin__ = 3406;
            for (int i = 1; i <= m2; ++i) {
                current_statement_begin__ = 3407;
                stan::model::assign(TT, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            (1.0 + get_base1(TT, i, i, "TT", 1)), 
                            "assigning variable TT");
            }
            current_statement_begin__ = 3409;
            stan::math::assign(P, to_matrix_colwise(multiply(inverse(TT), RQR_vec), m, m, pstream__));
            }
        }
        current_statement_begin__ = 3411;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct stationary_cov_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& T,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) const {
        return stationary_cov(T, RQR, pstream__);
    }
};
#include <stan_meta_header.hpp>
class model_functions
  : public stan::model::model_base_crtp<model_functions> {
private:
public:
    model_functions(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, 0, pstream__);
    }
    model_functions(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, random_seed__, pstream__);
    }
    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning
        current_statement_begin__ = -1;
        static const char* function__ = "model_functions_namespace::model_functions";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        try {
            // initialize data block variables from context__
            // initialize transformed data variables
            // execute transformed data statements
            // validate transformed data
            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    ~model_functions() { }
    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        typedef double local_scalar_t__;
        stan::io::writer<double> writer__(params_r__, params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;
        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }
    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }
    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(std::vector<T__>& params_r__,
                 std::vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {
        typedef T__ local_scalar_t__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // dummy to suppress unused var warning
        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;
        try {
            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
            // model parameters
            // model body
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
        lp_accum__.add(lp__);
        return lp_accum__.sum();
    } // log_prob()
    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }
    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
    }
    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
    }
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;
        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
        static const char* function__ = "model_functions_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        if (!include_tparams__ && !include_gqs__) return;
        try {
            if (!include_gqs__ && !include_tparams__) return;
            if (!include_gqs__) return;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }
    std::string model_name() const {
        return "model_functions";
    }
    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
        }
        if (!include_gqs__) return;
    }
    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
        }
        if (!include_gqs__) return;
    }
}; // model
}  // namespace
typedef model_functions_namespace::model_functions stan_model;
#ifndef USING_R
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
#endif
#endif
