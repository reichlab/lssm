// Generated by rstantools.  Do not edit by hand.

/*
    lssm is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    lssm is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with lssm.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.21.0
#include <stan/model/model_header.hpp>
namespace model_SARIMA_model_namespace {
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;
static int current_statement_begin__;
stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_SARIMA_model");
    reader.add_event(1, 1, "include", "/lib/functions.stan");
    reader.add_event(1, 0, "start", "/lib/functions.stan");
    reader.add_event(3420, 3419, "end", "/lib/functions.stan");
    reader.add_event(3420, 2, "restart", "model_SARIMA_model");
    reader.add_event(3420, 2, "include", "/lib/sarima_utils.stan");
    reader.add_event(3420, 0, "start", "/lib/sarima_utils.stan");
    reader.add_event(3568, 148, "end", "/lib/sarima_utils.stan");
    reader.add_event(3568, 3, "restart", "model_SARIMA_model");
    reader.add_event(3720, 153, "end", "model_SARIMA_model");
    return reader;
}
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_symmetric_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 13;
        return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(0.5, add(x, transpose(x))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_symmetric_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_symmetric_matrix(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_spd_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 26;
        return stan::math::promote_scalar<fun_return_scalar_t__>(add_diag(multiply(0.5, add(x, transpose(x))), 0.00000001));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_spd_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_spd_matrix(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_matrix_colwise(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 44;
        validate_non_negative_index("res", "m", m);
        validate_non_negative_index("res", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> res(m, n);
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 45;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 46;
        stan::math::assign(k, 1);
        current_statement_begin__ = 48;
        for (int j = 1; j <= n; ++j) {
            current_statement_begin__ = 50;
            for (int i = 1; i <= m; ++i) {
                current_statement_begin__ = 51;
                stan::model::assign(res, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            get_base1(v, k, "v", 1), 
                            "assigning variable res");
                current_statement_begin__ = 52;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 55;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_matrix_colwise_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) const {
        return to_matrix_colwise(v, m, n, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
matrix_pow(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__);
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
matrix_pow(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 74;
        local_scalar_t__ nn(DUMMY_VAR__);
        (void) nn;  // dummy to suppress unused var warning
        stan::math::initialize(nn, DUMMY_VAR__);
        stan::math::fill(nn, DUMMY_VAR__);
        current_statement_begin__ = 75;
        stan::math::assign(nn, stan::math::floor(n));
        current_statement_begin__ = 76;
        if (as_bool(logical_eq(nn, 0))) {
            current_statement_begin__ = 77;
            return stan::math::promote_scalar<fun_return_scalar_t__>(diag_matrix(rep_vector(1., rows(A))));
        } else if (as_bool(logical_eq(nn, 1))) {
            current_statement_begin__ = 79;
            return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        } else if (as_bool(logical_gt(nn, 1))) {
            current_statement_begin__ = 82;
            if (as_bool(logical_gt(fmod(nn, 2.), 0))) {
                current_statement_begin__ = 84;
                return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(A, matrix_pow(A, (nn - 1), pstream__)));
            } else {
                current_statement_begin__ = 87;
                return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(matrix_pow(A, (nn / 2), pstream__), matrix_pow(A, (nn / 2), pstream__)));
            }
        } else {
            current_statement_begin__ = 91;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Only non-negative values of n are allowed";
            throw std::domain_error(errmsg_stream__.str());
            current_statement_begin__ = 92;
            return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct matrix_pow_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__) const {
        return matrix_pow(A, n, pstream__);
    }
};
int
symmat_size(const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 127;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 130;
        stan::math::assign(sz, 0);
        current_statement_begin__ = 131;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 132;
            stan::math::assign(sz, (sz + i));
        }
        current_statement_begin__ = 134;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct symmat_size_functor__ {
            int
    operator()(const int& n, std::ostream* pstream__) const {
        return symmat_size(n, pstream__);
    }
};
int
find_symmat_dim(const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 154;
        int i(0);
        (void) i;  // dummy to suppress unused var warning
        stan::math::fill(i, std::numeric_limits<int>::min());
        current_statement_begin__ = 155;
        int remainder(0);
        (void) remainder;  // dummy to suppress unused var warning
        stan::math::fill(remainder, std::numeric_limits<int>::min());
        current_statement_begin__ = 156;
        stan::math::assign(remainder, n);
        current_statement_begin__ = 157;
        stan::math::assign(i, 0);
        current_statement_begin__ = 158;
        while (as_bool(logical_gt(remainder, 0))) {
            current_statement_begin__ = 159;
            stan::math::assign(i, (i + 1));
            current_statement_begin__ = 160;
            stan::math::assign(remainder, (remainder - i));
        }
        current_statement_begin__ = 162;
        return stan::math::promote_scalar<fun_return_scalar_t__>(i);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct find_symmat_dim_functor__ {
            int
    operator()(const int& n, std::ostream* pstream__) const {
        return find_symmat_dim(n, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
vector_to_symmat(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 179;
        validate_non_negative_index("m", "n", n);
        validate_non_negative_index("m", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> m(n, n);
        stan::math::initialize(m, DUMMY_VAR__);
        stan::math::fill(m, DUMMY_VAR__);
        current_statement_begin__ = 180;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 181;
        stan::math::assign(k, 1);
        current_statement_begin__ = 183;
        for (int j = 1; j <= n; ++j) {
            current_statement_begin__ = 185;
            for (int i = j; i <= n; ++i) {
                current_statement_begin__ = 186;
                stan::model::assign(m, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            get_base1(x, k, "x", 1), 
                            "assigning variable m");
                current_statement_begin__ = 187;
                if (as_bool(logical_neq(i, j))) {
                    current_statement_begin__ = 188;
                    stan::model::assign(m, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                get_base1(m, i, j, "m", 1), 
                                "assigning variable m");
                }
                current_statement_begin__ = 190;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 193;
        return stan::math::promote_scalar<fun_return_scalar_t__>(m);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct vector_to_symmat_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& n, std::ostream* pstream__) const {
        return vector_to_symmat(x, n, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
symmat_to_vector(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 213;
        validate_non_negative_index("v", "symmat_size(std::min(rows(x), cols(x)), pstream__)", symmat_size(std::min(rows(x), cols(x)), pstream__));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(symmat_size(std::min(rows(x), cols(x)), pstream__));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 214;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 215;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 216;
        stan::math::assign(k, 1);
        current_statement_begin__ = 217;
        stan::math::assign(m, std::min(rows(x), cols(x)));
        current_statement_begin__ = 220;
        for (int j = 1; j <= m; ++j) {
            current_statement_begin__ = 221;
            for (int i = j; i <= m; ++i) {
                current_statement_begin__ = 222;
                stan::model::assign(v, 
                            stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                            get_base1(x, i, j, "x", 1), 
                            "assigning variable v");
                current_statement_begin__ = 223;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 226;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct symmat_to_vector_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return symmat_to_vector(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_lower_triangular_matrix(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 250;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 251;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 252;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 253;
                if (as_bool(logical_gt(i, j))) {
                    current_statement_begin__ = 254;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                x, 
                                "assigning variable A");
                } else if (as_bool(logical_eq(i, j))) {
                    current_statement_begin__ = 256;
                    if (as_bool(diag)) {
                        current_statement_begin__ = 257;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    x, 
                                    "assigning variable A");
                    } else {
                        current_statement_begin__ = 259;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    0., 
                                    "assigning variable A");
                    }
                } else {
                    current_statement_begin__ = 262;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                0., 
                                "assigning variable A");
                }
            }
        }
        current_statement_begin__ = 266;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_lower_triangular_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) const {
        return rep_lower_triangular_matrix(x, m, n, diag, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_upper_triangular_matrix(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 290;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 291;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 292;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 294;
                if (as_bool(logical_lt(i, j))) {
                    current_statement_begin__ = 295;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                x, 
                                "assigning variable A");
                } else if (as_bool(logical_eq(i, j))) {
                    current_statement_begin__ = 297;
                    if (as_bool(diag)) {
                        current_statement_begin__ = 298;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    x, 
                                    "assigning variable A");
                    } else {
                        current_statement_begin__ = 300;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    0., 
                                    "assigning variable A");
                    }
                } else {
                    current_statement_begin__ = 303;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                0., 
                                "assigning variable A");
                }
            }
        }
        current_statement_begin__ = 307;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_upper_triangular_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) const {
        return rep_upper_triangular_matrix(x, m, n, diag, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_diagonal_matrix(const T0__& x,
                        const int& m,
                        const int& n,
                        const int& k, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 332;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 333;
        int mn(0);
        (void) mn;  // dummy to suppress unused var warning
        stan::math::fill(mn, std::numeric_limits<int>::min());
        current_statement_begin__ = 334;
        stan::math::assign(A, rep_matrix(0., m, n));
        current_statement_begin__ = 335;
        stan::math::assign(mn, std::min(m, n));
        current_statement_begin__ = 336;
        if (as_bool(logical_gte(k, 0))) {
            current_statement_begin__ = 337;
            for (int i = 1; i <= std::min(m, (n - k)); ++i) {
                current_statement_begin__ = 338;
                stan::model::assign(A, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni((i + k)), stan::model::nil_index_list())), 
                            x, 
                            "assigning variable A");
            }
        } else {
            current_statement_begin__ = 341;
            for (int i = 1; i <= std::min((m + k), n); ++i) {
                current_statement_begin__ = 342;
                stan::model::assign(A, 
                            stan::model::cons_list(stan::model::index_uni((i - k)), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            x, 
                            "assigning variable A");
            }
        }
        current_statement_begin__ = 345;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_diagonal_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                        const int& m,
                        const int& n,
                        const int& k, std::ostream* pstream__) const {
        return rep_diagonal_matrix(x, m, n, k, pstream__);
    }
};
template <typename T0__, typename T5__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T5__>::type, Eigen::Dynamic, Eigen::Dynamic>
fill_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x,
                const int& m,
                const int& n,
                const std::vector<int>& i,
                const std::vector<int>& j,
                const T5__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T5__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 382;
        validate_non_negative_index("ret", "m", m);
        validate_non_negative_index("ret", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ret(m, n);
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 383;
        stan::math::assign(ret, rep_matrix(a, m, n));
        current_statement_begin__ = 384;
        stan::model::assign(ret, 
                    stan::model::cons_list(stan::model::index_multi(i), stan::model::cons_list(stan::model::index_multi(j), stan::model::nil_index_list())), 
                    x, 
                    "assigning variable ret");
        current_statement_begin__ = 385;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct fill_matrix_functor__ {
    template <typename T0__, typename T5__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T5__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x,
                const int& m,
                const int& n,
                const std::vector<int>& i,
                const std::vector<int>& j,
                const T5__& a, std::ostream* pstream__) const {
        return fill_matrix(x, m, n, i, j, a, pstream__);
    }
};
template <typename T0__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T3__>::type, Eigen::Dynamic, 1>
fill_vector(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                const int& n,
                const std::vector<int>& i,
                const T3__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 416;
        validate_non_negative_index("ret", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ret(n);
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 417;
        stan::math::assign(ret, rep_vector(a, n));
        current_statement_begin__ = 418;
        stan::model::assign(ret, 
                    stan::model::cons_list(stan::model::index_multi(i), stan::model::nil_index_list()), 
                    x, 
                    "assigning variable ret");
        current_statement_begin__ = 419;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct fill_vector_functor__ {
    template <typename T0__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                const int& n,
                const std::vector<int>& i,
                const T3__& a, std::ostream* pstream__) const {
        return fill_vector(x, n, i, a, pstream__);
    }
};
int
int_sum_true(const std::vector<int>& x, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 438;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 439;
        stan::math::assign(n, 0);
        current_statement_begin__ = 440;
        for (int i = 1; i <= num_elements(x); ++i) {
            current_statement_begin__ = 441;
            if (as_bool(int_step(get_base1(x, i, "x", 1)))) {
                current_statement_begin__ = 442;
                stan::math::assign(n, (n + 1));
            }
        }
        current_statement_begin__ = 445;
        return stan::math::promote_scalar<fun_return_scalar_t__>(n);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct int_sum_true_functor__ {
            int
    operator()(const std::vector<int>& x, std::ostream* pstream__) const {
        return int_sum_true(x, pstream__);
    }
};
int
int_sum_false(const std::vector<int>& x, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 464;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 465;
        stan::math::assign(n, 0);
        current_statement_begin__ = 466;
        for (int i = 1; i <= num_elements(x); ++i) {
            current_statement_begin__ = 467;
            if (as_bool(logical_negation(int_step(get_base1(x, i, "x", 1))))) {
                current_statement_begin__ = 468;
                stan::math::assign(n, (n + 1));
            }
        }
        current_statement_begin__ = 471;
        return stan::math::promote_scalar<fun_return_scalar_t__>(n);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct int_sum_false_functor__ {
            int
    operator()(const std::vector<int>& x, std::ostream* pstream__) const {
        return int_sum_false(x, pstream__);
    }
};
std::vector<int>
mask_indexes(const std::vector<int>& x,
                 const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 497;
        validate_non_negative_index("idx", "n", n);
        std::vector<int  > idx(n, int(0));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 498;
        int j(0);
        (void) j;  // dummy to suppress unused var warning
        stan::math::fill(j, std::numeric_limits<int>::min());
        current_statement_begin__ = 499;
        stan::math::assign(j, 1);
        current_statement_begin__ = 500;
        if (as_bool(logical_gt(n, 0))) {
            current_statement_begin__ = 501;
            for (int i = 1; i <= num_elements(x); ++i) {
                current_statement_begin__ = 502;
                if (as_bool((primitive_value(logical_negation(int_step(get_base1(x, i, "x", 1)))) && primitive_value(logical_lte(j, n))))) {
                    current_statement_begin__ = 503;
                    stan::model::assign(idx, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list()), 
                                i, 
                                "assigning variable idx");
                    current_statement_begin__ = 504;
                    stan::math::assign(j, (j + 1));
                }
            }
        }
        current_statement_begin__ = 508;
        return stan::math::promote_scalar<fun_return_scalar_t__>(idx);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct mask_indexes_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& x,
                 const int& n, std::ostream* pstream__) const {
        return mask_indexes(x, n, pstream__);
    }
};
std::vector<int>
select_indexes(const std::vector<int>& x,
                   const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 534;
        validate_non_negative_index("idx", "n", n);
        std::vector<int  > idx(n, int(0));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 535;
        int j(0);
        (void) j;  // dummy to suppress unused var warning
        stan::math::fill(j, std::numeric_limits<int>::min());
        current_statement_begin__ = 536;
        stan::math::assign(j, 1);
        current_statement_begin__ = 537;
        if (as_bool(logical_gt(n, 0))) {
            current_statement_begin__ = 538;
            for (int i = 1; i <= num_elements(x); ++i) {
                current_statement_begin__ = 539;
                if (as_bool((primitive_value(int_step(get_base1(x, i, "x", 1))) && primitive_value(logical_lte(j, n))))) {
                    current_statement_begin__ = 540;
                    stan::model::assign(idx, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list()), 
                                i, 
                                "assigning variable idx");
                    current_statement_begin__ = 541;
                    stan::math::assign(j, (j + 1));
                }
            }
        }
        current_statement_begin__ = 545;
        return stan::math::promote_scalar<fun_return_scalar_t__>(idx);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct select_indexes_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& x,
                   const int& n, std::ostream* pstream__) const {
        return select_indexes(x, n, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
normal2_rng(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 567;
        local_scalar_t__ y(DUMMY_VAR__);
        (void) y;  // dummy to suppress unused var warning
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 568;
        if (as_bool(logical_lte(sigma, 0))) {
            current_statement_begin__ = 569;
            stan::math::assign(y, mu);
        } else {
            current_statement_begin__ = 571;
            stan::math::assign(y, normal_rng(mu, sigma, base_rng__));
        }
        current_statement_begin__ = 573;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct normal2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return normal2_rng(mu, sigma, base_rng__, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
cholesky_decompose2(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 592;
        validate_non_negative_index("L", "rows(A)", rows(A));
        validate_non_negative_index("L", "cols(A)", cols(A));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> L(rows(A), cols(A));
        stan::math::initialize(L, DUMMY_VAR__);
        stan::math::fill(L, DUMMY_VAR__);
        current_statement_begin__ = 593;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 594;
        validate_non_negative_index("nonzero", "rows(A)", rows(A));
        std::vector<int  > nonzero(rows(A), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 595;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 596;
        stan::math::assign(n, rows(A));
        current_statement_begin__ = 597;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 598;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(A, i, i, "A", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 600;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 601;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 602;
            stan::math::assign(L, cholesky_decompose(A));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 604;
            stan::math::assign(L, rep_matrix(0.0, n, n));
        } else {
            {
            current_statement_begin__ = 606;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 607;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 608;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 609;
            stan::math::assign(L, rep_matrix(0.0, n, n));
            current_statement_begin__ = 610;
            stan::model::assign(L, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), 
                        cholesky_decompose(stan::model::rvalue(A, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "A")), 
                        "assigning variable L");
            }
        }
        current_statement_begin__ = 612;
        return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct cholesky_decompose2_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A, std::ostream* pstream__) const {
        return cholesky_decompose2(A, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
multi_normal2_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 636;
        validate_non_negative_index("y", "num_elements(mu)", num_elements(mu));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(num_elements(mu));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 637;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 638;
        validate_non_negative_index("nonzero", "num_elements(mu)", num_elements(mu));
        std::vector<int  > nonzero(num_elements(mu), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 639;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 640;
        stan::math::assign(n, num_elements(mu));
        current_statement_begin__ = 641;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 642;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(Sigma, i, i, "Sigma", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 644;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 645;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 646;
            stan::math::assign(y, multi_normal_rng(mu, Sigma, base_rng__));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 648;
            stan::math::assign(y, mu);
        } else {
            {
            current_statement_begin__ = 650;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 651;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 652;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 653;
            stan::math::assign(eps, rep_vector(0.0, n));
            current_statement_begin__ = 654;
            stan::model::assign(eps, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                        multi_normal_rng(rep_vector(0.0, num_nonzero), stan::model::rvalue(Sigma, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "Sigma"), base_rng__), 
                        "assigning variable eps");
            current_statement_begin__ = 655;
            stan::math::assign(y, add(mu, eps));
            }
        }
        current_statement_begin__ = 657;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct multi_normal2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return multi_normal2_rng(mu, Sigma, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
multi_normal_cholesky2_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& L, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 680;
        validate_non_negative_index("y", "num_elements(mu)", num_elements(mu));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(num_elements(mu));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 681;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 682;
        validate_non_negative_index("nonzero", "num_elements(mu)", num_elements(mu));
        std::vector<int  > nonzero(num_elements(mu), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 683;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 684;
        stan::math::assign(n, num_elements(mu));
        current_statement_begin__ = 685;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 686;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(L, i, i, "L", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 688;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 689;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 690;
            stan::math::assign(y, multi_normal_cholesky_rng(mu, L, base_rng__));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 692;
            stan::math::assign(y, mu);
        } else {
            {
            current_statement_begin__ = 694;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 695;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 696;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 697;
            stan::math::assign(eps, rep_vector(0.0, n));
            current_statement_begin__ = 698;
            stan::model::assign(eps, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                        multi_normal_cholesky_rng(rep_vector(0.0, num_nonzero), stan::model::rvalue(L, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "L"), base_rng__), 
                        "assigning variable eps");
            current_statement_begin__ = 700;
            stan::math::assign(y, add(mu, eps));
            }
        }
        current_statement_begin__ = 702;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct multi_normal_cholesky2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& L, RNG& base_rng__, std::ostream* pstream__) const {
        return multi_normal_cholesky2_rng(mu, L, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, 1>
ssm_update_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& c,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& v,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 740;
        validate_non_negative_index("a_new", "num_elements(a)", num_elements(a));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_new(num_elements(a));
        stan::math::initialize(a_new, DUMMY_VAR__);
        stan::math::fill(a_new, DUMMY_VAR__);
        current_statement_begin__ = 741;
        stan::math::assign(a_new, add(add(multiply(T, a), multiply(K, v)), c));
        current_statement_begin__ = 742;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_a_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& c,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& v,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_a(a, c, T, v, K, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_P(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& RQR,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 773;
        validate_non_negative_index("P_new", "rows(P)", rows(P));
        validate_non_negative_index("P_new", "cols(P)", cols(P));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_new(rows(P), cols(P));
        stan::math::initialize(P_new, DUMMY_VAR__);
        stan::math::fill(P_new, DUMMY_VAR__);
        current_statement_begin__ = 774;
        stan::math::assign(P_new, to_symmetric_matrix(add(multiply(multiply(T, P), transpose(subtract(T, multiply(K, Z)))), RQR), pstream__));
        current_statement_begin__ = 775;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_P_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& RQR,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_P(P, Z, T, RQR, K, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
ssm_update_v(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 804;
        validate_non_negative_index("v", "num_elements(y)", num_elements(y));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(num_elements(y));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 805;
        stan::math::assign(v, subtract(subtract(y, multiply(Z, a)), d));
        current_statement_begin__ = 806;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_v_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z, std::ostream* pstream__) const {
        return ssm_update_v(y, a, d, Z, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
ssm_update_v_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const int& p_t,
                      const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 846;
        validate_non_negative_index("v", "num_elements(y)", num_elements(y));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(num_elements(y));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 847;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 848;
        stan::math::assign(p, num_elements(y));
        current_statement_begin__ = 849;
        if (as_bool(logical_lt(p_t, p))) {
            current_statement_begin__ = 850;
            stan::math::assign(v, rep_vector(0., p));
            current_statement_begin__ = 851;
            if (as_bool(logical_gt(p_t, 0))) {
                {
                current_statement_begin__ = 852;
                validate_non_negative_index("idx", "p_t", p_t);
                std::vector<int  > idx(p_t, int(0));
                stan::math::fill(idx, std::numeric_limits<int>::min());
                current_statement_begin__ = 853;
                validate_non_negative_index("y_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y_star(p_t);
                stan::math::initialize(y_star, DUMMY_VAR__);
                stan::math::fill(y_star, DUMMY_VAR__);
                current_statement_begin__ = 854;
                validate_non_negative_index("d_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_star(p_t);
                stan::math::initialize(d_star, DUMMY_VAR__);
                stan::math::fill(d_star, DUMMY_VAR__);
                current_statement_begin__ = 855;
                validate_non_negative_index("Z_star", "p_t", p_t);
                validate_non_negative_index("Z_star", "cols(Z)", cols(Z));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_star(p_t, cols(Z));
                stan::math::initialize(Z_star, DUMMY_VAR__);
                stan::math::fill(Z_star, DUMMY_VAR__);
                current_statement_begin__ = 856;
                stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
                current_statement_begin__ = 857;
                stan::math::assign(y_star, stan::model::rvalue(y, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "y"));
                current_statement_begin__ = 858;
                stan::math::assign(d_star, stan::model::rvalue(d, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "d"));
                current_statement_begin__ = 859;
                stan::math::assign(Z_star, stan::model::rvalue(Z, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "Z"));
                current_statement_begin__ = 860;
                stan::model::assign(v, 
                            stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                            ssm_update_v(y_star, a, d_star, Z_star, pstream__), 
                            "assigning variable v");
                }
            }
        } else {
            current_statement_begin__ = 863;
            stan::math::assign(v, ssm_update_v(y, a, d, Z, pstream__));
        }
        current_statement_begin__ = 865;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_v_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const int& p_t,
                      const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_v_miss(y, a, d, Z, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_F(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 892;
        validate_non_negative_index("F", "rows(H)", rows(H));
        validate_non_negative_index("F", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> F(rows(H), cols(H));
        stan::math::initialize(F, DUMMY_VAR__);
        stan::math::fill(F, DUMMY_VAR__);
        current_statement_begin__ = 893;
        stan::math::assign(F, to_symmetric_matrix(add(quad_form_sym(P, transpose(Z)), H), pstream__));
        current_statement_begin__ = 894;
        return stan::math::promote_scalar<fun_return_scalar_t__>(F);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_F_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_F(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                    const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                    const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 918;
        validate_non_negative_index("Finv", "rows(H)", rows(H));
        validate_non_negative_index("Finv", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(rows(H), cols(H));
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 920;
        stan::math::assign(Finv, inverse(to_spd_matrix(add(quad_form_sym(P, transpose(Z)), H), pstream__)));
        current_statement_begin__ = 922;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_Finv_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                    const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                    const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_Finv(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_Finv_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                         const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                         const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H,
                         const int& p_t,
                         const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 955;
        validate_non_negative_index("Finv", "rows(H)", rows(H));
        validate_non_negative_index("Finv", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(rows(H), cols(H));
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 956;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 957;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 958;
        stan::math::assign(p, rows(H));
        current_statement_begin__ = 959;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 960;
        if (as_bool(logical_lt(p_t, p))) {
            current_statement_begin__ = 961;
            stan::math::assign(Finv, rep_matrix(0., p, p));
            current_statement_begin__ = 962;
            if (as_bool(logical_gt(p_t, 0))) {
                {
                current_statement_begin__ = 963;
                validate_non_negative_index("Z_star", "p_t", p_t);
                validate_non_negative_index("Z_star", "m", m);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_star(p_t, m);
                stan::math::initialize(Z_star, DUMMY_VAR__);
                stan::math::fill(Z_star, DUMMY_VAR__);
                current_statement_begin__ = 964;
                validate_non_negative_index("H_star", "p_t", p_t);
                validate_non_negative_index("H_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_star(p_t, p_t);
                stan::math::initialize(H_star, DUMMY_VAR__);
                stan::math::fill(H_star, DUMMY_VAR__);
                current_statement_begin__ = 965;
                validate_non_negative_index("idx", "p_t", p_t);
                std::vector<int  > idx(p_t, int(0));
                stan::math::fill(idx, std::numeric_limits<int>::min());
                current_statement_begin__ = 966;
                stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
                current_statement_begin__ = 967;
                stan::math::assign(Z_star, stan::model::rvalue(Z, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "Z"));
                current_statement_begin__ = 968;
                stan::math::assign(H_star, stan::model::rvalue(H, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "H"));
                current_statement_begin__ = 969;
                stan::model::assign(Finv, 
                            stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), 
                            ssm_update_Finv(P, Z_star, H_star, pstream__), 
                            "assigning variable Finv");
                }
            }
        } else {
            current_statement_begin__ = 972;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
        }
        current_statement_begin__ = 974;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_Finv_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                         const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                         const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H,
                         const int& p_t,
                         const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_Finv_miss(P, Z, H, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_K(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1003;
        validate_non_negative_index("K", "cols(Z)", cols(Z));
        validate_non_negative_index("K", "rows(Z)", rows(Z));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(cols(Z), rows(Z));
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1004;
        stan::math::assign(K, multiply(multiply(multiply(T, P), transpose(Z)), Finv));
        current_statement_begin__ = 1005;
        return stan::math::promote_scalar<fun_return_scalar_t__>(K);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_K_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_update_K(P, Z, T, Finv, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_L(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1032;
        validate_non_negative_index("L", "rows(T)", rows(T));
        validate_non_negative_index("L", "cols(T)", cols(T));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> L(rows(T), cols(T));
        stan::math::initialize(L, DUMMY_VAR__);
        stan::math::fill(L, DUMMY_VAR__);
        current_statement_begin__ = 1033;
        stan::math::assign(L, subtract(T, multiply(K, Z)));
        current_statement_begin__ = 1034;
        return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_L_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_L(Z, T, K, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_update_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1060;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1061;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1062;
        stan::math::assign(p, num_elements(v));
        current_statement_begin__ = 1064;
        stan::math::assign(ll, (-(0.5) * (((p * stan::math::log((2 * stan::math::pi()))) - log_determinant(Finv)) + quad_form_sym(Finv, v))));
        current_statement_begin__ = 1069;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_loglik_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_update_loglik(v, Finv, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_update_loglik_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv,
                           const int& p_t,
                           const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1096;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1097;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1098;
        stan::math::assign(p, num_elements(v));
        current_statement_begin__ = 1099;
        if (as_bool(logical_eq(p_t, 0))) {
            current_statement_begin__ = 1100;
            stan::math::assign(ll, 0.);
        } else if (as_bool(logical_eq(p_t, p))) {
            current_statement_begin__ = 1102;
            stan::math::assign(ll, ssm_update_loglik(v, Finv, pstream__));
        } else {
            {
            current_statement_begin__ = 1104;
            validate_non_negative_index("idx", "p_t", p_t);
            std::vector<int  > idx(p_t, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 1105;
            validate_non_negative_index("Finv_star", "p_t", p_t);
            validate_non_negative_index("Finv_star", "p_t", p_t);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv_star(p_t, p_t);
            stan::math::initialize(Finv_star, DUMMY_VAR__);
            stan::math::fill(Finv_star, DUMMY_VAR__);
            current_statement_begin__ = 1106;
            validate_non_negative_index("v_star", "p_t", p_t);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v_star(p_t);
            stan::math::initialize(v_star, DUMMY_VAR__);
            stan::math::fill(v_star, DUMMY_VAR__);
            current_statement_begin__ = 1107;
            stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
            current_statement_begin__ = 1108;
            stan::math::assign(Finv_star, stan::model::rvalue(Finv, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "Finv"));
            current_statement_begin__ = 1109;
            stan::math::assign(v_star, stan::model::rvalue(v, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "v"));
            current_statement_begin__ = 1110;
            stan::math::assign(ll, ssm_update_loglik(v_star, Finv_star, pstream__));
            }
        }
        current_statement_begin__ = 1112;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_loglik_miss_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv,
                           const int& p_t,
                           const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_loglik_miss(v, Finv, p_t, y_idx, pstream__);
    }
};
std::vector<std::vector<int> >
ssm_filter_idx(const int& m,
                   const int& p, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1151;
        validate_non_negative_index("sz", "6", 6);
        validate_non_negative_index("sz", "3", 3);
        std::vector<std::vector<int  >  > sz(6, std::vector<int>(3, int(0)));
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 1153;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 1155;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    p, 
                    "assigning variable sz");
        current_statement_begin__ = 1157;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(3), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    symmat_size(p, pstream__), 
                    "assigning variable sz");
        current_statement_begin__ = 1159;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(4), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    (m * p), 
                    "assigning variable sz");
        current_statement_begin__ = 1161;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(5), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    m, 
                    "assigning variable sz");
        current_statement_begin__ = 1163;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(6), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    symmat_size(m, pstream__), 
                    "assigning variable sz");
        current_statement_begin__ = 1165;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 1166;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 1, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 1, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 1167;
        for (int i = 2; i <= 6; ++i) {
            current_statement_begin__ = 1168;
            stan::model::assign(sz, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                        (get_base1(get_base1(sz, (i - 1), "sz", 1), 3, "sz", 2) + 1), 
                        "assigning variable sz");
            current_statement_begin__ = 1169;
            stan::model::assign(sz, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                        ((get_base1(get_base1(sz, i, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, i, "sz", 1), 1, "sz", 2)) - 1), 
                        "assigning variable sz");
        }
        current_statement_begin__ = 1171;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_idx_functor__ {
            std::vector<std::vector<int> >
    operator()(const int& m,
                   const int& p, std::ostream* pstream__) const {
        return ssm_filter_idx(m, p, pstream__);
    }
};
int
ssm_filter_size(const int& m,
                    const int& p, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1191;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 1192;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1193;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1194;
        stan::math::assign(sz, get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2));
        current_statement_begin__ = 1195;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_size_functor__ {
            int
    operator()(const int& m,
                    const int& p, std::ostream* pstream__) const {
        return ssm_filter_size(m, p, pstream__);
    }
};
template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
ssm_filter_get_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1217;
        local_scalar_t__ y(DUMMY_VAR__);
        (void) y;  // dummy to suppress unused var warning
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1218;
        stan::math::assign(y, get_base1(x, 1, "x", 1));
        current_statement_begin__ = 1219;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_loglik_functor__ {
    template <typename T0__>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_loglik(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_filter_get_v(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1241;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1242;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1243;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1244;
        stan::math::assign(y, segment(x, get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 1, "idx", 2)));
        current_statement_begin__ = 1245;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_v_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_v(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1267;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(p, p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1268;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1269;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1270;
        stan::math::assign(y, vector_to_symmat(segment(x, get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 1, "idx", 2)), p, pstream__));
        current_statement_begin__ = 1271;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_Finv_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_Finv(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_K(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1293;
        validate_non_negative_index("y", "m", m);
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(m, p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1294;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1295;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1296;
        stan::math::assign(y, to_matrix_colwise(segment(x, get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 1, "idx", 2)), m, p, pstream__));
        current_statement_begin__ = 1297;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_K_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_K(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_filter_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1319;
        validate_non_negative_index("y", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(m);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1320;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1321;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1322;
        stan::math::assign(y, segment(x, get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 1, "idx", 2)));
        current_statement_begin__ = 1323;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_a_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_a(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_P(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1345;
        validate_non_negative_index("y", "m", m);
        validate_non_negative_index("y", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(m, m);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1346;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1347;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1348;
        stan::math::assign(y, vector_to_symmat(segment(x, get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 1, "idx", 2)), m, pstream__));
        current_statement_begin__ = 1349;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_P_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_P(x, m, p, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_filter(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1409;
        validate_non_negative_index("res", "ssm_filter_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), pstream__)", ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__));
        validate_non_negative_index("res", "size(y)", size(y));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > res(size(y), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__)));
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 1410;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1411;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1412;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1413;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1416;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1417;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1418;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1419;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1424;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1425;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1426;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1427;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1428;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1429;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1430;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1431;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1433;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1434;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1435;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1436;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1437;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1438;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1439;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1441;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1443;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1444;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1445;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1446;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1447;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1448;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1449;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1450;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1451;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1452;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1453;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1454;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1455;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1456;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1458;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1459;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1461;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1462;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1464;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 1465;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 1467;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 1468;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 1470;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 1471;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 1473;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 1474;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                }
                current_statement_begin__ = 1476;
                if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                    current_statement_begin__ = 1477;
                    stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                }
            }
            current_statement_begin__ = 1481;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d_t, Z_t, pstream__));
            current_statement_begin__ = 1482;
            stan::math::assign(Finv, ssm_update_Finv(P, Z_t, H_t, pstream__));
            current_statement_begin__ = 1483;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1484;
            stan::math::assign(ll, ssm_update_loglik(v, Finv, pstream__));
            current_statement_begin__ = 1486;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        ll, 
                        "assigning variable res");
            current_statement_begin__ = 1487;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        v, 
                        "assigning variable res");
            current_statement_begin__ = 1488;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(Finv, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1489;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        to_vector(K), 
                        "assigning variable res");
            current_statement_begin__ = 1490;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable res");
            current_statement_begin__ = 1491;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(P, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1493;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1494;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1495;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        }
        current_statement_begin__ = 1499;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_filter_miss(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                    const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                    const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                    const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                    const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                    const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                    const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                    const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                    const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                    const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                    const std::vector<int>& p_t,
                    const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1562;
        validate_non_negative_index("res", "ssm_filter_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), pstream__)", ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__));
        validate_non_negative_index("res", "size(y)", size(y));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > res(size(y), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__)));
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 1563;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1564;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1565;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1566;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1569;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1570;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1571;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1572;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1577;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1578;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1579;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1580;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1581;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1582;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1583;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1584;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1586;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1587;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1588;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1589;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1590;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1591;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1592;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1593;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1594;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1595;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1596;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1597;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1598;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1599;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1600;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1601;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1602;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1603;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1604;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1605;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1606;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1607;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1609;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1610;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1612;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1613;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1615;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 1616;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 1618;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 1619;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 1621;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 1622;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 1624;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 1625;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                }
                current_statement_begin__ = 1627;
                if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                    current_statement_begin__ = 1628;
                    stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                }
            }
            current_statement_begin__ = 1632;
            stan::math::assign(v, ssm_update_v_miss(get_base1(y, t, "y", 1), a, d_t, Z_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1633;
            stan::math::assign(Finv, ssm_update_Finv_miss(P, Z_t, H_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1634;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1635;
            stan::math::assign(ll, ssm_update_loglik_miss(v, Finv, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1637;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        ll, 
                        "assigning variable res");
            current_statement_begin__ = 1638;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        v, 
                        "assigning variable res");
            current_statement_begin__ = 1639;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(Finv, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1640;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        to_vector(K), 
                        "assigning variable res");
            current_statement_begin__ = 1641;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable res");
            current_statement_begin__ = 1642;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(P, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1644;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1645;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1646;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        }
        current_statement_begin__ = 1650;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                    const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                    const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                    const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                    const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                    const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                    const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                    const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                    const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                    const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                    const std::vector<int>& p_t,
                    const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) const {
        return ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1708;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1709;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1710;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1711;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1712;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1713;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1714;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1715;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1716;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1719;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1720;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1721;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1722;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1723;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1724;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1725;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1726;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1728;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1729;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1730;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1731;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1732;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1733;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1735;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1736;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1737;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1738;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1739;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1740;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1741;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1742;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1744;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1745;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1746;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1747;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1748;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1749;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1751;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1752;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1754;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1755;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1757;
                if (as_bool(logical_lt(t, n))) {
                    current_statement_begin__ = 1758;
                    if (as_bool(logical_gt(size(c), 1))) {
                        current_statement_begin__ = 1759;
                        stan::math::assign(c_t, get_base1(c, t, "c", 1));
                    }
                    current_statement_begin__ = 1761;
                    if (as_bool(logical_gt(size(T), 1))) {
                        current_statement_begin__ = 1762;
                        stan::math::assign(T_t, get_base1(T, t, "T", 1));
                    }
                    current_statement_begin__ = 1764;
                    if (as_bool(logical_gt(size(R), 1))) {
                        current_statement_begin__ = 1765;
                        stan::math::assign(R_t, get_base1(R, t, "R", 1));
                    }
                    current_statement_begin__ = 1767;
                    if (as_bool(logical_gt(size(Q), 1))) {
                        current_statement_begin__ = 1768;
                        stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    }
                    current_statement_begin__ = 1770;
                    if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                        current_statement_begin__ = 1771;
                        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                    }
                }
            }
            current_statement_begin__ = 1775;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d_t, Z_t, pstream__));
            current_statement_begin__ = 1776;
            stan::math::assign(Finv, ssm_update_Finv(P, Z_t, H_t, pstream__));
            current_statement_begin__ = 1777;
            stan::math::assign(K, ssm_update_K(P, T_t, Z_t, Finv, pstream__));
            current_statement_begin__ = 1778;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik(v, Finv, pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 1780;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1781;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1782;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        current_statement_begin__ = 1785;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 1787;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}
struct ssm_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_miss_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1826;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1827;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1828;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1829;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1830;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1831;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1832;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1833;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1834;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1837;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1838;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1839;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1840;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1841;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1842;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1843;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1844;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1846;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1847;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1848;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1849;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1850;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1851;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1853;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1854;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1855;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1856;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1857;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1858;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1859;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1860;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1862;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1863;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1864;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1865;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1866;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1867;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1869;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1870;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1872;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1873;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1875;
                if (as_bool(logical_lt(t, n))) {
                    current_statement_begin__ = 1876;
                    if (as_bool(logical_gt(size(c), 1))) {
                        current_statement_begin__ = 1877;
                        stan::math::assign(c_t, get_base1(c, t, "c", 1));
                    }
                    current_statement_begin__ = 1879;
                    if (as_bool(logical_gt(size(T), 1))) {
                        current_statement_begin__ = 1880;
                        stan::math::assign(T_t, get_base1(T, t, "T", 1));
                    }
                    current_statement_begin__ = 1882;
                    if (as_bool(logical_gt(size(R), 1))) {
                        current_statement_begin__ = 1883;
                        stan::math::assign(R_t, get_base1(R, t, "R", 1));
                    }
                    current_statement_begin__ = 1885;
                    if (as_bool(logical_gt(size(Q), 1))) {
                        current_statement_begin__ = 1886;
                        stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    }
                    current_statement_begin__ = 1888;
                    if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                        current_statement_begin__ = 1889;
                        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                    }
                }
            }
            current_statement_begin__ = 1893;
            stan::math::assign(v, ssm_update_v_miss(get_base1(y, t, "y", 1), a, d_t, Z_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1894;
            stan::math::assign(Finv, ssm_update_Finv_miss(P, Z_t, H_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1895;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1896;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik_miss(v, Finv, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 1898;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1899;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1900;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        current_statement_begin__ = 1903;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 1905;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_miss_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    return ssm_miss_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1,p_t,y_idx, pstream__);
}
struct ssm_miss_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) const {
        return ssm_miss_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
matrix_diff(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1933;
        local_scalar_t__ eps(DUMMY_VAR__);
        (void) eps;  // dummy to suppress unused var warning
        stan::math::initialize(eps, DUMMY_VAR__);
        stan::math::fill(eps, DUMMY_VAR__);
        current_statement_begin__ = 1934;
        local_scalar_t__ norm_AB(DUMMY_VAR__);
        (void) norm_AB;  // dummy to suppress unused var warning
        stan::math::initialize(norm_AB, DUMMY_VAR__);
        stan::math::fill(norm_AB, DUMMY_VAR__);
        current_statement_begin__ = 1935;
        local_scalar_t__ norm_A(DUMMY_VAR__);
        (void) norm_A;  // dummy to suppress unused var warning
        stan::math::initialize(norm_A, DUMMY_VAR__);
        stan::math::fill(norm_A, DUMMY_VAR__);
        current_statement_begin__ = 1936;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1937;
        local_scalar_t__ ab(DUMMY_VAR__);
        (void) ab;  // dummy to suppress unused var warning
        stan::math::initialize(ab, DUMMY_VAR__);
        stan::math::fill(ab, DUMMY_VAR__);
        current_statement_begin__ = 1938;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1939;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1940;
        stan::math::assign(m, rows(A));
        current_statement_begin__ = 1941;
        stan::math::assign(n, cols(A));
        current_statement_begin__ = 1942;
        stan::math::assign(eps, 0.0);
        current_statement_begin__ = 1943;
        stan::math::assign(norm_A, 0.0);
        current_statement_begin__ = 1944;
        stan::math::assign(norm_AB, 0.0);
        current_statement_begin__ = 1945;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 1946;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 1947;
                stan::math::assign(a, stan::math::fabs(get_base1(A, i, j, "A", 1)));
                current_statement_begin__ = 1948;
                stan::math::assign(ab, stan::math::fabs((get_base1(A, i, j, "A", 1) - get_base1(B, i, j, "B", 1))));
                current_statement_begin__ = 1949;
                if (as_bool(logical_gt(a, norm_A))) {
                    current_statement_begin__ = 1950;
                    stan::math::assign(norm_A, a);
                }
                current_statement_begin__ = 1952;
                if (as_bool(logical_gt(ab, norm_AB))) {
                    current_statement_begin__ = 1953;
                    stan::math::assign(norm_AB, ab);
                }
            }
        }
        current_statement_begin__ = 1957;
        stan::math::assign(eps, (norm_AB / norm_A));
        current_statement_begin__ = 1958;
        return stan::math::promote_scalar<fun_return_scalar_t__>(eps);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct matrix_diff_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return matrix_diff(A, B, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2003;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 2004;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2005;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2006;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2008;
        if (pstream__) {
            stan_print(pstream__,"In ssm_constant_lpdf");
            *pstream__ << std::endl;
        }
        current_statement_begin__ = 2010;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 2011;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 2012;
        stan::math::assign(p, rows(Z));
        {
        current_statement_begin__ = 2014;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 2015;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2016;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2017;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2018;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2019;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2020;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2023;
        int converged(0);
        (void) converged;  // dummy to suppress unused var warning
        stan::math::fill(converged, std::numeric_limits<int>::min());
        current_statement_begin__ = 2024;
        validate_non_negative_index("P_old", "m", m);
        validate_non_negative_index("P_old", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_old(m, m);
        stan::math::initialize(P_old, DUMMY_VAR__);
        stan::math::fill(P_old, DUMMY_VAR__);
        current_statement_begin__ = 2025;
        local_scalar_t__ tol(DUMMY_VAR__);
        (void) tol;  // dummy to suppress unused var warning
        stan::math::initialize(tol, DUMMY_VAR__);
        stan::math::fill(tol, DUMMY_VAR__);
        current_statement_begin__ = 2026;
        local_scalar_t__ matdiff(DUMMY_VAR__);
        (void) matdiff;  // dummy to suppress unused var warning
        stan::math::initialize(matdiff, DUMMY_VAR__);
        stan::math::fill(matdiff, DUMMY_VAR__);
        current_statement_begin__ = 2027;
        stan::math::assign(converged, 0);
        current_statement_begin__ = 2028;
        stan::math::assign(tol, 1e-7);
        current_statement_begin__ = 2030;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2031;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2032;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2033;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2034;
            if (pstream__) {
                stan_print(pstream__,t);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 2035;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2036;
            if (as_bool(logical_lt(converged, 1))) {
                current_statement_begin__ = 2037;
                stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
                current_statement_begin__ = 2038;
                stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            }
            current_statement_begin__ = 2040;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik(v, Finv, pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 2042;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 2043;
                stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
                current_statement_begin__ = 2046;
                if (as_bool(logical_lt(converged, 1))) {
                    current_statement_begin__ = 2047;
                    stan::math::assign(P_old, P);
                    current_statement_begin__ = 2048;
                    stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
                    current_statement_begin__ = 2049;
                    stan::math::assign(matdiff, matrix_diff(P, P_old, pstream__));
                    current_statement_begin__ = 2050;
                    if (as_bool(logical_lt(matdiff, tol))) {
                        current_statement_begin__ = 2051;
                        stan::math::assign(converged, 1);
                    }
                }
            }
        }
        current_statement_begin__ = 2056;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 2059;
        if (pstream__) {
            stan_print(pstream__,"Exiting ssm_constant_lpdf");
            *pstream__ << std::endl;
        }
        current_statement_begin__ = 2061;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_constant_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}
struct ssm_constant_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_constant_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_predicted_cov(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                             const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                             const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2080;
        validate_non_negative_index("cov_new", "rows(H)", rows(H));
        validate_non_negative_index("cov_new", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> cov_new(rows(H), cols(H));
        stan::math::initialize(cov_new, DUMMY_VAR__);
        stan::math::fill(cov_new, DUMMY_VAR__);
        current_statement_begin__ = 2081;
        stan::math::assign(cov_new, ssm_update_F(P, Z, H, pstream__));
        current_statement_begin__ = 2082;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cov_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_cov_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                             const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                             const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_predicted_cov(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
ssm_update_predicted_mean(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& d,
                              const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                              const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2101;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2102;
        validate_non_negative_index("mean_new", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> mean_new(p);
        stan::math::initialize(mean_new, DUMMY_VAR__);
        stan::math::fill(mean_new, DUMMY_VAR__);
        current_statement_begin__ = 2103;
        stan::math::assign(mean_new, add(d, multiply(Z, a)));
        current_statement_begin__ = 2104;
        return stan::math::promote_scalar<fun_return_scalar_t__>(mean_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_mean_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& d,
                              const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                              const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) const {
        return ssm_update_predicted_mean(d, Z, a, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
ssm_update_predicted_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2123;
        validate_non_negative_index("a_new", "num_elements(a)", num_elements(a));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_new(num_elements(a));
        stan::math::initialize(a_new, DUMMY_VAR__);
        stan::math::fill(a_new, DUMMY_VAR__);
        current_statement_begin__ = 2124;
        stan::math::assign(a_new, add(c, multiply(T, a)));
        current_statement_begin__ = 2125;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_a_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) const {
        return ssm_update_predicted_a(c, T, a, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_predicted_P(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2144;
        validate_non_negative_index("P_new", "rows(P)", rows(P));
        validate_non_negative_index("P_new", "cols(P)", cols(P));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_new(rows(P), cols(P));
        stan::math::initialize(P_new, DUMMY_VAR__);
        stan::math::fill(P_new, DUMMY_VAR__);
        current_statement_begin__ = 2145;
        stan::math::assign(P_new, to_symmetric_matrix(add(quad_form(P, transpose(T)), RQR), pstream__));
        current_statement_begin__ = 2146;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_P_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) const {
        return ssm_update_predicted_P(P, T, RQR, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
predict(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
            const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
            const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
            const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
            const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
            const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
            const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
            const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
            const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
            const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
            const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2184;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2185;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2186;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2188;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2189;
        validate_non_negative_index("F", "p", p);
        validate_non_negative_index("F", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> F(p, p);
        stan::math::initialize(F, DUMMY_VAR__);
        stan::math::fill(F, DUMMY_VAR__);
        current_statement_begin__ = 2190;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2191;
        validate_non_negative_index("prediction", "p", p);
        validate_non_negative_index("prediction", "(p + 1)", (p + 1));
        validate_non_negative_index("prediction", "horizon", horizon);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > prediction(horizon, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(p, (p + 1)));
        stan::math::initialize(prediction, DUMMY_VAR__);
        stan::math::fill(prediction, DUMMY_VAR__);
        {
        current_statement_begin__ = 2193;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2194;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2195;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2196;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2198;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2199;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2200;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2202;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2203;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2204;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2205;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2206;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2207;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        current_statement_begin__ = 2212;
        stan::model::assign(prediction, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                    "assigning variable prediction");
        current_statement_begin__ = 2214;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2215;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2216;
                stan::math::assign(a, ssm_update_predicted_a(c, T, a, pstream__));
                current_statement_begin__ = 2217;
                stan::math::assign(P, ssm_update_predicted_P(P, T, RQR, pstream__));
                current_statement_begin__ = 2218;
                stan::model::assign(prediction, 
                            stan::model::cons_list(stan::model::index_uni(h), stan::model::nil_index_list()), 
                            append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                            "assigning variable prediction");
            }
        }
        }
        current_statement_begin__ = 2223;
        return stan::math::promote_scalar<fun_return_scalar_t__>(prediction);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct predict_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
            const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
            const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
            const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
            const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
            const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
            const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
            const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
            const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
            const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
            const int& horizon, std::ostream* pstream__) const {
        return predict(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
predict_given_one_step(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                           const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                           const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                           const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                           const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                           const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                           const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2231;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2232;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2233;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2235;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        stan::math::assign(a,a1);
        current_statement_begin__ = 2236;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        stan::math::assign(P,P1);
        current_statement_begin__ = 2237;
        validate_non_negative_index("prediction", "p", p);
        validate_non_negative_index("prediction", "(p + 1)", (p + 1));
        validate_non_negative_index("prediction", "horizon", horizon);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > prediction(horizon, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(p, (p + 1)));
        stan::math::initialize(prediction, DUMMY_VAR__);
        stan::math::fill(prediction, DUMMY_VAR__);
        {
        current_statement_begin__ = 2239;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2241;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2244;
        stan::model::assign(prediction, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                    "assigning variable prediction");
        current_statement_begin__ = 2246;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2247;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2248;
                stan::math::assign(a, ssm_update_predicted_a(c, T, a, pstream__));
                current_statement_begin__ = 2249;
                stan::math::assign(P, ssm_update_predicted_P(P, T, RQR, pstream__));
                current_statement_begin__ = 2250;
                stan::model::assign(prediction, 
                            stan::model::cons_list(stan::model::index_uni(h), stan::model::nil_index_list()), 
                            append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                            "assigning variable prediction");
            }
        }
        }
        current_statement_begin__ = 2255;
        return stan::math::promote_scalar<fun_return_scalar_t__>(prediction);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct predict_given_one_step_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                           const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                           const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                           const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                           const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                           const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                           const int& horizon, std::ostream* pstream__) const {
        return predict_given_one_step(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_constant_joint_predict(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2296;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2297;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2298;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2300;
        validate_non_negative_index("d_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_tilde((p * horizon));
        stan::math::initialize(d_tilde, DUMMY_VAR__);
        stan::math::fill(d_tilde, DUMMY_VAR__);
        current_statement_begin__ = 2301;
        validate_non_negative_index("a_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_star((m * horizon));
        stan::math::initialize(a_star, DUMMY_VAR__);
        stan::math::fill(a_star, DUMMY_VAR__);
        stan::math::assign(a_star,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2302;
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_tilde((p * horizon), (p * horizon));
        stan::math::initialize(H_tilde, DUMMY_VAR__);
        stan::math::fill(H_tilde, DUMMY_VAR__);
        stan::math::assign(H_tilde,rep_matrix(0, (p * horizon), (p * horizon)));
        current_statement_begin__ = 2304;
        validate_non_negative_index("c_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_tilde((m * horizon));
        stan::math::initialize(c_tilde, DUMMY_VAR__);
        stan::math::fill(c_tilde, DUMMY_VAR__);
        stan::math::assign(c_tilde,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2305;
        validate_non_negative_index("ZT_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("ZT_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT_tilde((p * horizon), (m * horizon));
        stan::math::initialize(ZT_tilde, DUMMY_VAR__);
        stan::math::fill(ZT_tilde, DUMMY_VAR__);
        stan::math::assign(ZT_tilde,rep_matrix(0, (p * horizon), (m * horizon)));
        current_statement_begin__ = 2307;
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_star((m * horizon), (m * horizon));
        stan::math::initialize(Q_star, DUMMY_VAR__);
        stan::math::fill(Q_star, DUMMY_VAR__);
        stan::math::assign(Q_star,rep_matrix(0, (m * horizon), (m * horizon)));
        current_statement_begin__ = 2309;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        stan::math::assign(RQR,quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2313;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2314;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        {
        current_statement_begin__ = 2316;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2317;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2318;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2320;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2321;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2322;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2323;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2324;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2325;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2326;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2327;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        }
        {
        current_statement_begin__ = 2333;
        validate_non_negative_index("ZT", "p", p);
        validate_non_negative_index("ZT", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT(p, m);
        stan::math::initialize(ZT, DUMMY_VAR__);
        stan::math::fill(ZT, DUMMY_VAR__);
        stan::math::assign(ZT,Z);
        current_statement_begin__ = 2335;
        stan::model::assign(a_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list()), 
                    a, 
                    "assigning variable a_star");
        current_statement_begin__ = 2337;
        for (int h = 1; h <= horizon; ++h) {
            current_statement_begin__ = 2338;
            stan::model::assign(d_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list()), 
                        d, 
                        "assigning variable d_tilde");
            current_statement_begin__ = 2339;
            if (as_bool(logical_gt(h, 1))) {
                current_statement_begin__ = 2340;
                stan::model::assign(c_tilde, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list()), 
                            c, 
                            "assigning variable c_tilde");
                current_statement_begin__ = 2341;
                stan::math::assign(ZT, multiply(ZT, T));
            }
            current_statement_begin__ = 2344;
            stan::model::assign(H_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list())), 
                        H, 
                        "assigning variable H_tilde");
            current_statement_begin__ = 2346;
            for (int i = 1; i <= ((horizon - h) + 1); ++i) {
                current_statement_begin__ = 2347;
                stan::model::assign(ZT_tilde, 
                            stan::model::cons_list(stan::model::index_min_max(((((i + h) - 2) * p) + 1), (((i + h) - 1) * p)), stan::model::cons_list(stan::model::index_min_max((((i - 1) * m) + 1), (i * m)), stan::model::nil_index_list())), 
                            ZT, 
                            "assigning variable ZT_tilde");
            }
        }
        }
        current_statement_begin__ = 2352;
        stan::model::assign(Q_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list())), 
                    P, 
                    "assigning variable Q_star");
        current_statement_begin__ = 2353;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2354;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2355;
                stan::model::assign(Q_star, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list())), 
                            RQR, 
                            "assigning variable Q_star");
            }
        }
        current_statement_begin__ = 2361;
        return stan::math::promote_scalar<fun_return_scalar_t__>(append_col(add(to_matrix(d_tilde), multiply(ZT_tilde, to_matrix(add(c_tilde, a_star)))), add(quad_form_sym(Q_star, transpose(ZT_tilde)), H_tilde)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_constant_joint_predict_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) const {
        return ssm_constant_joint_predict(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_constant_joint_predict_given_one_step(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                                              const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                                              const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                                              const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                                              const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                                              const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                                              const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                                              const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                                              const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                                              const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                                              const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2373;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2374;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2375;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2377;
        validate_non_negative_index("d_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_tilde((p * horizon));
        stan::math::initialize(d_tilde, DUMMY_VAR__);
        stan::math::fill(d_tilde, DUMMY_VAR__);
        current_statement_begin__ = 2378;
        validate_non_negative_index("a_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_star((m * horizon));
        stan::math::initialize(a_star, DUMMY_VAR__);
        stan::math::fill(a_star, DUMMY_VAR__);
        stan::math::assign(a_star,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2379;
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_tilde((p * horizon), (p * horizon));
        stan::math::initialize(H_tilde, DUMMY_VAR__);
        stan::math::fill(H_tilde, DUMMY_VAR__);
        stan::math::assign(H_tilde,rep_matrix(0, (p * horizon), (p * horizon)));
        current_statement_begin__ = 2381;
        validate_non_negative_index("c_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_tilde((m * horizon));
        stan::math::initialize(c_tilde, DUMMY_VAR__);
        stan::math::fill(c_tilde, DUMMY_VAR__);
        stan::math::assign(c_tilde,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2382;
        validate_non_negative_index("ZT_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("ZT_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT_tilde((p * horizon), (m * horizon));
        stan::math::initialize(ZT_tilde, DUMMY_VAR__);
        stan::math::fill(ZT_tilde, DUMMY_VAR__);
        stan::math::assign(ZT_tilde,rep_matrix(0, (p * horizon), (m * horizon)));
        current_statement_begin__ = 2384;
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_star((m * horizon), (m * horizon));
        stan::math::initialize(Q_star, DUMMY_VAR__);
        stan::math::fill(Q_star, DUMMY_VAR__);
        stan::math::assign(Q_star,rep_matrix(0, (m * horizon), (m * horizon)));
        current_statement_begin__ = 2386;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        stan::math::assign(RQR,quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2390;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2391;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        {
        current_statement_begin__ = 2393;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2394;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2395;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2397;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2398;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2399;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2400;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2401;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2402;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2403;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2404;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        }
        {
        current_statement_begin__ = 2410;
        validate_non_negative_index("ZT", "p", p);
        validate_non_negative_index("ZT", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT(p, m);
        stan::math::initialize(ZT, DUMMY_VAR__);
        stan::math::fill(ZT, DUMMY_VAR__);
        stan::math::assign(ZT,Z);
        current_statement_begin__ = 2412;
        stan::model::assign(a_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list()), 
                    a, 
                    "assigning variable a_star");
        current_statement_begin__ = 2414;
        for (int h = 1; h <= horizon; ++h) {
            current_statement_begin__ = 2415;
            stan::model::assign(d_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list()), 
                        d, 
                        "assigning variable d_tilde");
            current_statement_begin__ = 2416;
            if (as_bool(logical_gt(h, 1))) {
                current_statement_begin__ = 2417;
                stan::model::assign(c_tilde, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list()), 
                            c, 
                            "assigning variable c_tilde");
                current_statement_begin__ = 2418;
                stan::math::assign(ZT, multiply(ZT, T));
            }
            current_statement_begin__ = 2421;
            stan::model::assign(H_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list())), 
                        H, 
                        "assigning variable H_tilde");
            current_statement_begin__ = 2423;
            for (int i = 1; i <= ((horizon - h) + 1); ++i) {
                current_statement_begin__ = 2424;
                stan::model::assign(ZT_tilde, 
                            stan::model::cons_list(stan::model::index_min_max(((((i + h) - 2) * p) + 1), (((i + h) - 1) * p)), stan::model::cons_list(stan::model::index_min_max((((i - 1) * m) + 1), (i * m)), stan::model::nil_index_list())), 
                            ZT, 
                            "assigning variable ZT_tilde");
            }
        }
        }
        current_statement_begin__ = 2429;
        stan::model::assign(Q_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list())), 
                    P, 
                    "assigning variable Q_star");
        current_statement_begin__ = 2430;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2431;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2432;
                stan::model::assign(Q_star, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list())), 
                            RQR, 
                            "assigning variable Q_star");
            }
        }
        current_statement_begin__ = 2438;
        return stan::math::promote_scalar<fun_return_scalar_t__>(append_col(add(to_matrix(d_tilde), multiply(ZT_tilde, to_matrix(add(c_tilde, a_star)))), add(quad_form_sym(Q_star, transpose(ZT_tilde)), H_tilde)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_constant_joint_predict_given_one_step_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                                              const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                                              const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                                              const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                                              const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                                              const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                                              const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                                              const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                                              const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                                              const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                                              const int& horizon, std::ostream* pstream__) const {
        return ssm_constant_joint_predict_given_one_step(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_forecast_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2487;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        stan::math::assign(ll,0.0);
        current_statement_begin__ = 2488;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2489;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2490;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2492;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 2493;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 2494;
        stan::math::assign(p, rows(Z));
        {
        current_statement_begin__ = 2496;
        validate_non_negative_index("ll_pred", "(n - horizon)", (n - horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_pred((n - horizon));
        stan::math::initialize(ll_pred, DUMMY_VAR__);
        stan::math::fill(ll_pred, DUMMY_VAR__);
        current_statement_begin__ = 2497;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2498;
        validate_non_negative_index("a_temp", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_temp(m);
        stan::math::initialize(a_temp, DUMMY_VAR__);
        stan::math::fill(a_temp, DUMMY_VAR__);
        current_statement_begin__ = 2499;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2500;
        validate_non_negative_index("P_temp", "m", m);
        validate_non_negative_index("P_temp", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_temp(m, m);
        stan::math::initialize(P_temp, DUMMY_VAR__);
        stan::math::fill(P_temp, DUMMY_VAR__);
        current_statement_begin__ = 2501;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2502;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2503;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2504;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2505;
        validate_non_negative_index("full_prediction", "p", p);
        validate_non_negative_index("full_prediction", "(p + 1)", (p + 1));
        validate_non_negative_index("full_prediction", "horizon", horizon);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > full_prediction(horizon, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(p, (p + 1)));
        stan::math::initialize(full_prediction, DUMMY_VAR__);
        stan::math::fill(full_prediction, DUMMY_VAR__);
        current_statement_begin__ = 2508;
        int converged(0);
        (void) converged;  // dummy to suppress unused var warning
        stan::math::fill(converged, std::numeric_limits<int>::min());
        current_statement_begin__ = 2509;
        validate_non_negative_index("P_old", "m", m);
        validate_non_negative_index("P_old", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_old(m, m);
        stan::math::initialize(P_old, DUMMY_VAR__);
        stan::math::fill(P_old, DUMMY_VAR__);
        current_statement_begin__ = 2510;
        local_scalar_t__ tol(DUMMY_VAR__);
        (void) tol;  // dummy to suppress unused var warning
        stan::math::initialize(tol, DUMMY_VAR__);
        stan::math::fill(tol, DUMMY_VAR__);
        current_statement_begin__ = 2511;
        local_scalar_t__ matdiff(DUMMY_VAR__);
        (void) matdiff;  // dummy to suppress unused var warning
        stan::math::initialize(matdiff, DUMMY_VAR__);
        stan::math::fill(matdiff, DUMMY_VAR__);
        current_statement_begin__ = 2512;
        stan::math::assign(converged, 0);
        current_statement_begin__ = 2513;
        stan::math::assign(tol, 1e-7);
        current_statement_begin__ = 2515;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2516;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2517;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2518;
        for (int t = 1; t <= (n - horizon); ++t) {
            current_statement_begin__ = 2519;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2520;
            if (as_bool(logical_lt(converged, 1))) {
                current_statement_begin__ = 2521;
                stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
                current_statement_begin__ = 2522;
                stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            }
            current_statement_begin__ = 2539;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2542;
            if (as_bool(logical_lt(converged, 1))) {
                current_statement_begin__ = 2543;
                stan::math::assign(P_old, P);
                current_statement_begin__ = 2544;
                stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
                current_statement_begin__ = 2545;
                stan::math::assign(matdiff, matrix_diff(P, P_old, pstream__));
                current_statement_begin__ = 2546;
                if (as_bool(logical_lt(matdiff, tol))) {
                    current_statement_begin__ = 2547;
                    stan::math::assign(converged, 1);
                }
            }
            current_statement_begin__ = 2551;
            stan::math::assign(full_prediction, predict_given_one_step(y, d, Z, H, c, T, R, Q, a, P, horizon, pstream__));
            current_statement_begin__ = 2552;
            stan::math::assign(ll, (ll + multi_normal_log(get_base1(y, (t + horizon), "y", 1), stan::model::rvalue(full_prediction, stan::model::cons_list(stan::model::index_uni(horizon), stan::model::cons_list(stan::model::index_min_max(1, p), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()))), "full_prediction"), stan::model::rvalue(full_prediction, stan::model::cons_list(stan::model::index_uni(horizon), stan::model::cons_list(stan::model::index_min_max(1, p), stan::model::cons_list(stan::model::index_min_max(2, (p + 1)), stan::model::nil_index_list()))), "full_prediction"))));
        }
        }
        current_statement_begin__ = 2563;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_forecast_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) {
    return ssm_constant_forecast_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1,horizon, pstream__);
}
struct ssm_constant_forecast_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) const {
        return ssm_constant_forecast_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic, 1> >
ssm_smooth_states_mean(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                           const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                           const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, 1> >& c,
                           const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                           const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                           const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& Q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2611;
        validate_non_negative_index("alpha", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("alpha", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(alpha, DUMMY_VAR__);
        stan::math::fill(alpha, DUMMY_VAR__);
        current_statement_begin__ = 2612;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2613;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2614;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2615;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2616;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 2617;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2618;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2619;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2621;
        validate_non_negative_index("r", "m", m);
        validate_non_negative_index("r", "(n + 1)", (n + 1));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > r((n + 1), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 2622;
        validate_non_negative_index("u", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> u(p);
        stan::math::initialize(u, DUMMY_VAR__);
        stan::math::fill(u, DUMMY_VAR__);
        current_statement_begin__ = 2623;
        validate_non_negative_index("a1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a1(m);
        stan::math::initialize(a1, DUMMY_VAR__);
        stan::math::fill(a1, DUMMY_VAR__);
        current_statement_begin__ = 2624;
        validate_non_negative_index("P1", "m", m);
        validate_non_negative_index("P1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
        stan::math::initialize(P1, DUMMY_VAR__);
        stan::math::fill(P1, DUMMY_VAR__);
        current_statement_begin__ = 2626;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2627;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2628;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2630;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 2631;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 2632;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 2633;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 2634;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 2635;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2637;
        if (as_bool(logical_eq(size(c), 1))) {
            current_statement_begin__ = 2638;
            stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        }
        current_statement_begin__ = 2640;
        if (as_bool(logical_eq(size(Z), 1))) {
            current_statement_begin__ = 2641;
            stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        }
        current_statement_begin__ = 2643;
        if (as_bool(logical_eq(size(T), 1))) {
            current_statement_begin__ = 2644;
            stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        }
        current_statement_begin__ = 2646;
        if (as_bool(logical_eq(size(R), 1))) {
            current_statement_begin__ = 2647;
            stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        }
        current_statement_begin__ = 2649;
        if (as_bool(logical_eq(size(Q), 1))) {
            current_statement_begin__ = 2650;
            stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        }
        current_statement_begin__ = 2652;
        if (as_bool((primitive_value(logical_eq(size(Q), 1)) && primitive_value(logical_eq(size(R), 1))))) {
            current_statement_begin__ = 2653;
            stan::math::assign(RQR, quad_form_sym(get_base1(Q, 1, "Q", 1), transpose(get_base1(R, 1, "R", 1))));
        }
        current_statement_begin__ = 2662;
        stan::model::assign(r, 
                    stan::model::cons_list(stan::model::index_uni((n + 1)), stan::model::nil_index_list()), 
                    rep_vector(0.0, m), 
                    "assigning variable r");
        current_statement_begin__ = 2663;
        for (int s = 0; s <= (n - 1); ++s) {
            {
            current_statement_begin__ = 2664;
            int t(0);
            (void) t;  // dummy to suppress unused var warning
            stan::math::fill(t, std::numeric_limits<int>::min());
            current_statement_begin__ = 2666;
            stan::math::assign(t, (n - s));
            current_statement_begin__ = 2668;
            if (as_bool(logical_gt(size(Z), 1))) {
                current_statement_begin__ = 2669;
                stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
            }
            current_statement_begin__ = 2671;
            if (as_bool(logical_gt(size(T), 1))) {
                current_statement_begin__ = 2672;
                stan::math::assign(T_t, get_base1(T, t, "T", 1));
            }
            current_statement_begin__ = 2675;
            stan::math::assign(K, ssm_filter_get_K(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2676;
            stan::math::assign(v, ssm_filter_get_v(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2677;
            stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2679;
            stan::math::assign(u, subtract(multiply(Finv, v), multiply(transpose(K), get_base1(r, (t + 1), "r", 1))));
            current_statement_begin__ = 2681;
            stan::model::assign(r, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        add(multiply(transpose(Z_t), u), multiply(transpose(T_t), get_base1(r, (t + 1), "r", 1))), 
                        "assigning variable r");
            }
        }
        current_statement_begin__ = 2684;
        stan::math::assign(a1, ssm_filter_get_a(get_base1(filter, 1, "filter", 1), m, p, pstream__));
        current_statement_begin__ = 2685;
        stan::math::assign(P1, ssm_filter_get_P(get_base1(filter, 1, "filter", 1), m, p, pstream__));
        current_statement_begin__ = 2687;
        stan::model::assign(alpha, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    add(a1, multiply(P1, get_base1(r, 1, "r", 1))), 
                    "assigning variable alpha");
        current_statement_begin__ = 2689;
        for (int t = 1; t <= (n - 1); ++t) {
            current_statement_begin__ = 2690;
            if (as_bool(logical_gt(size(c), 1))) {
                current_statement_begin__ = 2691;
                stan::math::assign(c_t, get_base1(c, t, "c", 1));
            }
            current_statement_begin__ = 2693;
            if (as_bool(logical_gt(size(T), 1))) {
                current_statement_begin__ = 2694;
                stan::math::assign(T_t, get_base1(T, t, "T", 1));
            }
            current_statement_begin__ = 2696;
            if (as_bool(logical_gt(size(Q), 1))) {
                current_statement_begin__ = 2697;
                stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
            }
            current_statement_begin__ = 2699;
            if (as_bool(logical_gt(size(R), 1))) {
                current_statement_begin__ = 2700;
                stan::math::assign(R_t, get_base1(R, t, "R", 1));
            }
            current_statement_begin__ = 2702;
            if (as_bool((primitive_value(logical_gt(size(Q), 1)) || primitive_value(logical_gt(size(R), 1))))) {
                current_statement_begin__ = 2703;
                stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
            }
            current_statement_begin__ = 2707;
            stan::model::assign(alpha, 
                        stan::model::cons_list(stan::model::index_uni((t + 1)), stan::model::nil_index_list()), 
                        add(add(c_t, multiply(T_t, get_base1(alpha, t, "alpha", 1))), multiply(RQR, get_base1(r, (t + 1), "r", 1))), 
                        "assigning variable alpha");
        }
        }
        current_statement_begin__ = 2710;
        return stan::math::promote_scalar<fun_return_scalar_t__>(alpha);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_smooth_states_mean_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                           const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                           const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, 1> >& c,
                           const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                           const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                           const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& Q, std::ostream* pstream__) const {
        return ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__);
    }
};
std::vector<std::vector<int> >
ssm_sim_idx(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2741;
        validate_non_negative_index("sz", "2", 2);
        validate_non_negative_index("sz", "3", 3);
        std::vector<std::vector<int  >  > sz(2, std::vector<int>(3, int(0)));
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 2743;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    p, 
                    "assigning variable sz");
        current_statement_begin__ = 2745;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    m, 
                    "assigning variable sz");
        current_statement_begin__ = 2747;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 2748;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 1, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 1, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2749;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    (get_base1(get_base1(sz, (2 - 1), "sz", 1), 3, "sz", 2) + 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2750;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 2, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 2, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2751;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_idx_functor__ {
            std::vector<std::vector<int> >
    operator()(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) const {
        return ssm_sim_idx(m, p, q, pstream__);
    }
};
int
ssm_sim_size(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2774;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 2775;
        stan::math::assign(sz, get_base1(get_base1(ssm_sim_idx(m, p, q, pstream__), 2, "ssm_sim_idx(m, p, q, pstream__)", 1), 3, "ssm_sim_idx(m, p, q, pstream__)", 2));
        current_statement_begin__ = 2776;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_size_functor__ {
            int
    operator()(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) const {
        return ssm_sim_size(m, p, q, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_sim_get_y(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2799;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2800;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2801;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2802;
        stan::math::assign(y, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 1, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 1, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list()), "x"));
        current_statement_begin__ = 2803;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_get_y_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_y(x, m, p, q, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_sim_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2826;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2827;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2828;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2829;
        stan::math::assign(a, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list()), "x"));
        current_statement_begin__ = 2830;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_get_a_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_a(x, m, p, q, pstream__);
    }
};
template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_sim_rng(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2896;
        validate_non_negative_index("ret", "ssm_sim_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), get_base1(dims(Q), 2, \"dims(Q)\", 1), pstream__)", ssm_sim_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), get_base1(dims(Q), 2, "dims(Q)", 1), pstream__));
        validate_non_negative_index("ret", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > ret(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), get_base1(dims(Q), 2, "dims(Q)", 1), pstream__)));
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 2897;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2898;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2899;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2900;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2901;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2902;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2905;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 2906;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 2907;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 2908;
        validate_non_negative_index("HL", "p", p);
        validate_non_negative_index("HL", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> HL(p, p);
        stan::math::initialize(HL, DUMMY_VAR__);
        stan::math::fill(HL, DUMMY_VAR__);
        current_statement_begin__ = 2909;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 2910;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 2911;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 2912;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 2913;
        validate_non_negative_index("QL", "q", q);
        validate_non_negative_index("QL", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> QL(q, q);
        stan::math::initialize(QL, DUMMY_VAR__);
        stan::math::fill(QL, DUMMY_VAR__);
        current_statement_begin__ = 2915;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2916;
        validate_non_negative_index("eps", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(p);
        stan::math::initialize(eps, DUMMY_VAR__);
        stan::math::fill(eps, DUMMY_VAR__);
        current_statement_begin__ = 2917;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2918;
        validate_non_negative_index("eta", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eta(q);
        stan::math::initialize(eta, DUMMY_VAR__);
        stan::math::fill(eta, DUMMY_VAR__);
        current_statement_begin__ = 2920;
        validate_non_negative_index("zero_p", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_p(p);
        stan::math::initialize(zero_p, DUMMY_VAR__);
        stan::math::fill(zero_p, DUMMY_VAR__);
        current_statement_begin__ = 2921;
        validate_non_negative_index("zero_q", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_q(q);
        stan::math::initialize(zero_q, DUMMY_VAR__);
        stan::math::fill(zero_q, DUMMY_VAR__);
        current_statement_begin__ = 2922;
        validate_non_negative_index("zero_m", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_m(m);
        stan::math::initialize(zero_m, DUMMY_VAR__);
        stan::math::fill(zero_m, DUMMY_VAR__);
        current_statement_begin__ = 2923;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2925;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 2926;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 2927;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 2928;
        stan::math::assign(HL, cholesky_decompose2(H_t, pstream__));
        current_statement_begin__ = 2929;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 2930;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 2931;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 2932;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 2933;
        stan::math::assign(QL, cholesky_decompose2(Q_t, pstream__));
        current_statement_begin__ = 2935;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2936;
        stan::math::assign(zero_p, rep_vector(0.0, p));
        current_statement_begin__ = 2937;
        stan::math::assign(zero_q, rep_vector(0.0, q));
        current_statement_begin__ = 2938;
        stan::math::assign(zero_m, rep_vector(0.0, m));
        current_statement_begin__ = 2939;
        stan::math::assign(a, multi_normal2_rng(a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 2940;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2942;
            stan::model::assign(ret, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable ret");
            current_statement_begin__ = 2944;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 2945;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 2946;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 2948;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 2949;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 2951;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 2952;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                    current_statement_begin__ = 2953;
                    stan::math::assign(HL, cholesky_decompose2(H_t, pstream__));
                }
            }
            current_statement_begin__ = 2957;
            stan::math::assign(eps, multi_normal_cholesky2_rng(zero_p, HL, base_rng__, pstream__));
            current_statement_begin__ = 2958;
            stan::math::assign(y, add(add(d_t, multiply(Z_t, a)), eps));
            current_statement_begin__ = 2960;
            stan::model::assign(ret, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 1, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 1, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        y, 
                        "assigning variable ret");
            current_statement_begin__ = 2962;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 2963;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 2964;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 2966;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 2967;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 2969;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 2970;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 2972;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 2973;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    current_statement_begin__ = 2974;
                    stan::math::assign(QL, cholesky_decompose2(Q_t, pstream__));
                }
                current_statement_begin__ = 2976;
                stan::math::assign(eta, multi_normal_cholesky2_rng(zero_q, QL, base_rng__, pstream__));
                current_statement_begin__ = 2977;
                stan::math::assign(a, add(add(c_t, multiply(T_t, a)), multiply(R_t, eta)));
            }
        }
        }
        current_statement_begin__ = 2981;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_rng_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_simsmo_states_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3035;
        validate_non_negative_index("draws", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("draws", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > draws(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(draws, DUMMY_VAR__);
        stan::math::fill(draws, DUMMY_VAR__);
        current_statement_begin__ = 3036;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3037;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3038;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3039;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 3040;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 3041;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 3042;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 3043;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 3045;
        validate_non_negative_index("filter_plus", "ssm_filter_size(m, p, pstream__)", ssm_filter_size(m, p, pstream__));
        validate_non_negative_index("filter_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > filter_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(m, p, pstream__)));
        stan::math::initialize(filter_plus, DUMMY_VAR__);
        stan::math::fill(filter_plus, DUMMY_VAR__);
        current_statement_begin__ = 3046;
        validate_non_negative_index("sims", "ssm_sim_size(m, p, q, pstream__)", ssm_sim_size(m, p, q, pstream__));
        validate_non_negative_index("sims", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > sims(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(m, p, q, pstream__)));
        stan::math::initialize(sims, DUMMY_VAR__);
        stan::math::fill(sims, DUMMY_VAR__);
        current_statement_begin__ = 3047;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > y(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(p));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 3048;
        validate_non_negative_index("alpha_hat_plus", "m", m);
        validate_non_negative_index("alpha_hat_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat_plus, DUMMY_VAR__);
        stan::math::fill(alpha_hat_plus, DUMMY_VAR__);
        current_statement_begin__ = 3049;
        validate_non_negative_index("alpha_hat", "m", m);
        validate_non_negative_index("alpha_hat", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat, DUMMY_VAR__);
        stan::math::fill(alpha_hat, DUMMY_VAR__);
        current_statement_begin__ = 3051;
        stan::math::assign(alpha_hat, ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 3053;
        stan::math::assign(sims, ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 3054;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3055;
            stan::model::assign(y, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ssm_sim_get_y(get_base1(sims, i, "sims", 1), m, p, q, pstream__), 
                        "assigning variable y");
        }
        current_statement_begin__ = 3058;
        stan::math::assign(filter_plus, ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__));
        current_statement_begin__ = 3060;
        stan::math::assign(alpha_hat_plus, ssm_smooth_states_mean(filter_plus, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 3061;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3062;
            stan::model::assign(draws, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        add(subtract(ssm_sim_get_a(get_base1(sims, i, "sims", 1), m, p, q, pstream__), get_base1(alpha_hat_plus, i, "alpha_hat_plus", 1)), get_base1(alpha_hat, i, "alpha_hat", 1)), 
                        "assigning variable draws");
        }
        }
        current_statement_begin__ = 3067;
        return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_simsmo_states_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_rng(filter, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_simsmo_states_miss_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const std::vector<int>& p_t,
                               const std::vector<std::vector<int> >& y_idx, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3113;
        validate_non_negative_index("draws", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("draws", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > draws(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(draws, DUMMY_VAR__);
        stan::math::fill(draws, DUMMY_VAR__);
        current_statement_begin__ = 3114;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3115;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3116;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3117;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 3118;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 3119;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 3120;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 3121;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 3123;
        validate_non_negative_index("filter_plus", "ssm_filter_size(m, p, pstream__)", ssm_filter_size(m, p, pstream__));
        validate_non_negative_index("filter_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > filter_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(m, p, pstream__)));
        stan::math::initialize(filter_plus, DUMMY_VAR__);
        stan::math::fill(filter_plus, DUMMY_VAR__);
        current_statement_begin__ = 3124;
        validate_non_negative_index("sims", "ssm_sim_size(m, p, q, pstream__)", ssm_sim_size(m, p, q, pstream__));
        validate_non_negative_index("sims", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > sims(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(m, p, q, pstream__)));
        stan::math::initialize(sims, DUMMY_VAR__);
        stan::math::fill(sims, DUMMY_VAR__);
        current_statement_begin__ = 3125;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > y(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(p));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 3126;
        validate_non_negative_index("alpha_hat_plus", "m", m);
        validate_non_negative_index("alpha_hat_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat_plus, DUMMY_VAR__);
        stan::math::fill(alpha_hat_plus, DUMMY_VAR__);
        current_statement_begin__ = 3127;
        validate_non_negative_index("alpha_hat", "m", m);
        validate_non_negative_index("alpha_hat", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat, DUMMY_VAR__);
        stan::math::fill(alpha_hat, DUMMY_VAR__);
        current_statement_begin__ = 3129;
        stan::math::assign(alpha_hat, ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 3131;
        stan::math::assign(sims, ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 3132;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3133;
            stan::model::assign(y, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ssm_sim_get_y(get_base1(sims, i, "sims", 1), m, p, q, pstream__), 
                        "assigning variable y");
        }
        current_statement_begin__ = 3136;
        stan::math::assign(filter_plus, ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__));
        current_statement_begin__ = 3139;
        stan::math::assign(alpha_hat_plus, ssm_smooth_states_mean(filter_plus, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 3140;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3141;
            stan::model::assign(draws, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        add(subtract(ssm_sim_get_a(get_base1(sims, i, "sims", 1), m, p, q, pstream__), get_base1(alpha_hat_plus, i, "alpha_hat_plus", 1)), get_base1(alpha_hat, i, "alpha_hat", 1)), 
                        "assigning variable draws");
        }
        }
        current_statement_begin__ = 3146;
        return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_simsmo_states_miss_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const std::vector<int>& p_t,
                               const std::vector<std::vector<int> >& y_idx, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_miss_rng(filter, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, base_rng__, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
pacf_to_acf(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3171;
        validate_non_negative_index("x_new", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> x_new(num_elements(x));
        stan::math::initialize(x_new, DUMMY_VAR__);
        stan::math::fill(x_new, DUMMY_VAR__);
        current_statement_begin__ = 3172;
        validate_non_negative_index("work", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> work(num_elements(x));
        stan::math::initialize(work, DUMMY_VAR__);
        stan::math::fill(work, DUMMY_VAR__);
        current_statement_begin__ = 3173;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 3174;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3175;
        stan::math::assign(p, num_elements(x));
        current_statement_begin__ = 3176;
        stan::math::assign(work, x);
        current_statement_begin__ = 3177;
        stan::math::assign(x_new, x);
        current_statement_begin__ = 3178;
        if (as_bool(logical_gt(p, 1))) {
            current_statement_begin__ = 3179;
            for (int j = 2; j <= p; ++j) {
                current_statement_begin__ = 3180;
                stan::math::assign(a, get_base1(x_new, j, "x_new", 1));
                current_statement_begin__ = 3181;
                for (int k = 1; k <= (j - 1); ++k) {
                    current_statement_begin__ = 3182;
                    stan::model::assign(work, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                (get_base1(work, k, "work", 1) - (a * get_base1(x_new, (j - k), "x_new", 1))), 
                                "assigning variable work");
                }
                current_statement_begin__ = 3184;
                for (int k = 1; k <= j; ++k) {
                    current_statement_begin__ = 3185;
                    stan::model::assign(x_new, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                get_base1(work, k, "work", 1), 
                                "assigning variable x_new");
                }
            }
        }
        current_statement_begin__ = 3189;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct pacf_to_acf_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return pacf_to_acf(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
constrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3229;
        validate_non_negative_index("r", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r(num_elements(x));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 3230;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3231;
        stan::math::assign(n, num_elements(x));
        current_statement_begin__ = 3233;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3234;
            stan::model::assign(r, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        stan::math::tanh(get_base1(x, i, "x", 1)), 
                        "assigning variable r");
        }
        current_statement_begin__ = 3237;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pacf_to_acf(r, pstream__));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct constrain_stationary_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return constrain_stationary(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
acf_to_pacf(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3258;
        validate_non_negative_index("x_new", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> x_new(num_elements(x));
        stan::math::initialize(x_new, DUMMY_VAR__);
        stan::math::fill(x_new, DUMMY_VAR__);
        current_statement_begin__ = 3259;
        validate_non_negative_index("work", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> work(num_elements(x));
        stan::math::initialize(work, DUMMY_VAR__);
        stan::math::fill(work, DUMMY_VAR__);
        current_statement_begin__ = 3260;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 3261;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3262;
        stan::math::assign(p, num_elements(x));
        current_statement_begin__ = 3263;
        stan::math::assign(work, x);
        current_statement_begin__ = 3264;
        stan::math::assign(x_new, x);
        current_statement_begin__ = 3266;
        if (as_bool(logical_gt(p, 1))) {
            current_statement_begin__ = 3267;
            for (int i = 0; i <= (p - 2); ++i) {
                {
                current_statement_begin__ = 3268;
                int j(0);
                (void) j;  // dummy to suppress unused var warning
                stan::math::fill(j, std::numeric_limits<int>::min());
                current_statement_begin__ = 3269;
                stan::math::assign(j, (p - i));
                current_statement_begin__ = 3270;
                stan::math::assign(a, get_base1(x_new, j, "x_new", 1));
                current_statement_begin__ = 3271;
                for (int k = 1; k <= (j - 1); ++k) {
                    current_statement_begin__ = 3272;
                    stan::model::assign(work, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                ((get_base1(x_new, k, "x_new", 1) + (a * get_base1(x_new, (j - k), "x_new", 1))) / (1 - pow(a, 2))), 
                                "assigning variable work");
                }
                current_statement_begin__ = 3274;
                for (int k = 1; k <= j; ++k) {
                    current_statement_begin__ = 3275;
                    stan::model::assign(x_new, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                get_base1(work, k, "work", 1), 
                                "assigning variable x_new");
                }
                }
            }
        }
        current_statement_begin__ = 3279;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct acf_to_pacf_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return acf_to_pacf(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
unconstrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3296;
        validate_non_negative_index("y", "num_elements(x)", num_elements(x));
        validate_non_negative_index("y", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(num_elements(x), num_elements(x));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 3297;
        validate_non_negative_index("r", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r(num_elements(x));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 3298;
        validate_non_negative_index("z", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> z(num_elements(x));
        stan::math::initialize(z, DUMMY_VAR__);
        stan::math::fill(z, DUMMY_VAR__);
        current_statement_begin__ = 3299;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3300;
        stan::math::assign(n, num_elements(x));
        current_statement_begin__ = 3302;
        stan::math::assign(r, acf_to_pacf(x, pstream__));
        current_statement_begin__ = 3304;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3305;
            stan::model::assign(z, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        stan::math::atanh(get_base1(r, i, "r", 1)), 
                        "assigning variable z");
        }
        current_statement_begin__ = 3307;
        return stan::math::promote_scalar<fun_return_scalar_t__>(z);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct unconstrain_stationary_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return unconstrain_stationary(x, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
kronecker_prod(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3334;
        validate_non_negative_index("C", "(rows(A) * rows(B))", (rows(A) * rows(B)));
        validate_non_negative_index("C", "(cols(A) * cols(B))", (cols(A) * cols(B)));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> C((rows(A) * rows(B)), (cols(A) * cols(B)));
        stan::math::initialize(C, DUMMY_VAR__);
        stan::math::fill(C, DUMMY_VAR__);
        current_statement_begin__ = 3335;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3336;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3337;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3338;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 3339;
        stan::math::assign(m, rows(A));
        current_statement_begin__ = 3340;
        stan::math::assign(n, cols(A));
        current_statement_begin__ = 3341;
        stan::math::assign(p, rows(B));
        current_statement_begin__ = 3342;
        stan::math::assign(q, cols(B));
        current_statement_begin__ = 3343;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 3344;
            for (int j = 1; j <= n; ++j) {
                {
                current_statement_begin__ = 3345;
                int row_start(0);
                (void) row_start;  // dummy to suppress unused var warning
                stan::math::fill(row_start, std::numeric_limits<int>::min());
                current_statement_begin__ = 3346;
                int row_end(0);
                (void) row_end;  // dummy to suppress unused var warning
                stan::math::fill(row_end, std::numeric_limits<int>::min());
                current_statement_begin__ = 3347;
                int col_start(0);
                (void) col_start;  // dummy to suppress unused var warning
                stan::math::fill(col_start, std::numeric_limits<int>::min());
                current_statement_begin__ = 3348;
                int col_end(0);
                (void) col_end;  // dummy to suppress unused var warning
                stan::math::fill(col_end, std::numeric_limits<int>::min());
                current_statement_begin__ = 3349;
                stan::math::assign(row_start, (((i - 1) * p) + 1));
                current_statement_begin__ = 3350;
                stan::math::assign(row_end, (((i - 1) * p) + p));
                current_statement_begin__ = 3351;
                stan::math::assign(col_start, (((j - 1) * q) + 1));
                current_statement_begin__ = 3352;
                stan::math::assign(col_end, (((j - 1) * q) + q));
                current_statement_begin__ = 3353;
                stan::model::assign(C, 
                            stan::model::cons_list(stan::model::index_min_max(row_start, row_end), stan::model::cons_list(stan::model::index_min_max(col_start, col_end), stan::model::nil_index_list())), 
                            multiply(get_base1(A, i, j, "A", 1), B), 
                            "assigning variable C");
                }
            }
        }
        current_statement_begin__ = 3356;
        return stan::math::promote_scalar<fun_return_scalar_t__>(C);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct kronecker_prod_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return kronecker_prod(A, B, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
stationary_cov(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& T,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3398;
        validate_non_negative_index("P", "rows(T)", rows(T));
        validate_non_negative_index("P", "cols(T)", cols(T));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(rows(T), cols(T));
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 3399;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3400;
        stan::math::assign(m, rows(T));
        current_statement_begin__ = 3403;
        if (as_bool(logical_eq(m, 1))) {
            current_statement_begin__ = 3404;
            stan::model::assign(P, 
                        stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        (get_base1(RQR, 1, 1, "RQR", 1) / (1.0 - pow(get_base1(T, 1, 1, "T", 1), 2))), 
                        "assigning variable P");
        } else {
            {
            current_statement_begin__ = 3406;
            validate_non_negative_index("TT", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            validate_non_negative_index("TT", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> TT((rows(T) * rows(T)), (rows(T) * rows(T)));
            stan::math::initialize(TT, DUMMY_VAR__);
            stan::math::fill(TT, DUMMY_VAR__);
            current_statement_begin__ = 3407;
            validate_non_negative_index("RQR_vec", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> RQR_vec((rows(T) * rows(T)));
            stan::math::initialize(RQR_vec, DUMMY_VAR__);
            stan::math::fill(RQR_vec, DUMMY_VAR__);
            current_statement_begin__ = 3408;
            int m2(0);
            (void) m2;  // dummy to suppress unused var warning
            stan::math::fill(m2, std::numeric_limits<int>::min());
            current_statement_begin__ = 3409;
            stan::math::assign(m2, (m * m));
            current_statement_begin__ = 3410;
            stan::math::assign(RQR_vec, to_vector(RQR));
            current_statement_begin__ = 3412;
            stan::math::assign(TT, minus(kronecker_prod(T, T, pstream__)));
            current_statement_begin__ = 3413;
            for (int i = 1; i <= m2; ++i) {
                current_statement_begin__ = 3414;
                stan::model::assign(TT, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            (1.0 + get_base1(TT, i, i, "TT", 1)), 
                            "assigning variable TT");
            }
            current_statement_begin__ = 3416;
            stan::math::assign(P, to_matrix_colwise(multiply(inverse(TT), RQR_vec), m, m, pstream__));
            }
        }
        current_statement_begin__ = 3418;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct stationary_cov_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& T,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) const {
        return stationary_cov(T, RQR, pstream__);
    }
};
Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>
sarima_build_observation_matrices(const int& m, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3432;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,1);
        current_statement_begin__ = 3435;
        validate_non_negative_index("d", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d(p);
        stan::math::initialize(d, DUMMY_VAR__);
        stan::math::fill(d, DUMMY_VAR__);
        stan::math::assign(d,rep_vector(0, p));
        current_statement_begin__ = 3438;
        validate_non_negative_index("Z", "p", p);
        validate_non_negative_index("Z", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z(p, m);
        stan::math::initialize(Z, DUMMY_VAR__);
        stan::math::fill(Z, DUMMY_VAR__);
        stan::math::assign(Z,append_col(stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<local_scalar_t__ >().add(1).array())).array()), to_matrix(rep_row_vector(0, (m - 1)))));
        current_statement_begin__ = 3441;
        validate_non_negative_index("H", "p", p);
        validate_non_negative_index("H", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H(p, p);
        stan::math::initialize(H, DUMMY_VAR__);
        stan::math::fill(H, DUMMY_VAR__);
        stan::math::assign(H,stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<local_scalar_t__ >().add(0).array())).array()));
        current_statement_begin__ = 3444;
        validate_non_negative_index("result", "p", p);
        validate_non_negative_index("result", "((1 + m) + p)", ((1 + m) + p));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> result(p, ((1 + m) + p));
        stan::math::initialize(result, DUMMY_VAR__);
        stan::math::fill(result, DUMMY_VAR__);
        stan::math::assign(result,append_col(append_col(to_matrix(d), Z), H));
        current_statement_begin__ = 3446;
        return stan::math::promote_scalar<fun_return_scalar_t__>(result);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct sarima_build_observation_matrices_functor__ {
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const int& m, std::ostream* pstream__) const {
        return sarima_build_observation_matrices(m, pstream__);
    }
};
template <typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
Eigen::Matrix<typename boost::math::tools::promote_args<T6__, T7__, T8__, T9__, typename boost::math::tools::promote_args<T10__, T11__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
sarima_build_state_matrices(const int& p_ar,
                                const int& q_ma,
                                const int& P_ar,
                                const int& Q_ma,
                                const int& ts_frequency,
                                const int& include_intercept,
                                const Eigen::Matrix<T6__, Eigen::Dynamic, 1>& phi_0,
                                const Eigen::Matrix<T7__, Eigen::Dynamic, 1>& phi,
                                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& phi_seasonal,
                                const Eigen::Matrix<T9__, Eigen::Dynamic, 1>& theta,
                                const Eigen::Matrix<T10__, Eigen::Dynamic, 1>& theta_seasonal,
                                const T11__& var_zeta, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T6__, T7__, T8__, T9__, typename boost::math::tools::promote_args<T10__, T11__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3467;
        int r(0);
        (void) r;  // dummy to suppress unused var warning
        stan::math::fill(r, std::numeric_limits<int>::min());
        stan::math::assign(r,std::max((p_ar + (P_ar * ts_frequency)), ((q_ma + (Q_ma * ts_frequency)) + 1)));
        current_statement_begin__ = 3469;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,r);
        current_statement_begin__ = 3472;
        validate_non_negative_index("c", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c(m);
        stan::math::initialize(c, DUMMY_VAR__);
        stan::math::fill(c, DUMMY_VAR__);
        current_statement_begin__ = 3475;
        validate_non_negative_index("Q", "1", 1);
        validate_non_negative_index("Q", "1", 1);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q(1, 1);
        stan::math::initialize(Q, DUMMY_VAR__);
        stan::math::fill(Q, DUMMY_VAR__);
        stan::math::assign(Q,stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<local_scalar_t__ >().add(var_zeta).array())).array()));
        current_statement_begin__ = 3478;
        validate_non_negative_index("T", "m", m);
        validate_non_negative_index("T", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T(m, m);
        stan::math::initialize(T, DUMMY_VAR__);
        stan::math::fill(T, DUMMY_VAR__);
        current_statement_begin__ = 3479;
        validate_non_negative_index("R", "m", m);
        validate_non_negative_index("R", "1", 1);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R(m, 1);
        stan::math::initialize(R, DUMMY_VAR__);
        stan::math::fill(R, DUMMY_VAR__);
        current_statement_begin__ = 3482;
        validate_non_negative_index("a0", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a0(m);
        stan::math::initialize(a0, DUMMY_VAR__);
        stan::math::fill(a0, DUMMY_VAR__);
        stan::math::assign(a0,rep_vector(0, m));
        current_statement_begin__ = 3485;
        validate_non_negative_index("a1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a1(m);
        stan::math::initialize(a1, DUMMY_VAR__);
        stan::math::fill(a1, DUMMY_VAR__);
        current_statement_begin__ = 3488;
        validate_non_negative_index("P1", "m", m);
        validate_non_negative_index("P1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
        stan::math::initialize(P1, DUMMY_VAR__);
        stan::math::fill(P1, DUMMY_VAR__);
        current_statement_begin__ = 3491;
        validate_non_negative_index("result", "m", m);
        validate_non_negative_index("result", "(((((1 + m) + 1) + 1) + 1) + m)", (((((1 + m) + 1) + 1) + 1) + m));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> result(m, (((((1 + m) + 1) + 1) + 1) + m));
        stan::math::initialize(result, DUMMY_VAR__);
        stan::math::fill(result, DUMMY_VAR__);
        current_statement_begin__ = 3494;
        validate_non_negative_index("dummy_phi", "r", r);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> dummy_phi(r);
        stan::math::initialize(dummy_phi, DUMMY_VAR__);
        stan::math::fill(dummy_phi, DUMMY_VAR__);
        stan::math::assign(dummy_phi,rep_vector(0, r));
        current_statement_begin__ = 3497;
        validate_non_negative_index("dummy_theta", "(r - 1)", (r - 1));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> dummy_theta((r - 1));
        stan::math::initialize(dummy_theta, DUMMY_VAR__);
        stan::math::fill(dummy_theta, DUMMY_VAR__);
        stan::math::assign(dummy_theta,rep_vector(0, (r - 1)));
        current_statement_begin__ = 3500;
        if (as_bool(logical_gt(p_ar, 0))) {
            current_statement_begin__ = 3501;
            stan::model::assign(dummy_phi, 
                        stan::model::cons_list(stan::model::index_min_max(1, p_ar), stan::model::nil_index_list()), 
                        phi, 
                        "assigning variable dummy_phi");
        }
        current_statement_begin__ = 3504;
        if (as_bool(logical_gt(P_ar, 0))) {
            current_statement_begin__ = 3505;
            for (int i = 1; i <= P_ar; ++i) {
                current_statement_begin__ = 3506;
                stan::model::assign(dummy_phi, 
                            stan::model::cons_list(stan::model::index_uni((i * ts_frequency)), stan::model::nil_index_list()), 
                            get_base1(phi_seasonal, i, "phi_seasonal", 1), 
                            "assigning variable dummy_phi");
            }
        }
        current_statement_begin__ = 3510;
        if (as_bool((primitive_value(logical_gt(p_ar, 0)) && primitive_value(logical_gt(P_ar, 0))))) {
            current_statement_begin__ = 3511;
            for (int i = 1; i <= p_ar; ++i) {
                current_statement_begin__ = 3512;
                for (int j = 1; j <= P_ar; ++j) {
                    current_statement_begin__ = 3513;
                    stan::model::assign(dummy_phi, 
                                stan::model::cons_list(stan::model::index_uni((i + (j * ts_frequency))), stan::model::nil_index_list()), 
                                (-(get_base1(phi, i, "phi", 1)) * get_base1(phi_seasonal, j, "phi_seasonal", 1)), 
                                "assigning variable dummy_phi");
                }
            }
        }
        current_statement_begin__ = 3519;
        if (as_bool(logical_gt(q_ma, 0))) {
            current_statement_begin__ = 3520;
            stan::model::assign(dummy_theta, 
                        stan::model::cons_list(stan::model::index_min_max(1, q_ma), stan::model::nil_index_list()), 
                        theta, 
                        "assigning variable dummy_theta");
        }
        current_statement_begin__ = 3523;
        if (as_bool(logical_gt(Q_ma, 0))) {
            current_statement_begin__ = 3524;
            for (int i = 1; i <= Q_ma; ++i) {
                current_statement_begin__ = 3525;
                stan::model::assign(dummy_theta, 
                            stan::model::cons_list(stan::model::index_uni((i * ts_frequency)), stan::model::nil_index_list()), 
                            get_base1(theta_seasonal, i, "theta_seasonal", 1), 
                            "assigning variable dummy_theta");
            }
        }
        current_statement_begin__ = 3529;
        if (as_bool((primitive_value(logical_gt(q_ma, 0)) && primitive_value(logical_gt(Q_ma, 0))))) {
            current_statement_begin__ = 3530;
            for (int i = 1; i <= q_ma; ++i) {
                current_statement_begin__ = 3531;
                for (int j = 1; j <= Q_ma; ++j) {
                    current_statement_begin__ = 3532;
                    stan::model::assign(dummy_theta, 
                                stan::model::cons_list(stan::model::index_uni((i + (j * ts_frequency))), stan::model::nil_index_list()), 
                                (-(get_base1(theta, i, "theta", 1)) * get_base1(theta_seasonal, j, "theta_seasonal", 1)), 
                                "assigning variable dummy_theta");
                }
            }
        }
        current_statement_begin__ = 3538;
        stan::math::assign(R, append_row(stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<local_scalar_t__ >().add(1).array())).array()), to_matrix(dummy_theta)));
        current_statement_begin__ = 3541;
        stan::math::assign(T, append_col(dummy_phi, append_row(diag_matrix(rep_vector(1, (m - 1))), to_matrix(rep_row_vector(0, (m - 1))))));
        current_statement_begin__ = 3546;
        stan::math::assign(P1, multiply(var_zeta, stationary_cov(T, quad_form_sym(Q, transpose(R)), pstream__)));
        current_statement_begin__ = 3549;
        if (as_bool(include_intercept)) {
            current_statement_begin__ = 3550;
            stan::math::assign(c, append_row(phi_0, rep_vector(0, (m - 1))));
        } else {
            current_statement_begin__ = 3552;
            stan::math::assign(c, rep_vector(0, m));
        }
        current_statement_begin__ = 3556;
        stan::math::assign(a1, ssm_update_predicted_a(c, T, a0, pstream__));
        current_statement_begin__ = 3557;
        stan::math::assign(P1, ssm_update_predicted_P(P1, T, quad_form_sym(Q, transpose(R)), pstream__));
        current_statement_begin__ = 3560;
        stan::model::assign(result, 
                    stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    c, 
                    "assigning variable result");
        current_statement_begin__ = 3561;
        stan::model::assign(result, 
                    stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max((1 + 1), (1 + m)), stan::model::nil_index_list())), 
                    T, 
                    "assigning variable result");
        current_statement_begin__ = 3562;
        stan::model::assign(result, 
                    stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(((1 + m) + 1), ((1 + m) + 1)), stan::model::nil_index_list())), 
                    R, 
                    "assigning variable result");
        current_statement_begin__ = 3563;
        stan::model::assign(result, 
                    stan::model::cons_list(stan::model::index_min_max(1, 1), stan::model::cons_list(stan::model::index_min_max((((1 + m) + 1) + 1), (((1 + m) + 1) + 1)), stan::model::nil_index_list())), 
                    Q, 
                    "assigning variable result");
        current_statement_begin__ = 3564;
        stan::model::assign(result, 
                    stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(((((1 + m) + 1) + 1) + 1)), stan::model::nil_index_list())), 
                    a1, 
                    "assigning variable result");
        current_statement_begin__ = 3565;
        stan::model::assign(result, 
                    stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max((((((1 + m) + 1) + 1) + 1) + 1), (((((1 + m) + 1) + 1) + 1) + m)), stan::model::nil_index_list())), 
                    P1, 
                    "assigning variable result");
        current_statement_begin__ = 3567;
        return stan::math::promote_scalar<fun_return_scalar_t__>(result);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct sarima_build_state_matrices_functor__ {
    template <typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T11__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T6__, T7__, T8__, T9__, typename boost::math::tools::promote_args<T10__, T11__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const int& p_ar,
                                const int& q_ma,
                                const int& P_ar,
                                const int& Q_ma,
                                const int& ts_frequency,
                                const int& include_intercept,
                                const Eigen::Matrix<T6__, Eigen::Dynamic, 1>& phi_0,
                                const Eigen::Matrix<T7__, Eigen::Dynamic, 1>& phi,
                                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& phi_seasonal,
                                const Eigen::Matrix<T9__, Eigen::Dynamic, 1>& theta,
                                const Eigen::Matrix<T10__, Eigen::Dynamic, 1>& theta_seasonal,
                                const T11__& var_zeta, std::ostream* pstream__) const {
        return sarima_build_state_matrices(p_ar, q_ma, P_ar, Q_ma, ts_frequency, include_intercept, phi_0, phi, phi_seasonal, theta, theta_seasonal, var_zeta, pstream__);
    }
};
#include <stan_meta_header.hpp>
class model_SARIMA_model
  : public stan::model::model_base_crtp<model_SARIMA_model> {
private:
        int n;
        int p;
        std::vector<vector_d> y;
        int p_ar;
        int q_ma;
        int P_ar;
        int Q_ma;
        int ts_frequency;
        int include_intercept;
        int stationary;
        int horizon;
        int r;
        int m;
        matrix_d observation_matrices;
        vector_d d;
        matrix_d Z;
        matrix_d H;
public:
    model_SARIMA_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, 0, pstream__);
    }
    model_SARIMA_model(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, random_seed__, pstream__);
    }
    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning
        current_statement_begin__ = -1;
        static const char* function__ = "model_SARIMA_model_namespace::model_SARIMA_model";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        try {
            // initialize data block variables from context__
            current_statement_begin__ = 3573;
            context__.validate_dims("data initialization", "n", "int", context__.to_vec());
            n = int(0);
            vals_i__ = context__.vals_i("n");
            pos__ = 0;
            n = vals_i__[pos__++];
            check_greater_or_equal(function__, "n", n, 0);
            current_statement_begin__ = 3575;
            context__.validate_dims("data initialization", "p", "int", context__.to_vec());
            p = int(0);
            vals_i__ = context__.vals_i("p");
            pos__ = 0;
            p = vals_i__[pos__++];
            check_greater_or_equal(function__, "p", p, 0);
            current_statement_begin__ = 3577;
            validate_non_negative_index("y", "p", p);
            validate_non_negative_index("y", "n", n);
            context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(n,p));
            y = std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> >(n, Eigen::Matrix<double, Eigen::Dynamic, 1>(p));
            vals_r__ = context__.vals_r("y");
            pos__ = 0;
            size_t y_j_1_max__ = p;
            size_t y_k_0_max__ = n;
            for (size_t j_1__ = 0; j_1__ < y_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < y_k_0_max__; ++k_0__) {
                    y[k_0__](j_1__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 3579;
            context__.validate_dims("data initialization", "p_ar", "int", context__.to_vec());
            p_ar = int(0);
            vals_i__ = context__.vals_i("p_ar");
            pos__ = 0;
            p_ar = vals_i__[pos__++];
            check_greater_or_equal(function__, "p_ar", p_ar, 0);
            current_statement_begin__ = 3581;
            context__.validate_dims("data initialization", "q_ma", "int", context__.to_vec());
            q_ma = int(0);
            vals_i__ = context__.vals_i("q_ma");
            pos__ = 0;
            q_ma = vals_i__[pos__++];
            check_greater_or_equal(function__, "q_ma", q_ma, 0);
            current_statement_begin__ = 3583;
            context__.validate_dims("data initialization", "P_ar", "int", context__.to_vec());
            P_ar = int(0);
            vals_i__ = context__.vals_i("P_ar");
            pos__ = 0;
            P_ar = vals_i__[pos__++];
            check_greater_or_equal(function__, "P_ar", P_ar, 0);
            current_statement_begin__ = 3585;
            context__.validate_dims("data initialization", "Q_ma", "int", context__.to_vec());
            Q_ma = int(0);
            vals_i__ = context__.vals_i("Q_ma");
            pos__ = 0;
            Q_ma = vals_i__[pos__++];
            check_greater_or_equal(function__, "Q_ma", Q_ma, 0);
            current_statement_begin__ = 3588;
            context__.validate_dims("data initialization", "ts_frequency", "int", context__.to_vec());
            ts_frequency = int(0);
            vals_i__ = context__.vals_i("ts_frequency");
            pos__ = 0;
            ts_frequency = vals_i__[pos__++];
            check_greater_or_equal(function__, "ts_frequency", ts_frequency, 0);
            current_statement_begin__ = 3592;
            context__.validate_dims("data initialization", "include_intercept", "int", context__.to_vec());
            include_intercept = int(0);
            vals_i__ = context__.vals_i("include_intercept");
            pos__ = 0;
            include_intercept = vals_i__[pos__++];
            check_greater_or_equal(function__, "include_intercept", include_intercept, 0);
            check_less_or_equal(function__, "include_intercept", include_intercept, 1);
            current_statement_begin__ = 3596;
            context__.validate_dims("data initialization", "stationary", "int", context__.to_vec());
            stationary = int(0);
            vals_i__ = context__.vals_i("stationary");
            pos__ = 0;
            stationary = vals_i__[pos__++];
            check_greater_or_equal(function__, "stationary", stationary, 0);
            check_less_or_equal(function__, "stationary", stationary, 1);
            current_statement_begin__ = 3602;
            context__.validate_dims("data initialization", "horizon", "int", context__.to_vec());
            horizon = int(0);
            vals_i__ = context__.vals_i("horizon");
            pos__ = 0;
            horizon = vals_i__[pos__++];
            check_greater_or_equal(function__, "horizon", horizon, 0);
            // initialize transformed data variables
            current_statement_begin__ = 3606;
            r = int(0);
            stan::math::fill(r, std::numeric_limits<int>::min());
            stan::math::assign(r,std::max((p_ar + (P_ar * ts_frequency)), ((q_ma + (Q_ma * ts_frequency)) + 1)));
            current_statement_begin__ = 3610;
            m = int(0);
            stan::math::fill(m, std::numeric_limits<int>::min());
            stan::math::assign(m,r);
            current_statement_begin__ = 3613;
            validate_non_negative_index("observation_matrices", "p", p);
            validate_non_negative_index("observation_matrices", "((1 + m) + p)", ((1 + m) + p));
            observation_matrices = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(p, ((1 + m) + p));
            stan::math::fill(observation_matrices, DUMMY_VAR__);
            stan::math::assign(observation_matrices,sarima_build_observation_matrices(m, pstream__));
            current_statement_begin__ = 3617;
            validate_non_negative_index("d", "p", p);
            d = Eigen::Matrix<double, Eigen::Dynamic, 1>(p);
            stan::math::fill(d, DUMMY_VAR__);
            stan::math::assign(d,stan::model::rvalue(observation_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "observation_matrices"));
            current_statement_begin__ = 3620;
            validate_non_negative_index("Z", "p", p);
            validate_non_negative_index("Z", "m", m);
            Z = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(p, m);
            stan::math::fill(Z, DUMMY_VAR__);
            stan::math::assign(Z,stan::model::rvalue(observation_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max((1 + 1), (1 + m)), stan::model::nil_index_list())), "observation_matrices"));
            current_statement_begin__ = 3623;
            validate_non_negative_index("H", "p", p);
            validate_non_negative_index("H", "p", p);
            H = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(p, p);
            stan::math::fill(H, DUMMY_VAR__);
            stan::math::assign(H,stan::model::rvalue(observation_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(((1 + m) + 1), ((1 + m) + p)), stan::model::nil_index_list())), "observation_matrices"));
            // execute transformed data statements
            // validate transformed data
            current_statement_begin__ = 3606;
            check_greater_or_equal(function__, "r", r, 0);
            current_statement_begin__ = 3610;
            check_greater_or_equal(function__, "m", m, 0);
            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 3628;
            validate_non_negative_index("phi_0", "include_intercept", include_intercept);
            num_params_r__ += include_intercept;
            current_statement_begin__ = 3631;
            validate_non_negative_index("unconstrained_phi", "p_ar", p_ar);
            num_params_r__ += p_ar;
            current_statement_begin__ = 3634;
            validate_non_negative_index("unconstrained_phi_seasonal", "P_ar", P_ar);
            num_params_r__ += P_ar;
            current_statement_begin__ = 3637;
            validate_non_negative_index("unconstrained_theta", "q_ma", q_ma);
            num_params_r__ += q_ma;
            current_statement_begin__ = 3640;
            validate_non_negative_index("unconstrained_theta_seasonal", "Q_ma", Q_ma);
            num_params_r__ += Q_ma;
            current_statement_begin__ = 3643;
            num_params_r__ += 1;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    ~model_SARIMA_model() { }
    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        typedef double local_scalar_t__;
        stan::io::writer<double> writer__(params_r__, params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;
        current_statement_begin__ = 3628;
        if (!(context__.contains_r("phi_0")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable phi_0 missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("phi_0");
        pos__ = 0U;
        validate_non_negative_index("phi_0", "include_intercept", include_intercept);
        context__.validate_dims("parameter initialization", "phi_0", "vector_d", context__.to_vec(include_intercept));
        Eigen::Matrix<double, Eigen::Dynamic, 1> phi_0(include_intercept);
        size_t phi_0_j_1_max__ = include_intercept;
        for (size_t j_1__ = 0; j_1__ < phi_0_j_1_max__; ++j_1__) {
            phi_0(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(phi_0);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable phi_0: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 3631;
        if (!(context__.contains_r("unconstrained_phi")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable unconstrained_phi missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("unconstrained_phi");
        pos__ = 0U;
        validate_non_negative_index("unconstrained_phi", "p_ar", p_ar);
        context__.validate_dims("parameter initialization", "unconstrained_phi", "vector_d", context__.to_vec(p_ar));
        Eigen::Matrix<double, Eigen::Dynamic, 1> unconstrained_phi(p_ar);
        size_t unconstrained_phi_j_1_max__ = p_ar;
        for (size_t j_1__ = 0; j_1__ < unconstrained_phi_j_1_max__; ++j_1__) {
            unconstrained_phi(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(unconstrained_phi);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable unconstrained_phi: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 3634;
        if (!(context__.contains_r("unconstrained_phi_seasonal")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable unconstrained_phi_seasonal missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("unconstrained_phi_seasonal");
        pos__ = 0U;
        validate_non_negative_index("unconstrained_phi_seasonal", "P_ar", P_ar);
        context__.validate_dims("parameter initialization", "unconstrained_phi_seasonal", "vector_d", context__.to_vec(P_ar));
        Eigen::Matrix<double, Eigen::Dynamic, 1> unconstrained_phi_seasonal(P_ar);
        size_t unconstrained_phi_seasonal_j_1_max__ = P_ar;
        for (size_t j_1__ = 0; j_1__ < unconstrained_phi_seasonal_j_1_max__; ++j_1__) {
            unconstrained_phi_seasonal(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(unconstrained_phi_seasonal);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable unconstrained_phi_seasonal: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 3637;
        if (!(context__.contains_r("unconstrained_theta")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable unconstrained_theta missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("unconstrained_theta");
        pos__ = 0U;
        validate_non_negative_index("unconstrained_theta", "q_ma", q_ma);
        context__.validate_dims("parameter initialization", "unconstrained_theta", "vector_d", context__.to_vec(q_ma));
        Eigen::Matrix<double, Eigen::Dynamic, 1> unconstrained_theta(q_ma);
        size_t unconstrained_theta_j_1_max__ = q_ma;
        for (size_t j_1__ = 0; j_1__ < unconstrained_theta_j_1_max__; ++j_1__) {
            unconstrained_theta(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(unconstrained_theta);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable unconstrained_theta: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 3640;
        if (!(context__.contains_r("unconstrained_theta_seasonal")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable unconstrained_theta_seasonal missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("unconstrained_theta_seasonal");
        pos__ = 0U;
        validate_non_negative_index("unconstrained_theta_seasonal", "Q_ma", Q_ma);
        context__.validate_dims("parameter initialization", "unconstrained_theta_seasonal", "vector_d", context__.to_vec(Q_ma));
        Eigen::Matrix<double, Eigen::Dynamic, 1> unconstrained_theta_seasonal(Q_ma);
        size_t unconstrained_theta_seasonal_j_1_max__ = Q_ma;
        for (size_t j_1__ = 0; j_1__ < unconstrained_theta_seasonal_j_1_max__; ++j_1__) {
            unconstrained_theta_seasonal(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(unconstrained_theta_seasonal);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable unconstrained_theta_seasonal: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 3643;
        if (!(context__.contains_r("var_zeta")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable var_zeta missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("var_zeta");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "var_zeta", "double", context__.to_vec());
        double var_zeta(0);
        var_zeta = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0, var_zeta);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable var_zeta: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }
    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }
    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(std::vector<T__>& params_r__,
                 std::vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {
        typedef T__ local_scalar_t__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // dummy to suppress unused var warning
        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;
        try {
            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
            // model parameters
            current_statement_begin__ = 3628;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> phi_0;
            (void) phi_0;  // dummy to suppress unused var warning
            if (jacobian__)
                phi_0 = in__.vector_constrain(include_intercept, lp__);
            else
                phi_0 = in__.vector_constrain(include_intercept);
            current_statement_begin__ = 3631;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> unconstrained_phi;
            (void) unconstrained_phi;  // dummy to suppress unused var warning
            if (jacobian__)
                unconstrained_phi = in__.vector_constrain(p_ar, lp__);
            else
                unconstrained_phi = in__.vector_constrain(p_ar);
            current_statement_begin__ = 3634;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> unconstrained_phi_seasonal;
            (void) unconstrained_phi_seasonal;  // dummy to suppress unused var warning
            if (jacobian__)
                unconstrained_phi_seasonal = in__.vector_constrain(P_ar, lp__);
            else
                unconstrained_phi_seasonal = in__.vector_constrain(P_ar);
            current_statement_begin__ = 3637;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> unconstrained_theta;
            (void) unconstrained_theta;  // dummy to suppress unused var warning
            if (jacobian__)
                unconstrained_theta = in__.vector_constrain(q_ma, lp__);
            else
                unconstrained_theta = in__.vector_constrain(q_ma);
            current_statement_begin__ = 3640;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> unconstrained_theta_seasonal;
            (void) unconstrained_theta_seasonal;  // dummy to suppress unused var warning
            if (jacobian__)
                unconstrained_theta_seasonal = in__.vector_constrain(Q_ma, lp__);
            else
                unconstrained_theta_seasonal = in__.vector_constrain(Q_ma);
            current_statement_begin__ = 3643;
            local_scalar_t__ var_zeta;
            (void) var_zeta;  // dummy to suppress unused var warning
            if (jacobian__)
                var_zeta = in__.scalar_lb_constrain(0, lp__);
            else
                var_zeta = in__.scalar_lb_constrain(0);
            // transformed parameters
            current_statement_begin__ = 3648;
            validate_non_negative_index("phi", "p_ar", p_ar);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> phi(p_ar);
            stan::math::initialize(phi, DUMMY_VAR__);
            stan::math::fill(phi, DUMMY_VAR__);
            current_statement_begin__ = 3649;
            validate_non_negative_index("phi_seasonal", "P_ar", P_ar);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> phi_seasonal(P_ar);
            stan::math::initialize(phi_seasonal, DUMMY_VAR__);
            stan::math::fill(phi_seasonal, DUMMY_VAR__);
            current_statement_begin__ = 3653;
            validate_non_negative_index("theta", "q_ma", q_ma);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> theta(q_ma);
            stan::math::initialize(theta, DUMMY_VAR__);
            stan::math::fill(theta, DUMMY_VAR__);
            stan::math::assign(theta,unconstrained_theta);
            current_statement_begin__ = 3654;
            validate_non_negative_index("theta_seasonal", "Q_ma", Q_ma);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> theta_seasonal(Q_ma);
            stan::math::initialize(theta_seasonal, DUMMY_VAR__);
            stan::math::fill(theta_seasonal, DUMMY_VAR__);
            stan::math::assign(theta_seasonal,unconstrained_theta_seasonal);
            current_statement_begin__ = 3657;
            validate_non_negative_index("c", "m", m);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c(m);
            stan::math::initialize(c, DUMMY_VAR__);
            stan::math::fill(c, DUMMY_VAR__);
            current_statement_begin__ = 3658;
            validate_non_negative_index("T", "m", m);
            validate_non_negative_index("T", "m", m);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T(m, m);
            stan::math::initialize(T, DUMMY_VAR__);
            stan::math::fill(T, DUMMY_VAR__);
            current_statement_begin__ = 3659;
            validate_non_negative_index("R", "m", m);
            validate_non_negative_index("R", "1", 1);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R(m, 1);
            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R, DUMMY_VAR__);
            current_statement_begin__ = 3660;
            validate_non_negative_index("Q", "1", 1);
            validate_non_negative_index("Q", "1", 1);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q(1, 1);
            stan::math::initialize(Q, DUMMY_VAR__);
            stan::math::fill(Q, DUMMY_VAR__);
            current_statement_begin__ = 3661;
            validate_non_negative_index("a1", "m", m);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a1(m);
            stan::math::initialize(a1, DUMMY_VAR__);
            stan::math::fill(a1, DUMMY_VAR__);
            current_statement_begin__ = 3662;
            validate_non_negative_index("P1", "m", m);
            validate_non_negative_index("P1", "m", m);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
            stan::math::initialize(P1, DUMMY_VAR__);
            stan::math::fill(P1, DUMMY_VAR__);
            // transformed parameters block statements
            current_statement_begin__ = 3664;
            if (as_bool(stationary)) {
                current_statement_begin__ = 3665;
                stan::math::assign(phi, constrain_stationary(unconstrained_phi, pstream__));
                current_statement_begin__ = 3666;
                stan::math::assign(phi_seasonal, constrain_stationary(unconstrained_phi_seasonal, pstream__));
            } else {
                current_statement_begin__ = 3668;
                stan::math::assign(phi, unconstrained_phi);
                current_statement_begin__ = 3669;
                stan::math::assign(phi_seasonal, unconstrained_phi_seasonal);
            }
            current_statement_begin__ = 3671;
            if (pstream__) {
                stan_print(pstream__,"modified function");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3672;
            if (pstream__) {
                stan_print(pstream__,"Stationary = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3673;
            if (pstream__) {
                stan_print(pstream__,stationary);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3674;
            if (pstream__) {
                stan_print(pstream__,"phi = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3675;
            if (pstream__) {
                stan_print(pstream__,phi);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3676;
            if (pstream__) {
                stan_print(pstream__,"phi_seasonal = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3677;
            if (pstream__) {
                stan_print(pstream__,phi_seasonal);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3678;
            if (pstream__) {
                stan_print(pstream__,"theta = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3679;
            if (pstream__) {
                stan_print(pstream__,theta);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3680;
            if (pstream__) {
                stan_print(pstream__,"theta_seasonal = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3681;
            if (pstream__) {
                stan_print(pstream__,theta_seasonal);
                *pstream__ << std::endl;
            }
            {
            current_statement_begin__ = 3685;
            validate_non_negative_index("state_matrices", "m", m);
            validate_non_negative_index("state_matrices", "(((((1 + m) + 1) + 1) + 1) + m)", (((((1 + m) + 1) + 1) + 1) + m));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> state_matrices(m, (((((1 + m) + 1) + 1) + 1) + m));
            stan::math::initialize(state_matrices, DUMMY_VAR__);
            stan::math::fill(state_matrices, DUMMY_VAR__);
            stan::math::assign(state_matrices,sarima_build_state_matrices(p_ar, q_ma, P_ar, Q_ma, ts_frequency, include_intercept, phi_0, phi, phi_seasonal, theta, theta_seasonal, var_zeta, pstream__));
            current_statement_begin__ = 3690;
            stan::math::assign(c, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3693;
            stan::math::assign(T, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max((1 + 1), (1 + m)), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3694;
            stan::math::assign(R, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(((1 + m) + 1), ((1 + m) + 1)), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3697;
            stan::math::assign(Q, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_min_max(1, 1), stan::model::cons_list(stan::model::index_min_max((((1 + m) + 1) + 1), (((1 + m) + 1) + 1)), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3700;
            stan::math::assign(a1, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(((((1 + m) + 1) + 1) + 1)), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3703;
            stan::math::assign(P1, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max((((((1 + m) + 1) + 1) + 1) + 1), (((((1 + m) + 1) + 1) + 1) + m)), stan::model::nil_index_list())), "state_matrices"));
            }
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 3648;
            size_t phi_j_1_max__ = p_ar;
            for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(phi(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: phi" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable phi: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 3649;
            size_t phi_seasonal_j_1_max__ = P_ar;
            for (size_t j_1__ = 0; j_1__ < phi_seasonal_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(phi_seasonal(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: phi_seasonal" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable phi_seasonal: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 3653;
            size_t theta_j_1_max__ = q_ma;
            for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(theta(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: theta" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable theta: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 3654;
            size_t theta_seasonal_j_1_max__ = Q_ma;
            for (size_t j_1__ = 0; j_1__ < theta_seasonal_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(theta_seasonal(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: theta_seasonal" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable theta_seasonal: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 3657;
            size_t c_j_1_max__ = m;
            for (size_t j_1__ = 0; j_1__ < c_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(c(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: c" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable c: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 3658;
            size_t T_j_1_max__ = m;
            size_t T_j_2_max__ = m;
            for (size_t j_1__ = 0; j_1__ < T_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < T_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(T(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: T" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable T: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            current_statement_begin__ = 3659;
            size_t R_j_1_max__ = m;
            size_t R_j_2_max__ = 1;
            for (size_t j_1__ = 0; j_1__ < R_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < R_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(R(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: R" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable R: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            current_statement_begin__ = 3660;
            size_t Q_j_1_max__ = 1;
            size_t Q_j_2_max__ = 1;
            for (size_t j_1__ = 0; j_1__ < Q_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < Q_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(Q(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: Q" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable Q: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            current_statement_begin__ = 3661;
            size_t a1_j_1_max__ = m;
            for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(a1(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: a1" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable a1: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 3662;
            size_t P1_j_1_max__ = m;
            size_t P1_j_2_max__ = m;
            for (size_t j_1__ = 0; j_1__ < P1_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < P1_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(P1(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: P1" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable P1: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            // model body
            current_statement_begin__ = 3708;
            if (as_bool(logical_eq(horizon, 0))) {
                {
                current_statement_begin__ = 3709;
                local_scalar_t__ temp(DUMMY_VAR__);
                (void) temp;  // dummy to suppress unused var warning
                stan::math::initialize(temp, DUMMY_VAR__);
                stan::math::fill(temp, DUMMY_VAR__);
                current_statement_begin__ = 3710;
                if (pstream__) {
                    stan_print(pstream__,"calculating log likelihood...");
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 3711;
                stan::math::assign(temp, ssm_constant_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__));
                current_statement_begin__ = 3712;
                if (pstream__) {
                    stan_print(pstream__,"log likelihood = ");
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 3713;
                if (pstream__) {
                    stan_print(pstream__,temp);
                    *pstream__ << std::endl;
                }
                current_statement_begin__ = 3714;
                lp_accum__.add(ssm_constant_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__));
                }
            } else {
                current_statement_begin__ = 3716;
                lp_accum__.add(ssm_constant_forecast_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__));
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
        lp_accum__.add(lp__);
        return lp_accum__.sum();
    } // log_prob()
    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }
    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("phi_0");
        names__.push_back("unconstrained_phi");
        names__.push_back("unconstrained_phi_seasonal");
        names__.push_back("unconstrained_theta");
        names__.push_back("unconstrained_theta_seasonal");
        names__.push_back("var_zeta");
        names__.push_back("phi");
        names__.push_back("phi_seasonal");
        names__.push_back("theta");
        names__.push_back("theta_seasonal");
        names__.push_back("c");
        names__.push_back("T");
        names__.push_back("R");
        names__.push_back("Q");
        names__.push_back("a1");
        names__.push_back("P1");
    }
    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(include_intercept);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(p_ar);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(P_ar);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(q_ma);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Q_ma);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(p_ar);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(P_ar);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(q_ma);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(Q_ma);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(1);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(1);
        dims__.push_back(1);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(m);
        dimss__.push_back(dims__);
    }
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;
        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
        static const char* function__ = "model_SARIMA_model_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        Eigen::Matrix<double, Eigen::Dynamic, 1> phi_0 = in__.vector_constrain(include_intercept);
        size_t phi_0_j_1_max__ = include_intercept;
        for (size_t j_1__ = 0; j_1__ < phi_0_j_1_max__; ++j_1__) {
            vars__.push_back(phi_0(j_1__));
        }
        Eigen::Matrix<double, Eigen::Dynamic, 1> unconstrained_phi = in__.vector_constrain(p_ar);
        size_t unconstrained_phi_j_1_max__ = p_ar;
        for (size_t j_1__ = 0; j_1__ < unconstrained_phi_j_1_max__; ++j_1__) {
            vars__.push_back(unconstrained_phi(j_1__));
        }
        Eigen::Matrix<double, Eigen::Dynamic, 1> unconstrained_phi_seasonal = in__.vector_constrain(P_ar);
        size_t unconstrained_phi_seasonal_j_1_max__ = P_ar;
        for (size_t j_1__ = 0; j_1__ < unconstrained_phi_seasonal_j_1_max__; ++j_1__) {
            vars__.push_back(unconstrained_phi_seasonal(j_1__));
        }
        Eigen::Matrix<double, Eigen::Dynamic, 1> unconstrained_theta = in__.vector_constrain(q_ma);
        size_t unconstrained_theta_j_1_max__ = q_ma;
        for (size_t j_1__ = 0; j_1__ < unconstrained_theta_j_1_max__; ++j_1__) {
            vars__.push_back(unconstrained_theta(j_1__));
        }
        Eigen::Matrix<double, Eigen::Dynamic, 1> unconstrained_theta_seasonal = in__.vector_constrain(Q_ma);
        size_t unconstrained_theta_seasonal_j_1_max__ = Q_ma;
        for (size_t j_1__ = 0; j_1__ < unconstrained_theta_seasonal_j_1_max__; ++j_1__) {
            vars__.push_back(unconstrained_theta_seasonal(j_1__));
        }
        double var_zeta = in__.scalar_lb_constrain(0);
        vars__.push_back(var_zeta);
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        if (!include_tparams__ && !include_gqs__) return;
        try {
            // declare and define transformed parameters
            current_statement_begin__ = 3648;
            validate_non_negative_index("phi", "p_ar", p_ar);
            Eigen::Matrix<double, Eigen::Dynamic, 1> phi(p_ar);
            stan::math::initialize(phi, DUMMY_VAR__);
            stan::math::fill(phi, DUMMY_VAR__);
            current_statement_begin__ = 3649;
            validate_non_negative_index("phi_seasonal", "P_ar", P_ar);
            Eigen::Matrix<double, Eigen::Dynamic, 1> phi_seasonal(P_ar);
            stan::math::initialize(phi_seasonal, DUMMY_VAR__);
            stan::math::fill(phi_seasonal, DUMMY_VAR__);
            current_statement_begin__ = 3653;
            validate_non_negative_index("theta", "q_ma", q_ma);
            Eigen::Matrix<double, Eigen::Dynamic, 1> theta(q_ma);
            stan::math::initialize(theta, DUMMY_VAR__);
            stan::math::fill(theta, DUMMY_VAR__);
            stan::math::assign(theta,unconstrained_theta);
            current_statement_begin__ = 3654;
            validate_non_negative_index("theta_seasonal", "Q_ma", Q_ma);
            Eigen::Matrix<double, Eigen::Dynamic, 1> theta_seasonal(Q_ma);
            stan::math::initialize(theta_seasonal, DUMMY_VAR__);
            stan::math::fill(theta_seasonal, DUMMY_VAR__);
            stan::math::assign(theta_seasonal,unconstrained_theta_seasonal);
            current_statement_begin__ = 3657;
            validate_non_negative_index("c", "m", m);
            Eigen::Matrix<double, Eigen::Dynamic, 1> c(m);
            stan::math::initialize(c, DUMMY_VAR__);
            stan::math::fill(c, DUMMY_VAR__);
            current_statement_begin__ = 3658;
            validate_non_negative_index("T", "m", m);
            validate_non_negative_index("T", "m", m);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> T(m, m);
            stan::math::initialize(T, DUMMY_VAR__);
            stan::math::fill(T, DUMMY_VAR__);
            current_statement_begin__ = 3659;
            validate_non_negative_index("R", "m", m);
            validate_non_negative_index("R", "1", 1);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> R(m, 1);
            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R, DUMMY_VAR__);
            current_statement_begin__ = 3660;
            validate_non_negative_index("Q", "1", 1);
            validate_non_negative_index("Q", "1", 1);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> Q(1, 1);
            stan::math::initialize(Q, DUMMY_VAR__);
            stan::math::fill(Q, DUMMY_VAR__);
            current_statement_begin__ = 3661;
            validate_non_negative_index("a1", "m", m);
            Eigen::Matrix<double, Eigen::Dynamic, 1> a1(m);
            stan::math::initialize(a1, DUMMY_VAR__);
            stan::math::fill(a1, DUMMY_VAR__);
            current_statement_begin__ = 3662;
            validate_non_negative_index("P1", "m", m);
            validate_non_negative_index("P1", "m", m);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
            stan::math::initialize(P1, DUMMY_VAR__);
            stan::math::fill(P1, DUMMY_VAR__);
            // do transformed parameters statements
            current_statement_begin__ = 3664;
            if (as_bool(stationary)) {
                current_statement_begin__ = 3665;
                stan::math::assign(phi, constrain_stationary(unconstrained_phi, pstream__));
                current_statement_begin__ = 3666;
                stan::math::assign(phi_seasonal, constrain_stationary(unconstrained_phi_seasonal, pstream__));
            } else {
                current_statement_begin__ = 3668;
                stan::math::assign(phi, unconstrained_phi);
                current_statement_begin__ = 3669;
                stan::math::assign(phi_seasonal, unconstrained_phi_seasonal);
            }
            current_statement_begin__ = 3671;
            if (pstream__) {
                stan_print(pstream__,"modified function");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3672;
            if (pstream__) {
                stan_print(pstream__,"Stationary = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3673;
            if (pstream__) {
                stan_print(pstream__,stationary);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3674;
            if (pstream__) {
                stan_print(pstream__,"phi = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3675;
            if (pstream__) {
                stan_print(pstream__,phi);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3676;
            if (pstream__) {
                stan_print(pstream__,"phi_seasonal = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3677;
            if (pstream__) {
                stan_print(pstream__,phi_seasonal);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3678;
            if (pstream__) {
                stan_print(pstream__,"theta = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3679;
            if (pstream__) {
                stan_print(pstream__,theta);
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3680;
            if (pstream__) {
                stan_print(pstream__,"theta_seasonal = ");
                *pstream__ << std::endl;
            }
            current_statement_begin__ = 3681;
            if (pstream__) {
                stan_print(pstream__,theta_seasonal);
                *pstream__ << std::endl;
            }
            {
            current_statement_begin__ = 3685;
            validate_non_negative_index("state_matrices", "m", m);
            validate_non_negative_index("state_matrices", "(((((1 + m) + 1) + 1) + 1) + m)", (((((1 + m) + 1) + 1) + 1) + m));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> state_matrices(m, (((((1 + m) + 1) + 1) + 1) + m));
            stan::math::initialize(state_matrices, DUMMY_VAR__);
            stan::math::fill(state_matrices, DUMMY_VAR__);
            stan::math::assign(state_matrices,sarima_build_state_matrices(p_ar, q_ma, P_ar, Q_ma, ts_frequency, include_intercept, phi_0, phi, phi_seasonal, theta, theta_seasonal, var_zeta, pstream__));
            current_statement_begin__ = 3690;
            stan::math::assign(c, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3693;
            stan::math::assign(T, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max((1 + 1), (1 + m)), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3694;
            stan::math::assign(R, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max(((1 + m) + 1), ((1 + m) + 1)), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3697;
            stan::math::assign(Q, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_min_max(1, 1), stan::model::cons_list(stan::model::index_min_max((((1 + m) + 1) + 1), (((1 + m) + 1) + 1)), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3700;
            stan::math::assign(a1, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_uni(((((1 + m) + 1) + 1) + 1)), stan::model::nil_index_list())), "state_matrices"));
            current_statement_begin__ = 3703;
            stan::math::assign(P1, stan::model::rvalue(state_matrices, stan::model::cons_list(stan::model::index_omni(), stan::model::cons_list(stan::model::index_min_max((((((1 + m) + 1) + 1) + 1) + 1), (((((1 + m) + 1) + 1) + 1) + m)), stan::model::nil_index_list())), "state_matrices"));
            }
            if (!include_gqs__ && !include_tparams__) return;
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            // write transformed parameters
            if (include_tparams__) {
                size_t phi_j_1_max__ = p_ar;
                for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
                    vars__.push_back(phi(j_1__));
                }
                size_t phi_seasonal_j_1_max__ = P_ar;
                for (size_t j_1__ = 0; j_1__ < phi_seasonal_j_1_max__; ++j_1__) {
                    vars__.push_back(phi_seasonal(j_1__));
                }
                size_t theta_j_1_max__ = q_ma;
                for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
                    vars__.push_back(theta(j_1__));
                }
                size_t theta_seasonal_j_1_max__ = Q_ma;
                for (size_t j_1__ = 0; j_1__ < theta_seasonal_j_1_max__; ++j_1__) {
                    vars__.push_back(theta_seasonal(j_1__));
                }
                size_t c_j_1_max__ = m;
                for (size_t j_1__ = 0; j_1__ < c_j_1_max__; ++j_1__) {
                    vars__.push_back(c(j_1__));
                }
                size_t T_j_2_max__ = m;
                size_t T_j_1_max__ = m;
                for (size_t j_2__ = 0; j_2__ < T_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < T_j_1_max__; ++j_1__) {
                        vars__.push_back(T(j_1__, j_2__));
                    }
                }
                size_t R_j_2_max__ = 1;
                size_t R_j_1_max__ = m;
                for (size_t j_2__ = 0; j_2__ < R_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < R_j_1_max__; ++j_1__) {
                        vars__.push_back(R(j_1__, j_2__));
                    }
                }
                size_t Q_j_2_max__ = 1;
                size_t Q_j_1_max__ = 1;
                for (size_t j_2__ = 0; j_2__ < Q_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < Q_j_1_max__; ++j_1__) {
                        vars__.push_back(Q(j_1__, j_2__));
                    }
                }
                size_t a1_j_1_max__ = m;
                for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
                    vars__.push_back(a1(j_1__));
                }
                size_t P1_j_2_max__ = m;
                size_t P1_j_1_max__ = m;
                for (size_t j_2__ = 0; j_2__ < P1_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < P1_j_1_max__; ++j_1__) {
                        vars__.push_back(P1(j_1__, j_2__));
                    }
                }
            }
            if (!include_gqs__) return;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }
    std::string model_name() const {
        return "model_SARIMA_model";
    }
    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        size_t phi_0_j_1_max__ = include_intercept;
        for (size_t j_1__ = 0; j_1__ < phi_0_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_0" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unconstrained_phi_j_1_max__ = p_ar;
        for (size_t j_1__ = 0; j_1__ < unconstrained_phi_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "unconstrained_phi" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unconstrained_phi_seasonal_j_1_max__ = P_ar;
        for (size_t j_1__ = 0; j_1__ < unconstrained_phi_seasonal_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "unconstrained_phi_seasonal" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unconstrained_theta_j_1_max__ = q_ma;
        for (size_t j_1__ = 0; j_1__ < unconstrained_theta_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "unconstrained_theta" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unconstrained_theta_seasonal_j_1_max__ = Q_ma;
        for (size_t j_1__ = 0; j_1__ < unconstrained_theta_seasonal_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "unconstrained_theta_seasonal" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "var_zeta";
        param_names__.push_back(param_name_stream__.str());
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
            size_t phi_j_1_max__ = p_ar;
            for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "phi" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t phi_seasonal_j_1_max__ = P_ar;
            for (size_t j_1__ = 0; j_1__ < phi_seasonal_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "phi_seasonal" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t theta_j_1_max__ = q_ma;
            for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "theta" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t theta_seasonal_j_1_max__ = Q_ma;
            for (size_t j_1__ = 0; j_1__ < theta_seasonal_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "theta_seasonal" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t c_j_1_max__ = m;
            for (size_t j_1__ = 0; j_1__ < c_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "c" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t T_j_2_max__ = m;
            size_t T_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < T_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < T_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "T" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t R_j_2_max__ = 1;
            size_t R_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < R_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < R_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "R" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t Q_j_2_max__ = 1;
            size_t Q_j_1_max__ = 1;
            for (size_t j_2__ = 0; j_2__ < Q_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < Q_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "Q" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t a1_j_1_max__ = m;
            for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "a1" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t P1_j_2_max__ = m;
            size_t P1_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < P1_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < P1_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "P1" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        if (!include_gqs__) return;
    }
    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        size_t phi_0_j_1_max__ = include_intercept;
        for (size_t j_1__ = 0; j_1__ < phi_0_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi_0" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unconstrained_phi_j_1_max__ = p_ar;
        for (size_t j_1__ = 0; j_1__ < unconstrained_phi_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "unconstrained_phi" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unconstrained_phi_seasonal_j_1_max__ = P_ar;
        for (size_t j_1__ = 0; j_1__ < unconstrained_phi_seasonal_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "unconstrained_phi_seasonal" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unconstrained_theta_j_1_max__ = q_ma;
        for (size_t j_1__ = 0; j_1__ < unconstrained_theta_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "unconstrained_theta" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t unconstrained_theta_seasonal_j_1_max__ = Q_ma;
        for (size_t j_1__ = 0; j_1__ < unconstrained_theta_seasonal_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "unconstrained_theta_seasonal" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "var_zeta";
        param_names__.push_back(param_name_stream__.str());
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
            size_t phi_j_1_max__ = p_ar;
            for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "phi" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t phi_seasonal_j_1_max__ = P_ar;
            for (size_t j_1__ = 0; j_1__ < phi_seasonal_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "phi_seasonal" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t theta_j_1_max__ = q_ma;
            for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "theta" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t theta_seasonal_j_1_max__ = Q_ma;
            for (size_t j_1__ = 0; j_1__ < theta_seasonal_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "theta_seasonal" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t c_j_1_max__ = m;
            for (size_t j_1__ = 0; j_1__ < c_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "c" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t T_j_2_max__ = m;
            size_t T_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < T_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < T_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "T" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t R_j_2_max__ = 1;
            size_t R_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < R_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < R_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "R" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t Q_j_2_max__ = 1;
            size_t Q_j_1_max__ = 1;
            for (size_t j_2__ = 0; j_2__ < Q_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < Q_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "Q" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t a1_j_1_max__ = m;
            for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "a1" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t P1_j_2_max__ = m;
            size_t P1_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < P1_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < P1_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "P1" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        if (!include_gqs__) return;
    }
}; // model
}  // namespace
typedef model_SARIMA_model_namespace::model_SARIMA_model stan_model;
#ifndef USING_R
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
#endif
#endif
