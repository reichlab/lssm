// Generated by rstantools.  Do not edit by hand.

/*
    lssm is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    lssm is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with lssm.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.21.0
#include <stan/model/model_header.hpp>
namespace model_SARIMA_predict_namespace {
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;
static int current_statement_begin__;
stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_SARIMA_predict");
    reader.add_event(0, 0, "include", "functions.stan");
    reader.add_event(0, 0, "start", "functions.stan");
    reader.add_event(3129, 3129, "end", "functions.stan");
    reader.add_event(3129, 1, "restart", "model_SARIMA_predict");
    reader.add_event(3304, 174, "end", "model_SARIMA_predict");
    return reader;
}
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_symmetric_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 12;
        return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(0.5, add(x, transpose(x))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_symmetric_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_symmetric_matrix(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_matrix_colwise(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 30;
        validate_non_negative_index("res", "m", m);
        validate_non_negative_index("res", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> res(m, n);
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 31;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 32;
        stan::math::assign(k, 1);
        current_statement_begin__ = 34;
        for (int j = 1; j <= n; ++j) {
            current_statement_begin__ = 36;
            for (int i = 1; i <= m; ++i) {
                current_statement_begin__ = 37;
                stan::model::assign(res, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            get_base1(v, k, "v", 1), 
                            "assigning variable res");
                current_statement_begin__ = 38;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 41;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_matrix_colwise_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) const {
        return to_matrix_colwise(v, m, n, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
matrix_pow(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__);
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
matrix_pow(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 60;
        local_scalar_t__ nn(DUMMY_VAR__);
        (void) nn;  // dummy to suppress unused var warning
        stan::math::initialize(nn, DUMMY_VAR__);
        stan::math::fill(nn, DUMMY_VAR__);
        current_statement_begin__ = 61;
        stan::math::assign(nn, stan::math::floor(n));
        current_statement_begin__ = 62;
        if (as_bool(logical_eq(nn, 0))) {
            current_statement_begin__ = 63;
            return stan::math::promote_scalar<fun_return_scalar_t__>(diag_matrix(rep_vector(1., rows(A))));
        } else if (as_bool(logical_eq(nn, 1))) {
            current_statement_begin__ = 65;
            return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        } else if (as_bool(logical_gt(nn, 1))) {
            current_statement_begin__ = 68;
            if (as_bool(logical_gt(fmod(nn, 2.), 0))) {
                current_statement_begin__ = 70;
                return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(A, matrix_pow(A, (nn - 1), pstream__)));
            } else {
                current_statement_begin__ = 73;
                return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(matrix_pow(A, (nn / 2), pstream__), matrix_pow(A, (nn / 2), pstream__)));
            }
        } else {
            current_statement_begin__ = 77;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Only non-negative values of n are allowed";
            throw std::domain_error(errmsg_stream__.str());
            current_statement_begin__ = 78;
            return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct matrix_pow_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__) const {
        return matrix_pow(A, n, pstream__);
    }
};
int
symmat_size(const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 113;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 116;
        stan::math::assign(sz, 0);
        current_statement_begin__ = 117;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 118;
            stan::math::assign(sz, (sz + i));
        }
        current_statement_begin__ = 120;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct symmat_size_functor__ {
            int
    operator()(const int& n, std::ostream* pstream__) const {
        return symmat_size(n, pstream__);
    }
};
int
find_symmat_dim(const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 140;
        int i(0);
        (void) i;  // dummy to suppress unused var warning
        stan::math::fill(i, std::numeric_limits<int>::min());
        current_statement_begin__ = 141;
        int remainder(0);
        (void) remainder;  // dummy to suppress unused var warning
        stan::math::fill(remainder, std::numeric_limits<int>::min());
        current_statement_begin__ = 142;
        stan::math::assign(remainder, n);
        current_statement_begin__ = 143;
        stan::math::assign(i, 0);
        current_statement_begin__ = 144;
        while (as_bool(logical_gt(remainder, 0))) {
            current_statement_begin__ = 145;
            stan::math::assign(i, (i + 1));
            current_statement_begin__ = 146;
            stan::math::assign(remainder, (remainder - i));
        }
        current_statement_begin__ = 148;
        return stan::math::promote_scalar<fun_return_scalar_t__>(i);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct find_symmat_dim_functor__ {
            int
    operator()(const int& n, std::ostream* pstream__) const {
        return find_symmat_dim(n, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
vector_to_symmat(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 165;
        validate_non_negative_index("m", "n", n);
        validate_non_negative_index("m", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> m(n, n);
        stan::math::initialize(m, DUMMY_VAR__);
        stan::math::fill(m, DUMMY_VAR__);
        current_statement_begin__ = 166;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 167;
        stan::math::assign(k, 1);
        current_statement_begin__ = 169;
        for (int j = 1; j <= n; ++j) {
            current_statement_begin__ = 171;
            for (int i = j; i <= n; ++i) {
                current_statement_begin__ = 172;
                stan::model::assign(m, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            get_base1(x, k, "x", 1), 
                            "assigning variable m");
                current_statement_begin__ = 173;
                if (as_bool(logical_neq(i, j))) {
                    current_statement_begin__ = 174;
                    stan::model::assign(m, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                get_base1(m, i, j, "m", 1), 
                                "assigning variable m");
                }
                current_statement_begin__ = 176;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 179;
        return stan::math::promote_scalar<fun_return_scalar_t__>(m);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct vector_to_symmat_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& n, std::ostream* pstream__) const {
        return vector_to_symmat(x, n, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
symmat_to_vector(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 199;
        validate_non_negative_index("v", "symmat_size(std::min(rows(x), cols(x)), pstream__)", symmat_size(std::min(rows(x), cols(x)), pstream__));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(symmat_size(std::min(rows(x), cols(x)), pstream__));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 200;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 201;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 202;
        stan::math::assign(k, 1);
        current_statement_begin__ = 203;
        stan::math::assign(m, std::min(rows(x), cols(x)));
        current_statement_begin__ = 206;
        for (int j = 1; j <= m; ++j) {
            current_statement_begin__ = 207;
            for (int i = j; i <= m; ++i) {
                current_statement_begin__ = 208;
                stan::model::assign(v, 
                            stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                            get_base1(x, i, j, "x", 1), 
                            "assigning variable v");
                current_statement_begin__ = 209;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 212;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct symmat_to_vector_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return symmat_to_vector(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_lower_triangular_matrix(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 236;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 237;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 238;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 239;
                if (as_bool(logical_gt(i, j))) {
                    current_statement_begin__ = 240;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                x, 
                                "assigning variable A");
                } else if (as_bool(logical_eq(i, j))) {
                    current_statement_begin__ = 242;
                    if (as_bool(diag)) {
                        current_statement_begin__ = 243;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    x, 
                                    "assigning variable A");
                    } else {
                        current_statement_begin__ = 245;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    0., 
                                    "assigning variable A");
                    }
                } else {
                    current_statement_begin__ = 248;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                0., 
                                "assigning variable A");
                }
            }
        }
        current_statement_begin__ = 252;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_lower_triangular_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) const {
        return rep_lower_triangular_matrix(x, m, n, diag, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_upper_triangular_matrix(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 276;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 277;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 278;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 280;
                if (as_bool(logical_lt(i, j))) {
                    current_statement_begin__ = 281;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                x, 
                                "assigning variable A");
                } else if (as_bool(logical_eq(i, j))) {
                    current_statement_begin__ = 283;
                    if (as_bool(diag)) {
                        current_statement_begin__ = 284;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    x, 
                                    "assigning variable A");
                    } else {
                        current_statement_begin__ = 286;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    0., 
                                    "assigning variable A");
                    }
                } else {
                    current_statement_begin__ = 289;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                0., 
                                "assigning variable A");
                }
            }
        }
        current_statement_begin__ = 293;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_upper_triangular_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) const {
        return rep_upper_triangular_matrix(x, m, n, diag, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_diagonal_matrix(const T0__& x,
                        const int& m,
                        const int& n,
                        const int& k, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 318;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 319;
        int mn(0);
        (void) mn;  // dummy to suppress unused var warning
        stan::math::fill(mn, std::numeric_limits<int>::min());
        current_statement_begin__ = 320;
        stan::math::assign(A, rep_matrix(0., m, n));
        current_statement_begin__ = 321;
        stan::math::assign(mn, std::min(m, n));
        current_statement_begin__ = 322;
        if (as_bool(logical_gte(k, 0))) {
            current_statement_begin__ = 323;
            for (int i = 1; i <= std::min(m, (n - k)); ++i) {
                current_statement_begin__ = 324;
                stan::model::assign(A, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni((i + k)), stan::model::nil_index_list())), 
                            x, 
                            "assigning variable A");
            }
        } else {
            current_statement_begin__ = 327;
            for (int i = 1; i <= std::min((m + k), n); ++i) {
                current_statement_begin__ = 328;
                stan::model::assign(A, 
                            stan::model::cons_list(stan::model::index_uni((i - k)), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            x, 
                            "assigning variable A");
            }
        }
        current_statement_begin__ = 331;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_diagonal_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                        const int& m,
                        const int& n,
                        const int& k, std::ostream* pstream__) const {
        return rep_diagonal_matrix(x, m, n, k, pstream__);
    }
};
template <typename T0__, typename T5__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T5__>::type, Eigen::Dynamic, Eigen::Dynamic>
fill_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x,
                const int& m,
                const int& n,
                const std::vector<int>& i,
                const std::vector<int>& j,
                const T5__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T5__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 368;
        validate_non_negative_index("ret", "m", m);
        validate_non_negative_index("ret", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ret(m, n);
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 369;
        stan::math::assign(ret, rep_matrix(a, m, n));
        current_statement_begin__ = 370;
        stan::model::assign(ret, 
                    stan::model::cons_list(stan::model::index_multi(i), stan::model::cons_list(stan::model::index_multi(j), stan::model::nil_index_list())), 
                    x, 
                    "assigning variable ret");
        current_statement_begin__ = 371;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct fill_matrix_functor__ {
    template <typename T0__, typename T5__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T5__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x,
                const int& m,
                const int& n,
                const std::vector<int>& i,
                const std::vector<int>& j,
                const T5__& a, std::ostream* pstream__) const {
        return fill_matrix(x, m, n, i, j, a, pstream__);
    }
};
template <typename T0__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T3__>::type, Eigen::Dynamic, 1>
fill_vector(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                const int& n,
                const std::vector<int>& i,
                const T3__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 402;
        validate_non_negative_index("ret", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ret(n);
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 403;
        stan::math::assign(ret, rep_vector(a, n));
        current_statement_begin__ = 404;
        stan::model::assign(ret, 
                    stan::model::cons_list(stan::model::index_multi(i), stan::model::nil_index_list()), 
                    x, 
                    "assigning variable ret");
        current_statement_begin__ = 405;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct fill_vector_functor__ {
    template <typename T0__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                const int& n,
                const std::vector<int>& i,
                const T3__& a, std::ostream* pstream__) const {
        return fill_vector(x, n, i, a, pstream__);
    }
};
int
int_sum_true(const std::vector<int>& x, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 424;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 425;
        stan::math::assign(n, 0);
        current_statement_begin__ = 426;
        for (int i = 1; i <= num_elements(x); ++i) {
            current_statement_begin__ = 427;
            if (as_bool(int_step(get_base1(x, i, "x", 1)))) {
                current_statement_begin__ = 428;
                stan::math::assign(n, (n + 1));
            }
        }
        current_statement_begin__ = 431;
        return stan::math::promote_scalar<fun_return_scalar_t__>(n);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct int_sum_true_functor__ {
            int
    operator()(const std::vector<int>& x, std::ostream* pstream__) const {
        return int_sum_true(x, pstream__);
    }
};
int
int_sum_false(const std::vector<int>& x, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 450;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 451;
        stan::math::assign(n, 0);
        current_statement_begin__ = 452;
        for (int i = 1; i <= num_elements(x); ++i) {
            current_statement_begin__ = 453;
            if (as_bool(logical_negation(int_step(get_base1(x, i, "x", 1))))) {
                current_statement_begin__ = 454;
                stan::math::assign(n, (n + 1));
            }
        }
        current_statement_begin__ = 457;
        return stan::math::promote_scalar<fun_return_scalar_t__>(n);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct int_sum_false_functor__ {
            int
    operator()(const std::vector<int>& x, std::ostream* pstream__) const {
        return int_sum_false(x, pstream__);
    }
};
std::vector<int>
mask_indexes(const std::vector<int>& x,
                 const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 483;
        validate_non_negative_index("idx", "n", n);
        std::vector<int  > idx(n, int(0));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 484;
        int j(0);
        (void) j;  // dummy to suppress unused var warning
        stan::math::fill(j, std::numeric_limits<int>::min());
        current_statement_begin__ = 485;
        stan::math::assign(j, 1);
        current_statement_begin__ = 486;
        if (as_bool(logical_gt(n, 0))) {
            current_statement_begin__ = 487;
            for (int i = 1; i <= num_elements(x); ++i) {
                current_statement_begin__ = 488;
                if (as_bool((primitive_value(logical_negation(int_step(get_base1(x, i, "x", 1)))) && primitive_value(logical_lte(j, n))))) {
                    current_statement_begin__ = 489;
                    stan::model::assign(idx, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list()), 
                                i, 
                                "assigning variable idx");
                    current_statement_begin__ = 490;
                    stan::math::assign(j, (j + 1));
                }
            }
        }
        current_statement_begin__ = 494;
        return stan::math::promote_scalar<fun_return_scalar_t__>(idx);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct mask_indexes_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& x,
                 const int& n, std::ostream* pstream__) const {
        return mask_indexes(x, n, pstream__);
    }
};
std::vector<int>
select_indexes(const std::vector<int>& x,
                   const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 520;
        validate_non_negative_index("idx", "n", n);
        std::vector<int  > idx(n, int(0));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 521;
        int j(0);
        (void) j;  // dummy to suppress unused var warning
        stan::math::fill(j, std::numeric_limits<int>::min());
        current_statement_begin__ = 522;
        stan::math::assign(j, 1);
        current_statement_begin__ = 523;
        if (as_bool(logical_gt(n, 0))) {
            current_statement_begin__ = 524;
            for (int i = 1; i <= num_elements(x); ++i) {
                current_statement_begin__ = 525;
                if (as_bool((primitive_value(int_step(get_base1(x, i, "x", 1))) && primitive_value(logical_lte(j, n))))) {
                    current_statement_begin__ = 526;
                    stan::model::assign(idx, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list()), 
                                i, 
                                "assigning variable idx");
                    current_statement_begin__ = 527;
                    stan::math::assign(j, (j + 1));
                }
            }
        }
        current_statement_begin__ = 531;
        return stan::math::promote_scalar<fun_return_scalar_t__>(idx);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct select_indexes_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& x,
                   const int& n, std::ostream* pstream__) const {
        return select_indexes(x, n, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
normal2_rng(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 553;
        local_scalar_t__ y(DUMMY_VAR__);
        (void) y;  // dummy to suppress unused var warning
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 554;
        if (as_bool(logical_lte(sigma, 0))) {
            current_statement_begin__ = 555;
            stan::math::assign(y, mu);
        } else {
            current_statement_begin__ = 557;
            stan::math::assign(y, normal_rng(mu, sigma, base_rng__));
        }
        current_statement_begin__ = 559;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct normal2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return normal2_rng(mu, sigma, base_rng__, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
cholesky_decompose2(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 578;
        validate_non_negative_index("L", "rows(A)", rows(A));
        validate_non_negative_index("L", "cols(A)", cols(A));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> L(rows(A), cols(A));
        stan::math::initialize(L, DUMMY_VAR__);
        stan::math::fill(L, DUMMY_VAR__);
        current_statement_begin__ = 579;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 580;
        validate_non_negative_index("nonzero", "rows(A)", rows(A));
        std::vector<int  > nonzero(rows(A), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 581;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 582;
        stan::math::assign(n, rows(A));
        current_statement_begin__ = 583;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 584;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(A, i, i, "A", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 586;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 587;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 588;
            stan::math::assign(L, cholesky_decompose(A));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 590;
            stan::math::assign(L, rep_matrix(0.0, n, n));
        } else {
            {
            current_statement_begin__ = 592;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 593;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 594;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 595;
            stan::math::assign(L, rep_matrix(0.0, n, n));
            current_statement_begin__ = 596;
            stan::model::assign(L, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), 
                        cholesky_decompose(stan::model::rvalue(A, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "A")), 
                        "assigning variable L");
            }
        }
        current_statement_begin__ = 598;
        return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct cholesky_decompose2_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A, std::ostream* pstream__) const {
        return cholesky_decompose2(A, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
multi_normal2_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 622;
        validate_non_negative_index("y", "num_elements(mu)", num_elements(mu));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(num_elements(mu));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 623;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 624;
        validate_non_negative_index("nonzero", "num_elements(mu)", num_elements(mu));
        std::vector<int  > nonzero(num_elements(mu), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 625;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 626;
        stan::math::assign(n, num_elements(mu));
        current_statement_begin__ = 627;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 628;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(Sigma, i, i, "Sigma", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 630;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 631;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 632;
            stan::math::assign(y, multi_normal_rng(mu, Sigma, base_rng__));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 634;
            stan::math::assign(y, mu);
        } else {
            {
            current_statement_begin__ = 636;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 637;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 638;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 639;
            stan::math::assign(eps, rep_vector(0.0, n));
            current_statement_begin__ = 640;
            stan::model::assign(eps, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                        multi_normal_rng(rep_vector(0.0, num_nonzero), stan::model::rvalue(Sigma, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "Sigma"), base_rng__), 
                        "assigning variable eps");
            current_statement_begin__ = 641;
            stan::math::assign(y, add(mu, eps));
            }
        }
        current_statement_begin__ = 643;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct multi_normal2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return multi_normal2_rng(mu, Sigma, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
multi_normal_cholesky2_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& L, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 666;
        validate_non_negative_index("y", "num_elements(mu)", num_elements(mu));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(num_elements(mu));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 667;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 668;
        validate_non_negative_index("nonzero", "num_elements(mu)", num_elements(mu));
        std::vector<int  > nonzero(num_elements(mu), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 669;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 670;
        stan::math::assign(n, num_elements(mu));
        current_statement_begin__ = 671;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 672;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(L, i, i, "L", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 674;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 675;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 676;
            stan::math::assign(y, multi_normal_cholesky_rng(mu, L, base_rng__));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 678;
            stan::math::assign(y, mu);
        } else {
            {
            current_statement_begin__ = 680;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 681;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 682;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 683;
            stan::math::assign(eps, rep_vector(0.0, n));
            current_statement_begin__ = 684;
            stan::model::assign(eps, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                        multi_normal_cholesky_rng(rep_vector(0.0, num_nonzero), stan::model::rvalue(L, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "L"), base_rng__), 
                        "assigning variable eps");
            current_statement_begin__ = 686;
            stan::math::assign(y, add(mu, eps));
            }
        }
        current_statement_begin__ = 688;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct multi_normal_cholesky2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& L, RNG& base_rng__, std::ostream* pstream__) const {
        return multi_normal_cholesky2_rng(mu, L, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, 1>
ssm_update_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& c,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& v,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 726;
        validate_non_negative_index("a_new", "num_elements(a)", num_elements(a));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_new(num_elements(a));
        stan::math::initialize(a_new, DUMMY_VAR__);
        stan::math::fill(a_new, DUMMY_VAR__);
        current_statement_begin__ = 727;
        stan::math::assign(a_new, add(add(multiply(T, a), multiply(K, v)), c));
        current_statement_begin__ = 728;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_a_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& c,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& v,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_a(a, c, T, v, K, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_P(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& RQR,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 759;
        validate_non_negative_index("P_new", "rows(P)", rows(P));
        validate_non_negative_index("P_new", "cols(P)", cols(P));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_new(rows(P), cols(P));
        stan::math::initialize(P_new, DUMMY_VAR__);
        stan::math::fill(P_new, DUMMY_VAR__);
        current_statement_begin__ = 760;
        stan::math::assign(P_new, to_symmetric_matrix(add(multiply(multiply(T, P), transpose(subtract(T, multiply(K, Z)))), RQR), pstream__));
        current_statement_begin__ = 761;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_P_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& RQR,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_P(P, Z, T, RQR, K, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
ssm_update_v(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 790;
        validate_non_negative_index("v", "num_elements(y)", num_elements(y));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(num_elements(y));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 791;
        stan::math::assign(v, subtract(subtract(y, multiply(Z, a)), d));
        current_statement_begin__ = 792;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_v_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z, std::ostream* pstream__) const {
        return ssm_update_v(y, a, d, Z, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
ssm_update_v_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const int& p_t,
                      const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 832;
        validate_non_negative_index("v", "num_elements(y)", num_elements(y));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(num_elements(y));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 833;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 834;
        stan::math::assign(p, num_elements(y));
        current_statement_begin__ = 835;
        if (as_bool(logical_lt(p_t, p))) {
            current_statement_begin__ = 836;
            stan::math::assign(v, rep_vector(0., p));
            current_statement_begin__ = 837;
            if (as_bool(logical_gt(p_t, 0))) {
                {
                current_statement_begin__ = 838;
                validate_non_negative_index("idx", "p_t", p_t);
                std::vector<int  > idx(p_t, int(0));
                stan::math::fill(idx, std::numeric_limits<int>::min());
                current_statement_begin__ = 839;
                validate_non_negative_index("y_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y_star(p_t);
                stan::math::initialize(y_star, DUMMY_VAR__);
                stan::math::fill(y_star, DUMMY_VAR__);
                current_statement_begin__ = 840;
                validate_non_negative_index("d_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_star(p_t);
                stan::math::initialize(d_star, DUMMY_VAR__);
                stan::math::fill(d_star, DUMMY_VAR__);
                current_statement_begin__ = 841;
                validate_non_negative_index("Z_star", "p_t", p_t);
                validate_non_negative_index("Z_star", "cols(Z)", cols(Z));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_star(p_t, cols(Z));
                stan::math::initialize(Z_star, DUMMY_VAR__);
                stan::math::fill(Z_star, DUMMY_VAR__);
                current_statement_begin__ = 842;
                stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
                current_statement_begin__ = 843;
                stan::math::assign(y_star, stan::model::rvalue(y, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "y"));
                current_statement_begin__ = 844;
                stan::math::assign(d_star, stan::model::rvalue(d, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "d"));
                current_statement_begin__ = 845;
                stan::math::assign(Z_star, stan::model::rvalue(Z, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "Z"));
                current_statement_begin__ = 846;
                stan::model::assign(v, 
                            stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                            ssm_update_v(y_star, a, d_star, Z_star, pstream__), 
                            "assigning variable v");
                }
            }
        } else {
            current_statement_begin__ = 849;
            stan::math::assign(v, ssm_update_v(y, a, d, Z, pstream__));
        }
        current_statement_begin__ = 851;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_v_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const int& p_t,
                      const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_v_miss(y, a, d, Z, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_F(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 878;
        validate_non_negative_index("F", "rows(H)", rows(H));
        validate_non_negative_index("F", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> F(rows(H), cols(H));
        stan::math::initialize(F, DUMMY_VAR__);
        stan::math::fill(F, DUMMY_VAR__);
        current_statement_begin__ = 879;
        stan::math::assign(F, to_symmetric_matrix(add(quad_form(P, transpose(Z)), H), pstream__));
        current_statement_begin__ = 880;
        return stan::math::promote_scalar<fun_return_scalar_t__>(F);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_F_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_F(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                    const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                    const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 904;
        validate_non_negative_index("Finv", "rows(H)", rows(H));
        validate_non_negative_index("Finv", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(rows(H), cols(H));
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 906;
        stan::math::assign(Finv, inverse_spd(to_symmetric_matrix(add(quad_form(P, transpose(Z)), H), pstream__)));
        current_statement_begin__ = 908;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_Finv_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                    const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                    const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_Finv(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_Finv_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                         const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                         const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H,
                         const int& p_t,
                         const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 941;
        validate_non_negative_index("Finv", "rows(H)", rows(H));
        validate_non_negative_index("Finv", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(rows(H), cols(H));
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 942;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 943;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 944;
        stan::math::assign(p, rows(H));
        current_statement_begin__ = 945;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 946;
        if (as_bool(logical_lt(p_t, p))) {
            current_statement_begin__ = 947;
            stan::math::assign(Finv, rep_matrix(0., p, p));
            current_statement_begin__ = 948;
            if (as_bool(logical_gt(p_t, 0))) {
                {
                current_statement_begin__ = 949;
                validate_non_negative_index("Z_star", "p_t", p_t);
                validate_non_negative_index("Z_star", "m", m);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_star(p_t, m);
                stan::math::initialize(Z_star, DUMMY_VAR__);
                stan::math::fill(Z_star, DUMMY_VAR__);
                current_statement_begin__ = 950;
                validate_non_negative_index("H_star", "p_t", p_t);
                validate_non_negative_index("H_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_star(p_t, p_t);
                stan::math::initialize(H_star, DUMMY_VAR__);
                stan::math::fill(H_star, DUMMY_VAR__);
                current_statement_begin__ = 951;
                validate_non_negative_index("idx", "p_t", p_t);
                std::vector<int  > idx(p_t, int(0));
                stan::math::fill(idx, std::numeric_limits<int>::min());
                current_statement_begin__ = 952;
                stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
                current_statement_begin__ = 953;
                stan::math::assign(Z_star, stan::model::rvalue(Z, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "Z"));
                current_statement_begin__ = 954;
                stan::math::assign(H_star, stan::model::rvalue(H, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "H"));
                current_statement_begin__ = 955;
                stan::model::assign(Finv, 
                            stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), 
                            ssm_update_Finv(P, Z_star, H_star, pstream__), 
                            "assigning variable Finv");
                }
            }
        } else {
            current_statement_begin__ = 958;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
        }
        current_statement_begin__ = 960;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_Finv_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                         const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                         const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H,
                         const int& p_t,
                         const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_Finv_miss(P, Z, H, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_K(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 989;
        validate_non_negative_index("K", "cols(Z)", cols(Z));
        validate_non_negative_index("K", "rows(Z)", rows(Z));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(cols(Z), rows(Z));
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 990;
        stan::math::assign(K, multiply(multiply(multiply(T, P), transpose(Z)), Finv));
        current_statement_begin__ = 991;
        return stan::math::promote_scalar<fun_return_scalar_t__>(K);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_K_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_update_K(P, Z, T, Finv, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_L(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1018;
        validate_non_negative_index("L", "rows(T)", rows(T));
        validate_non_negative_index("L", "cols(T)", cols(T));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> L(rows(T), cols(T));
        stan::math::initialize(L, DUMMY_VAR__);
        stan::math::fill(L, DUMMY_VAR__);
        current_statement_begin__ = 1019;
        stan::math::assign(L, subtract(T, multiply(K, Z)));
        current_statement_begin__ = 1020;
        return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_L_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_L(Z, T, K, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_update_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1046;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1047;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1048;
        stan::math::assign(p, num_elements(v));
        current_statement_begin__ = 1050;
        stan::math::assign(ll, (-(0.5) * (((p * stan::math::log((2 * stan::math::pi()))) - log_determinant(Finv)) + quad_form_sym(Finv, v))));
        current_statement_begin__ = 1055;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_loglik_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_update_loglik(v, Finv, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_update_loglik_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv,
                           const int& p_t,
                           const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1082;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1083;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1084;
        stan::math::assign(p, num_elements(v));
        current_statement_begin__ = 1085;
        if (as_bool(logical_eq(p_t, 0))) {
            current_statement_begin__ = 1086;
            stan::math::assign(ll, 0.);
        } else if (as_bool(logical_eq(p_t, p))) {
            current_statement_begin__ = 1088;
            stan::math::assign(ll, ssm_update_loglik(v, Finv, pstream__));
        } else {
            {
            current_statement_begin__ = 1090;
            validate_non_negative_index("idx", "p_t", p_t);
            std::vector<int  > idx(p_t, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 1091;
            validate_non_negative_index("Finv_star", "p_t", p_t);
            validate_non_negative_index("Finv_star", "p_t", p_t);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv_star(p_t, p_t);
            stan::math::initialize(Finv_star, DUMMY_VAR__);
            stan::math::fill(Finv_star, DUMMY_VAR__);
            current_statement_begin__ = 1092;
            validate_non_negative_index("v_star", "p_t", p_t);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v_star(p_t);
            stan::math::initialize(v_star, DUMMY_VAR__);
            stan::math::fill(v_star, DUMMY_VAR__);
            current_statement_begin__ = 1093;
            stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
            current_statement_begin__ = 1094;
            stan::math::assign(Finv_star, stan::model::rvalue(Finv, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "Finv"));
            current_statement_begin__ = 1095;
            stan::math::assign(v_star, stan::model::rvalue(v, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "v"));
            current_statement_begin__ = 1096;
            stan::math::assign(ll, ssm_update_loglik(v_star, Finv_star, pstream__));
            }
        }
        current_statement_begin__ = 1098;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_loglik_miss_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv,
                           const int& p_t,
                           const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_loglik_miss(v, Finv, p_t, y_idx, pstream__);
    }
};
std::vector<std::vector<int> >
ssm_filter_idx(const int& m,
                   const int& p, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1137;
        validate_non_negative_index("sz", "6", 6);
        validate_non_negative_index("sz", "3", 3);
        std::vector<std::vector<int  >  > sz(6, std::vector<int>(3, int(0)));
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 1139;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 1141;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    p, 
                    "assigning variable sz");
        current_statement_begin__ = 1143;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(3), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    symmat_size(p, pstream__), 
                    "assigning variable sz");
        current_statement_begin__ = 1145;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(4), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    (m * p), 
                    "assigning variable sz");
        current_statement_begin__ = 1147;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(5), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    m, 
                    "assigning variable sz");
        current_statement_begin__ = 1149;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(6), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    symmat_size(m, pstream__), 
                    "assigning variable sz");
        current_statement_begin__ = 1151;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 1152;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 1, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 1, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 1153;
        for (int i = 2; i <= 6; ++i) {
            current_statement_begin__ = 1154;
            stan::model::assign(sz, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                        (get_base1(get_base1(sz, (i - 1), "sz", 1), 3, "sz", 2) + 1), 
                        "assigning variable sz");
            current_statement_begin__ = 1155;
            stan::model::assign(sz, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                        ((get_base1(get_base1(sz, i, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, i, "sz", 1), 1, "sz", 2)) - 1), 
                        "assigning variable sz");
        }
        current_statement_begin__ = 1157;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_idx_functor__ {
            std::vector<std::vector<int> >
    operator()(const int& m,
                   const int& p, std::ostream* pstream__) const {
        return ssm_filter_idx(m, p, pstream__);
    }
};
int
ssm_filter_size(const int& m,
                    const int& p, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1177;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 1178;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1179;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1180;
        stan::math::assign(sz, get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2));
        current_statement_begin__ = 1181;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_size_functor__ {
            int
    operator()(const int& m,
                    const int& p, std::ostream* pstream__) const {
        return ssm_filter_size(m, p, pstream__);
    }
};
template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
ssm_filter_get_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1203;
        local_scalar_t__ y(DUMMY_VAR__);
        (void) y;  // dummy to suppress unused var warning
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1204;
        stan::math::assign(y, get_base1(x, 1, "x", 1));
        current_statement_begin__ = 1205;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_loglik_functor__ {
    template <typename T0__>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_loglik(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_filter_get_v(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1227;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1228;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1229;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1230;
        stan::math::assign(y, segment(x, get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 1, "idx", 2)));
        current_statement_begin__ = 1231;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_v_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_v(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1253;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(p, p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1254;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1255;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1256;
        stan::math::assign(y, vector_to_symmat(segment(x, get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 1, "idx", 2)), p, pstream__));
        current_statement_begin__ = 1257;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_Finv_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_Finv(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_K(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1279;
        validate_non_negative_index("y", "m", m);
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(m, p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1280;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1281;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1282;
        stan::math::assign(y, to_matrix_colwise(segment(x, get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 1, "idx", 2)), m, p, pstream__));
        current_statement_begin__ = 1283;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_K_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_K(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_filter_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1305;
        validate_non_negative_index("y", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(m);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1306;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1307;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1308;
        stan::math::assign(y, segment(x, get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 1, "idx", 2)));
        current_statement_begin__ = 1309;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_a_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_a(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_P(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1331;
        validate_non_negative_index("y", "m", m);
        validate_non_negative_index("y", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(m, m);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1332;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1333;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1334;
        stan::math::assign(y, vector_to_symmat(segment(x, get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 1, "idx", 2)), m, pstream__));
        current_statement_begin__ = 1335;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_P_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_P(x, m, p, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_filter(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1395;
        validate_non_negative_index("res", "ssm_filter_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), pstream__)", ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__));
        validate_non_negative_index("res", "size(y)", size(y));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > res(size(y), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__)));
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 1396;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1397;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1398;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1399;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1402;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1403;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1404;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1405;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1410;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1411;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1412;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1413;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1414;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1415;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1416;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1417;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1419;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1420;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1421;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1422;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1423;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1424;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1425;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1427;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1429;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1430;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1431;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1432;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1433;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1434;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1435;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1436;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1437;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1438;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1439;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1440;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1441;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1442;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1444;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1445;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1447;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1448;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1450;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 1451;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 1453;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 1454;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 1456;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 1457;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 1459;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 1460;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                }
                current_statement_begin__ = 1462;
                if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                    current_statement_begin__ = 1463;
                    stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                }
            }
            current_statement_begin__ = 1467;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d_t, Z_t, pstream__));
            current_statement_begin__ = 1468;
            stan::math::assign(Finv, ssm_update_Finv(P, Z_t, H_t, pstream__));
            current_statement_begin__ = 1469;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1470;
            stan::math::assign(ll, ssm_update_loglik(v, Finv, pstream__));
            current_statement_begin__ = 1472;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        ll, 
                        "assigning variable res");
            current_statement_begin__ = 1473;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        v, 
                        "assigning variable res");
            current_statement_begin__ = 1474;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(Finv, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1475;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        to_vector(K), 
                        "assigning variable res");
            current_statement_begin__ = 1476;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable res");
            current_statement_begin__ = 1477;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(P, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1479;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1480;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1481;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        }
        current_statement_begin__ = 1485;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_filter_miss(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                    const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                    const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                    const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                    const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                    const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                    const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                    const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                    const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                    const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                    const std::vector<int>& p_t,
                    const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1548;
        validate_non_negative_index("res", "ssm_filter_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), pstream__)", ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__));
        validate_non_negative_index("res", "size(y)", size(y));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > res(size(y), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__)));
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 1549;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1550;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1551;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1552;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1555;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1556;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1557;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1558;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1563;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1564;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1565;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1566;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1567;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1568;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1569;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1570;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1572;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1573;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1574;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1575;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1576;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1577;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1578;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1579;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1580;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1581;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1582;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1583;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1584;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1585;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1586;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1587;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1588;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1589;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1590;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1591;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1592;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1593;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1595;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1596;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1598;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1599;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1601;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 1602;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 1604;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 1605;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 1607;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 1608;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 1610;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 1611;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                }
                current_statement_begin__ = 1613;
                if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                    current_statement_begin__ = 1614;
                    stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                }
            }
            current_statement_begin__ = 1618;
            stan::math::assign(v, ssm_update_v_miss(get_base1(y, t, "y", 1), a, d_t, Z_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1619;
            stan::math::assign(Finv, ssm_update_Finv_miss(P, Z_t, H_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1620;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1621;
            stan::math::assign(ll, ssm_update_loglik_miss(v, Finv, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1623;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        ll, 
                        "assigning variable res");
            current_statement_begin__ = 1624;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        v, 
                        "assigning variable res");
            current_statement_begin__ = 1625;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(Finv, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1626;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        to_vector(K), 
                        "assigning variable res");
            current_statement_begin__ = 1627;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable res");
            current_statement_begin__ = 1628;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(P, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1630;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1631;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1632;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        }
        current_statement_begin__ = 1636;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                    const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                    const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                    const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                    const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                    const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                    const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                    const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                    const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                    const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                    const std::vector<int>& p_t,
                    const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) const {
        return ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1694;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1695;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1696;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1697;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1698;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1699;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1700;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1701;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1702;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1705;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1706;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1707;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1708;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1709;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1710;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1711;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1712;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1714;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1715;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1716;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1717;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1718;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1719;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1721;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1722;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1723;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1724;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1725;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1726;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1727;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1728;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1730;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1731;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1732;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1733;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1734;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1735;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1737;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1738;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1740;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1741;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1743;
                if (as_bool(logical_lt(t, n))) {
                    current_statement_begin__ = 1744;
                    if (as_bool(logical_gt(size(c), 1))) {
                        current_statement_begin__ = 1745;
                        stan::math::assign(c_t, get_base1(c, t, "c", 1));
                    }
                    current_statement_begin__ = 1747;
                    if (as_bool(logical_gt(size(T), 1))) {
                        current_statement_begin__ = 1748;
                        stan::math::assign(T_t, get_base1(T, t, "T", 1));
                    }
                    current_statement_begin__ = 1750;
                    if (as_bool(logical_gt(size(R), 1))) {
                        current_statement_begin__ = 1751;
                        stan::math::assign(R_t, get_base1(R, t, "R", 1));
                    }
                    current_statement_begin__ = 1753;
                    if (as_bool(logical_gt(size(Q), 1))) {
                        current_statement_begin__ = 1754;
                        stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    }
                    current_statement_begin__ = 1756;
                    if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                        current_statement_begin__ = 1757;
                        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                    }
                }
            }
            current_statement_begin__ = 1761;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d_t, Z_t, pstream__));
            current_statement_begin__ = 1762;
            stan::math::assign(Finv, ssm_update_Finv(P, Z_t, H_t, pstream__));
            current_statement_begin__ = 1763;
            stan::math::assign(K, ssm_update_K(P, T_t, Z_t, Finv, pstream__));
            current_statement_begin__ = 1764;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik(v, Finv, pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 1766;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1767;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1768;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        current_statement_begin__ = 1771;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 1773;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}
struct ssm_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_miss_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1812;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1813;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1814;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1815;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1816;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1817;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1818;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1819;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1820;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1823;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1824;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1825;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1826;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1827;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1828;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1829;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1830;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1832;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1833;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1834;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1835;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1836;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1837;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1839;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1840;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1841;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1842;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1843;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1844;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1845;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1846;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1848;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1849;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1850;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1851;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1852;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1853;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1855;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1856;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1858;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1859;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1861;
                if (as_bool(logical_lt(t, n))) {
                    current_statement_begin__ = 1862;
                    if (as_bool(logical_gt(size(c), 1))) {
                        current_statement_begin__ = 1863;
                        stan::math::assign(c_t, get_base1(c, t, "c", 1));
                    }
                    current_statement_begin__ = 1865;
                    if (as_bool(logical_gt(size(T), 1))) {
                        current_statement_begin__ = 1866;
                        stan::math::assign(T_t, get_base1(T, t, "T", 1));
                    }
                    current_statement_begin__ = 1868;
                    if (as_bool(logical_gt(size(R), 1))) {
                        current_statement_begin__ = 1869;
                        stan::math::assign(R_t, get_base1(R, t, "R", 1));
                    }
                    current_statement_begin__ = 1871;
                    if (as_bool(logical_gt(size(Q), 1))) {
                        current_statement_begin__ = 1872;
                        stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    }
                    current_statement_begin__ = 1874;
                    if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                        current_statement_begin__ = 1875;
                        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                    }
                }
            }
            current_statement_begin__ = 1879;
            stan::math::assign(v, ssm_update_v_miss(get_base1(y, t, "y", 1), a, d_t, Z_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1880;
            stan::math::assign(Finv, ssm_update_Finv_miss(P, Z_t, H_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1881;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1882;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik_miss(v, Finv, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 1884;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1885;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1886;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        current_statement_begin__ = 1889;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 1891;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_miss_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    return ssm_miss_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1,p_t,y_idx, pstream__);
}
struct ssm_miss_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) const {
        return ssm_miss_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
matrix_diff(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1919;
        local_scalar_t__ eps(DUMMY_VAR__);
        (void) eps;  // dummy to suppress unused var warning
        stan::math::initialize(eps, DUMMY_VAR__);
        stan::math::fill(eps, DUMMY_VAR__);
        current_statement_begin__ = 1920;
        local_scalar_t__ norm_AB(DUMMY_VAR__);
        (void) norm_AB;  // dummy to suppress unused var warning
        stan::math::initialize(norm_AB, DUMMY_VAR__);
        stan::math::fill(norm_AB, DUMMY_VAR__);
        current_statement_begin__ = 1921;
        local_scalar_t__ norm_A(DUMMY_VAR__);
        (void) norm_A;  // dummy to suppress unused var warning
        stan::math::initialize(norm_A, DUMMY_VAR__);
        stan::math::fill(norm_A, DUMMY_VAR__);
        current_statement_begin__ = 1922;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1923;
        local_scalar_t__ ab(DUMMY_VAR__);
        (void) ab;  // dummy to suppress unused var warning
        stan::math::initialize(ab, DUMMY_VAR__);
        stan::math::fill(ab, DUMMY_VAR__);
        current_statement_begin__ = 1924;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1925;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1926;
        stan::math::assign(m, rows(A));
        current_statement_begin__ = 1927;
        stan::math::assign(n, cols(A));
        current_statement_begin__ = 1928;
        stan::math::assign(eps, 0.0);
        current_statement_begin__ = 1929;
        stan::math::assign(norm_A, 0.0);
        current_statement_begin__ = 1930;
        stan::math::assign(norm_AB, 0.0);
        current_statement_begin__ = 1931;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 1932;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 1933;
                stan::math::assign(a, stan::math::fabs(get_base1(A, i, j, "A", 1)));
                current_statement_begin__ = 1934;
                stan::math::assign(ab, stan::math::fabs((get_base1(A, i, j, "A", 1) - get_base1(B, i, j, "B", 1))));
                current_statement_begin__ = 1935;
                if (as_bool(logical_gt(a, norm_A))) {
                    current_statement_begin__ = 1936;
                    stan::math::assign(norm_A, a);
                }
                current_statement_begin__ = 1938;
                if (as_bool(logical_gt(ab, norm_AB))) {
                    current_statement_begin__ = 1939;
                    stan::math::assign(norm_AB, ab);
                }
            }
        }
        current_statement_begin__ = 1943;
        stan::math::assign(eps, (norm_AB / norm_A));
        current_statement_begin__ = 1944;
        return stan::math::promote_scalar<fun_return_scalar_t__>(eps);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct matrix_diff_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return matrix_diff(A, B, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1989;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1990;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1991;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1992;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1994;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1995;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 1996;
        stan::math::assign(p, rows(Z));
        {
        current_statement_begin__ = 1998;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1999;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2000;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2001;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2002;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2003;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2004;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2007;
        int converged(0);
        (void) converged;  // dummy to suppress unused var warning
        stan::math::fill(converged, std::numeric_limits<int>::min());
        current_statement_begin__ = 2008;
        validate_non_negative_index("P_old", "m", m);
        validate_non_negative_index("P_old", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_old(m, m);
        stan::math::initialize(P_old, DUMMY_VAR__);
        stan::math::fill(P_old, DUMMY_VAR__);
        current_statement_begin__ = 2009;
        local_scalar_t__ tol(DUMMY_VAR__);
        (void) tol;  // dummy to suppress unused var warning
        stan::math::initialize(tol, DUMMY_VAR__);
        stan::math::fill(tol, DUMMY_VAR__);
        current_statement_begin__ = 2010;
        local_scalar_t__ matdiff(DUMMY_VAR__);
        (void) matdiff;  // dummy to suppress unused var warning
        stan::math::initialize(matdiff, DUMMY_VAR__);
        stan::math::fill(matdiff, DUMMY_VAR__);
        current_statement_begin__ = 2011;
        stan::math::assign(converged, 0);
        current_statement_begin__ = 2012;
        stan::math::assign(tol, 1e-7);
        current_statement_begin__ = 2014;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2015;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2016;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2017;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2018;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2019;
            if (as_bool(logical_lt(converged, 1))) {
                current_statement_begin__ = 2020;
                stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
                current_statement_begin__ = 2021;
                stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            }
            current_statement_begin__ = 2023;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik(v, Finv, pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 2025;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 2026;
                stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
                current_statement_begin__ = 2029;
                if (as_bool(logical_lt(converged, 1))) {
                    current_statement_begin__ = 2030;
                    stan::math::assign(P_old, P);
                    current_statement_begin__ = 2031;
                    stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
                    current_statement_begin__ = 2032;
                    stan::math::assign(matdiff, matrix_diff(P, P_old, pstream__));
                    current_statement_begin__ = 2033;
                    if (as_bool(logical_lt(matdiff, tol))) {
                        current_statement_begin__ = 2034;
                        stan::math::assign(converged, 1);
                    }
                }
            }
        }
        current_statement_begin__ = 2039;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 2041;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_constant_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}
struct ssm_constant_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_constant_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_predicted_cov(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                             const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                             const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2051;
        validate_non_negative_index("cov_new", "rows(H)", rows(H));
        validate_non_negative_index("cov_new", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> cov_new(rows(H), cols(H));
        stan::math::initialize(cov_new, DUMMY_VAR__);
        stan::math::fill(cov_new, DUMMY_VAR__);
        current_statement_begin__ = 2052;
        stan::math::assign(cov_new, ssm_update_F(P, Z, H, pstream__));
        current_statement_begin__ = 2053;
        return stan::math::promote_scalar<fun_return_scalar_t__>(cov_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_cov_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                             const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                             const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_predicted_cov(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
ssm_update_predicted_mean(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& d,
                              const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                              const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2061;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2062;
        validate_non_negative_index("mean_new", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> mean_new(p);
        stan::math::initialize(mean_new, DUMMY_VAR__);
        stan::math::fill(mean_new, DUMMY_VAR__);
        current_statement_begin__ = 2063;
        stan::math::assign(mean_new, add(d, multiply(Z, a)));
        current_statement_begin__ = 2064;
        return stan::math::promote_scalar<fun_return_scalar_t__>(mean_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_mean_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& d,
                              const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                              const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) const {
        return ssm_update_predicted_mean(d, Z, a, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
ssm_update_predicted_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2072;
        validate_non_negative_index("a_new", "num_elements(a)", num_elements(a));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_new(num_elements(a));
        stan::math::initialize(a_new, DUMMY_VAR__);
        stan::math::fill(a_new, DUMMY_VAR__);
        current_statement_begin__ = 2073;
        stan::math::assign(a_new, add(c, multiply(T, a)));
        current_statement_begin__ = 2074;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_a_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& c,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& a, std::ostream* pstream__) const {
        return ssm_update_predicted_a(c, T, a, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_predicted_P(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2082;
        validate_non_negative_index("P_new", "rows(P)", rows(P));
        validate_non_negative_index("P_new", "cols(P)", cols(P));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_new(rows(P), cols(P));
        stan::math::initialize(P_new, DUMMY_VAR__);
        stan::math::fill(P_new, DUMMY_VAR__);
        current_statement_begin__ = 2083;
        stan::math::assign(P_new, to_symmetric_matrix(add(quad_form_sym(P, transpose(T)), RQR), pstream__));
        current_statement_begin__ = 2084;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_predicted_P_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                           const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) const {
        return ssm_update_predicted_P(P, T, RQR, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
predict(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
            const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
            const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
            const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
            const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
            const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
            const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
            const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
            const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
            const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
            const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2123;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2124;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2125;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2127;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2128;
        validate_non_negative_index("F", "p", p);
        validate_non_negative_index("F", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> F(p, p);
        stan::math::initialize(F, DUMMY_VAR__);
        stan::math::fill(F, DUMMY_VAR__);
        current_statement_begin__ = 2129;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2130;
        validate_non_negative_index("prediction", "p", p);
        validate_non_negative_index("prediction", "(p + 1)", (p + 1));
        validate_non_negative_index("prediction", "horizon", horizon);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > prediction(horizon, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(p, (p + 1)));
        stan::math::initialize(prediction, DUMMY_VAR__);
        stan::math::fill(prediction, DUMMY_VAR__);
        {
        current_statement_begin__ = 2132;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2133;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2134;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2135;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2137;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2138;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2139;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2141;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2142;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2143;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2144;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2145;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2146;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        current_statement_begin__ = 2151;
        stan::model::assign(prediction, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                    "assigning variable prediction");
        current_statement_begin__ = 2153;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2154;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2155;
                stan::math::assign(a, ssm_update_predicted_a(c, T, a, pstream__));
                current_statement_begin__ = 2156;
                stan::math::assign(P, ssm_update_predicted_P(P, T, RQR, pstream__));
                current_statement_begin__ = 2157;
                stan::model::assign(prediction, 
                            stan::model::cons_list(stan::model::index_uni(h), stan::model::nil_index_list()), 
                            append_col(to_matrix(ssm_update_predicted_mean(d, Z, a, pstream__)), ssm_update_predicted_cov(P, Z, H, pstream__)), 
                            "assigning variable prediction");
            }
        }
        }
        current_statement_begin__ = 2162;
        return stan::math::promote_scalar<fun_return_scalar_t__>(prediction);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct predict_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
            const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
            const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
            const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
            const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
            const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
            const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
            const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
            const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
            const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
            const int& horizon, std::ostream* pstream__) const {
        return predict(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_constant_joint_predict(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2204;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2205;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2206;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2208;
        validate_non_negative_index("d_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_tilde((p * horizon));
        stan::math::initialize(d_tilde, DUMMY_VAR__);
        stan::math::fill(d_tilde, DUMMY_VAR__);
        current_statement_begin__ = 2209;
        validate_non_negative_index("a_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_star((m * horizon));
        stan::math::initialize(a_star, DUMMY_VAR__);
        stan::math::fill(a_star, DUMMY_VAR__);
        stan::math::assign(a_star,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2210;
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("H_tilde", "(p * horizon)", (p * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_tilde((p * horizon), (p * horizon));
        stan::math::initialize(H_tilde, DUMMY_VAR__);
        stan::math::fill(H_tilde, DUMMY_VAR__);
        stan::math::assign(H_tilde,rep_matrix(0, (p * horizon), (p * horizon)));
        current_statement_begin__ = 2212;
        validate_non_negative_index("c_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_tilde((m * horizon));
        stan::math::initialize(c_tilde, DUMMY_VAR__);
        stan::math::fill(c_tilde, DUMMY_VAR__);
        stan::math::assign(c_tilde,rep_vector(0, (m * horizon)));
        current_statement_begin__ = 2213;
        validate_non_negative_index("ZT_tilde", "(p * horizon)", (p * horizon));
        validate_non_negative_index("ZT_tilde", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT_tilde((p * horizon), (m * horizon));
        stan::math::initialize(ZT_tilde, DUMMY_VAR__);
        stan::math::fill(ZT_tilde, DUMMY_VAR__);
        stan::math::assign(ZT_tilde,rep_matrix(0, (p * horizon), (m * horizon)));
        current_statement_begin__ = 2215;
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        validate_non_negative_index("Q_star", "(m * horizon)", (m * horizon));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_star((m * horizon), (m * horizon));
        stan::math::initialize(Q_star, DUMMY_VAR__);
        stan::math::fill(Q_star, DUMMY_VAR__);
        stan::math::assign(Q_star,rep_matrix(0, (m * horizon), (m * horizon)));
        current_statement_begin__ = 2217;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        stan::math::assign(RQR,quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2221;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2222;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        {
        current_statement_begin__ = 2224;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2225;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2226;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2228;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2229;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2230;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2231;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2232;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2233;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2234;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2235;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        }
        {
        current_statement_begin__ = 2241;
        validate_non_negative_index("ZT", "p", p);
        validate_non_negative_index("ZT", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ZT(p, m);
        stan::math::initialize(ZT, DUMMY_VAR__);
        stan::math::fill(ZT, DUMMY_VAR__);
        stan::math::assign(ZT,Z);
        current_statement_begin__ = 2243;
        stan::model::assign(a_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list()), 
                    a, 
                    "assigning variable a_star");
        current_statement_begin__ = 2245;
        for (int h = 1; h <= horizon; ++h) {
            current_statement_begin__ = 2246;
            stan::model::assign(d_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list()), 
                        d, 
                        "assigning variable d_tilde");
            current_statement_begin__ = 2247;
            if (as_bool(logical_gt(h, 1))) {
                current_statement_begin__ = 2248;
                stan::model::assign(c_tilde, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list()), 
                            c, 
                            "assigning variable c_tilde");
                current_statement_begin__ = 2249;
                stan::math::assign(ZT, multiply(ZT, T));
            }
            current_statement_begin__ = 2252;
            stan::model::assign(H_tilde, 
                        stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * p) + 1), (h * p)), stan::model::nil_index_list())), 
                        H, 
                        "assigning variable H_tilde");
            current_statement_begin__ = 2254;
            for (int i = 1; i <= ((horizon - h) + 1); ++i) {
                current_statement_begin__ = 2255;
                stan::model::assign(ZT_tilde, 
                            stan::model::cons_list(stan::model::index_min_max(((((i + h) - 2) * p) + 1), (((i + h) - 1) * p)), stan::model::cons_list(stan::model::index_min_max((((i - 1) * m) + 1), (i * m)), stan::model::nil_index_list())), 
                            ZT, 
                            "assigning variable ZT_tilde");
            }
        }
        }
        current_statement_begin__ = 2260;
        stan::model::assign(Q_star, 
                    stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::cons_list(stan::model::index_min_max(1, m), stan::model::nil_index_list())), 
                    P, 
                    "assigning variable Q_star");
        current_statement_begin__ = 2261;
        if (as_bool(logical_gt(horizon, 1))) {
            current_statement_begin__ = 2262;
            for (int h = 2; h <= horizon; ++h) {
                current_statement_begin__ = 2263;
                stan::model::assign(Q_star, 
                            stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::cons_list(stan::model::index_min_max((((h - 1) * m) + 1), (h * m)), stan::model::nil_index_list())), 
                            RQR, 
                            "assigning variable Q_star");
            }
        }
        current_statement_begin__ = 2269;
        return stan::math::promote_scalar<fun_return_scalar_t__>(append_col(add(to_matrix(d_tilde), multiply(ZT_tilde, to_matrix(add(c_tilde, a_star)))), add(quad_form_sym(Q_star, transpose(ZT_tilde)), H_tilde)));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_constant_joint_predict_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                               const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                               const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                               const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                               const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                               const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                               const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const int& horizon, std::ostream* pstream__) const {
        return ssm_constant_joint_predict(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic, 1> >
ssm_smooth_states_mean(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                           const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                           const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, 1> >& c,
                           const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                           const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                           const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& Q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2320;
        validate_non_negative_index("alpha", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("alpha", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(alpha, DUMMY_VAR__);
        stan::math::fill(alpha, DUMMY_VAR__);
        current_statement_begin__ = 2321;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2322;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2323;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2324;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2325;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 2326;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2327;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2328;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2330;
        validate_non_negative_index("r", "m", m);
        validate_non_negative_index("r", "(n + 1)", (n + 1));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > r((n + 1), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 2331;
        validate_non_negative_index("u", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> u(p);
        stan::math::initialize(u, DUMMY_VAR__);
        stan::math::fill(u, DUMMY_VAR__);
        current_statement_begin__ = 2332;
        validate_non_negative_index("a1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a1(m);
        stan::math::initialize(a1, DUMMY_VAR__);
        stan::math::fill(a1, DUMMY_VAR__);
        current_statement_begin__ = 2333;
        validate_non_negative_index("P1", "m", m);
        validate_non_negative_index("P1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
        stan::math::initialize(P1, DUMMY_VAR__);
        stan::math::fill(P1, DUMMY_VAR__);
        current_statement_begin__ = 2335;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2336;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2337;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2339;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 2340;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 2341;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 2342;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 2343;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 2344;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2346;
        if (as_bool(logical_eq(size(c), 1))) {
            current_statement_begin__ = 2347;
            stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        }
        current_statement_begin__ = 2349;
        if (as_bool(logical_eq(size(Z), 1))) {
            current_statement_begin__ = 2350;
            stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        }
        current_statement_begin__ = 2352;
        if (as_bool(logical_eq(size(T), 1))) {
            current_statement_begin__ = 2353;
            stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        }
        current_statement_begin__ = 2355;
        if (as_bool(logical_eq(size(R), 1))) {
            current_statement_begin__ = 2356;
            stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        }
        current_statement_begin__ = 2358;
        if (as_bool(logical_eq(size(Q), 1))) {
            current_statement_begin__ = 2359;
            stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        }
        current_statement_begin__ = 2361;
        if (as_bool((primitive_value(logical_eq(size(Q), 1)) && primitive_value(logical_eq(size(R), 1))))) {
            current_statement_begin__ = 2362;
            stan::math::assign(RQR, quad_form_sym(get_base1(Q, 1, "Q", 1), transpose(get_base1(R, 1, "R", 1))));
        }
        current_statement_begin__ = 2371;
        stan::model::assign(r, 
                    stan::model::cons_list(stan::model::index_uni((n + 1)), stan::model::nil_index_list()), 
                    rep_vector(0.0, m), 
                    "assigning variable r");
        current_statement_begin__ = 2372;
        for (int s = 0; s <= (n - 1); ++s) {
            {
            current_statement_begin__ = 2373;
            int t(0);
            (void) t;  // dummy to suppress unused var warning
            stan::math::fill(t, std::numeric_limits<int>::min());
            current_statement_begin__ = 2375;
            stan::math::assign(t, (n - s));
            current_statement_begin__ = 2377;
            if (as_bool(logical_gt(size(Z), 1))) {
                current_statement_begin__ = 2378;
                stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
            }
            current_statement_begin__ = 2380;
            if (as_bool(logical_gt(size(T), 1))) {
                current_statement_begin__ = 2381;
                stan::math::assign(T_t, get_base1(T, t, "T", 1));
            }
            current_statement_begin__ = 2384;
            stan::math::assign(K, ssm_filter_get_K(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2385;
            stan::math::assign(v, ssm_filter_get_v(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2386;
            stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2388;
            stan::math::assign(u, subtract(multiply(Finv, v), multiply(transpose(K), get_base1(r, (t + 1), "r", 1))));
            current_statement_begin__ = 2390;
            stan::model::assign(r, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        add(multiply(transpose(Z_t), u), multiply(transpose(T_t), get_base1(r, (t + 1), "r", 1))), 
                        "assigning variable r");
            }
        }
        current_statement_begin__ = 2393;
        stan::math::assign(a1, ssm_filter_get_a(get_base1(filter, 1, "filter", 1), m, p, pstream__));
        current_statement_begin__ = 2394;
        stan::math::assign(P1, ssm_filter_get_P(get_base1(filter, 1, "filter", 1), m, p, pstream__));
        current_statement_begin__ = 2396;
        stan::model::assign(alpha, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    add(a1, multiply(P1, get_base1(r, 1, "r", 1))), 
                    "assigning variable alpha");
        current_statement_begin__ = 2398;
        for (int t = 1; t <= (n - 1); ++t) {
            current_statement_begin__ = 2399;
            if (as_bool(logical_gt(size(c), 1))) {
                current_statement_begin__ = 2400;
                stan::math::assign(c_t, get_base1(c, t, "c", 1));
            }
            current_statement_begin__ = 2402;
            if (as_bool(logical_gt(size(T), 1))) {
                current_statement_begin__ = 2403;
                stan::math::assign(T_t, get_base1(T, t, "T", 1));
            }
            current_statement_begin__ = 2405;
            if (as_bool(logical_gt(size(Q), 1))) {
                current_statement_begin__ = 2406;
                stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
            }
            current_statement_begin__ = 2408;
            if (as_bool(logical_gt(size(R), 1))) {
                current_statement_begin__ = 2409;
                stan::math::assign(R_t, get_base1(R, t, "R", 1));
            }
            current_statement_begin__ = 2411;
            if (as_bool((primitive_value(logical_gt(size(Q), 1)) || primitive_value(logical_gt(size(R), 1))))) {
                current_statement_begin__ = 2412;
                stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
            }
            current_statement_begin__ = 2416;
            stan::model::assign(alpha, 
                        stan::model::cons_list(stan::model::index_uni((t + 1)), stan::model::nil_index_list()), 
                        add(add(c_t, multiply(T_t, get_base1(alpha, t, "alpha", 1))), multiply(RQR, get_base1(r, (t + 1), "r", 1))), 
                        "assigning variable alpha");
        }
        }
        current_statement_begin__ = 2419;
        return stan::math::promote_scalar<fun_return_scalar_t__>(alpha);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_smooth_states_mean_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                           const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                           const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, 1> >& c,
                           const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                           const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                           const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& Q, std::ostream* pstream__) const {
        return ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__);
    }
};
std::vector<std::vector<int> >
ssm_sim_idx(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2450;
        validate_non_negative_index("sz", "2", 2);
        validate_non_negative_index("sz", "3", 3);
        std::vector<std::vector<int  >  > sz(2, std::vector<int>(3, int(0)));
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 2452;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    p, 
                    "assigning variable sz");
        current_statement_begin__ = 2454;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    m, 
                    "assigning variable sz");
        current_statement_begin__ = 2456;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 2457;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 1, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 1, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2458;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    (get_base1(get_base1(sz, (2 - 1), "sz", 1), 3, "sz", 2) + 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2459;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 2, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 2, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2460;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_idx_functor__ {
            std::vector<std::vector<int> >
    operator()(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) const {
        return ssm_sim_idx(m, p, q, pstream__);
    }
};
int
ssm_sim_size(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2483;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 2484;
        stan::math::assign(sz, get_base1(get_base1(ssm_sim_idx(m, p, q, pstream__), 2, "ssm_sim_idx(m, p, q, pstream__)", 1), 3, "ssm_sim_idx(m, p, q, pstream__)", 2));
        current_statement_begin__ = 2485;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_size_functor__ {
            int
    operator()(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) const {
        return ssm_sim_size(m, p, q, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_sim_get_y(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2508;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2509;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2510;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2511;
        stan::math::assign(y, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 1, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 1, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list()), "x"));
        current_statement_begin__ = 2512;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_get_y_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_y(x, m, p, q, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_sim_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2535;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2536;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2537;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2538;
        stan::math::assign(a, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list()), "x"));
        current_statement_begin__ = 2539;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_get_a_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_a(x, m, p, q, pstream__);
    }
};
template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_sim_rng(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2605;
        validate_non_negative_index("ret", "ssm_sim_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), get_base1(dims(Q), 2, \"dims(Q)\", 1), pstream__)", ssm_sim_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), get_base1(dims(Q), 2, "dims(Q)", 1), pstream__));
        validate_non_negative_index("ret", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > ret(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), get_base1(dims(Q), 2, "dims(Q)", 1), pstream__)));
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 2606;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2607;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2608;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2609;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2610;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2611;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2614;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 2615;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 2616;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 2617;
        validate_non_negative_index("HL", "p", p);
        validate_non_negative_index("HL", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> HL(p, p);
        stan::math::initialize(HL, DUMMY_VAR__);
        stan::math::fill(HL, DUMMY_VAR__);
        current_statement_begin__ = 2618;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 2619;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 2620;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 2621;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 2622;
        validate_non_negative_index("QL", "q", q);
        validate_non_negative_index("QL", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> QL(q, q);
        stan::math::initialize(QL, DUMMY_VAR__);
        stan::math::fill(QL, DUMMY_VAR__);
        current_statement_begin__ = 2624;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2625;
        validate_non_negative_index("eps", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(p);
        stan::math::initialize(eps, DUMMY_VAR__);
        stan::math::fill(eps, DUMMY_VAR__);
        current_statement_begin__ = 2626;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2627;
        validate_non_negative_index("eta", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eta(q);
        stan::math::initialize(eta, DUMMY_VAR__);
        stan::math::fill(eta, DUMMY_VAR__);
        current_statement_begin__ = 2629;
        validate_non_negative_index("zero_p", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_p(p);
        stan::math::initialize(zero_p, DUMMY_VAR__);
        stan::math::fill(zero_p, DUMMY_VAR__);
        current_statement_begin__ = 2630;
        validate_non_negative_index("zero_q", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_q(q);
        stan::math::initialize(zero_q, DUMMY_VAR__);
        stan::math::fill(zero_q, DUMMY_VAR__);
        current_statement_begin__ = 2631;
        validate_non_negative_index("zero_m", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_m(m);
        stan::math::initialize(zero_m, DUMMY_VAR__);
        stan::math::fill(zero_m, DUMMY_VAR__);
        current_statement_begin__ = 2632;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2634;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 2635;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 2636;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 2637;
        stan::math::assign(HL, cholesky_decompose2(H_t, pstream__));
        current_statement_begin__ = 2638;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 2639;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 2640;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 2641;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 2642;
        stan::math::assign(QL, cholesky_decompose2(Q_t, pstream__));
        current_statement_begin__ = 2644;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2645;
        stan::math::assign(zero_p, rep_vector(0.0, p));
        current_statement_begin__ = 2646;
        stan::math::assign(zero_q, rep_vector(0.0, q));
        current_statement_begin__ = 2647;
        stan::math::assign(zero_m, rep_vector(0.0, m));
        current_statement_begin__ = 2648;
        stan::math::assign(a, multi_normal2_rng(a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 2649;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2651;
            stan::model::assign(ret, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable ret");
            current_statement_begin__ = 2653;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 2654;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 2655;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 2657;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 2658;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 2660;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 2661;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                    current_statement_begin__ = 2662;
                    stan::math::assign(HL, cholesky_decompose2(H_t, pstream__));
                }
            }
            current_statement_begin__ = 2666;
            stan::math::assign(eps, multi_normal_cholesky2_rng(zero_p, HL, base_rng__, pstream__));
            current_statement_begin__ = 2667;
            stan::math::assign(y, add(add(d_t, multiply(Z_t, a)), eps));
            current_statement_begin__ = 2669;
            stan::model::assign(ret, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 1, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 1, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        y, 
                        "assigning variable ret");
            current_statement_begin__ = 2671;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 2672;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 2673;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 2675;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 2676;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 2678;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 2679;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 2681;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 2682;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    current_statement_begin__ = 2683;
                    stan::math::assign(QL, cholesky_decompose2(Q_t, pstream__));
                }
                current_statement_begin__ = 2685;
                stan::math::assign(eta, multi_normal_cholesky2_rng(zero_q, QL, base_rng__, pstream__));
                current_statement_begin__ = 2686;
                stan::math::assign(a, add(add(c_t, multiply(T_t, a)), multiply(R_t, eta)));
            }
        }
        }
        current_statement_begin__ = 2690;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_rng_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_simsmo_states_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2744;
        validate_non_negative_index("draws", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("draws", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > draws(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(draws, DUMMY_VAR__);
        stan::math::fill(draws, DUMMY_VAR__);
        current_statement_begin__ = 2745;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2746;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2747;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2748;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2749;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 2750;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2751;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2752;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2754;
        validate_non_negative_index("filter_plus", "ssm_filter_size(m, p, pstream__)", ssm_filter_size(m, p, pstream__));
        validate_non_negative_index("filter_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > filter_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(m, p, pstream__)));
        stan::math::initialize(filter_plus, DUMMY_VAR__);
        stan::math::fill(filter_plus, DUMMY_VAR__);
        current_statement_begin__ = 2755;
        validate_non_negative_index("sims", "ssm_sim_size(m, p, q, pstream__)", ssm_sim_size(m, p, q, pstream__));
        validate_non_negative_index("sims", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > sims(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(m, p, q, pstream__)));
        stan::math::initialize(sims, DUMMY_VAR__);
        stan::math::fill(sims, DUMMY_VAR__);
        current_statement_begin__ = 2756;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > y(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(p));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2757;
        validate_non_negative_index("alpha_hat_plus", "m", m);
        validate_non_negative_index("alpha_hat_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat_plus, DUMMY_VAR__);
        stan::math::fill(alpha_hat_plus, DUMMY_VAR__);
        current_statement_begin__ = 2758;
        validate_non_negative_index("alpha_hat", "m", m);
        validate_non_negative_index("alpha_hat", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat, DUMMY_VAR__);
        stan::math::fill(alpha_hat, DUMMY_VAR__);
        current_statement_begin__ = 2760;
        stan::math::assign(alpha_hat, ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 2762;
        stan::math::assign(sims, ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 2763;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2764;
            stan::model::assign(y, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ssm_sim_get_y(get_base1(sims, i, "sims", 1), m, p, q, pstream__), 
                        "assigning variable y");
        }
        current_statement_begin__ = 2767;
        stan::math::assign(filter_plus, ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__));
        current_statement_begin__ = 2769;
        stan::math::assign(alpha_hat_plus, ssm_smooth_states_mean(filter_plus, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 2770;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2771;
            stan::model::assign(draws, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        add(subtract(ssm_sim_get_a(get_base1(sims, i, "sims", 1), m, p, q, pstream__), get_base1(alpha_hat_plus, i, "alpha_hat_plus", 1)), get_base1(alpha_hat, i, "alpha_hat", 1)), 
                        "assigning variable draws");
        }
        }
        current_statement_begin__ = 2776;
        return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_simsmo_states_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_rng(filter, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_simsmo_states_miss_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const std::vector<int>& p_t,
                               const std::vector<std::vector<int> >& y_idx, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2822;
        validate_non_negative_index("draws", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("draws", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > draws(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(draws, DUMMY_VAR__);
        stan::math::fill(draws, DUMMY_VAR__);
        current_statement_begin__ = 2823;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2824;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2825;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2826;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2827;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 2828;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2829;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2830;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2832;
        validate_non_negative_index("filter_plus", "ssm_filter_size(m, p, pstream__)", ssm_filter_size(m, p, pstream__));
        validate_non_negative_index("filter_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > filter_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(m, p, pstream__)));
        stan::math::initialize(filter_plus, DUMMY_VAR__);
        stan::math::fill(filter_plus, DUMMY_VAR__);
        current_statement_begin__ = 2833;
        validate_non_negative_index("sims", "ssm_sim_size(m, p, q, pstream__)", ssm_sim_size(m, p, q, pstream__));
        validate_non_negative_index("sims", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > sims(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(m, p, q, pstream__)));
        stan::math::initialize(sims, DUMMY_VAR__);
        stan::math::fill(sims, DUMMY_VAR__);
        current_statement_begin__ = 2834;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > y(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(p));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2835;
        validate_non_negative_index("alpha_hat_plus", "m", m);
        validate_non_negative_index("alpha_hat_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat_plus, DUMMY_VAR__);
        stan::math::fill(alpha_hat_plus, DUMMY_VAR__);
        current_statement_begin__ = 2836;
        validate_non_negative_index("alpha_hat", "m", m);
        validate_non_negative_index("alpha_hat", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat, DUMMY_VAR__);
        stan::math::fill(alpha_hat, DUMMY_VAR__);
        current_statement_begin__ = 2838;
        stan::math::assign(alpha_hat, ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 2840;
        stan::math::assign(sims, ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 2841;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2842;
            stan::model::assign(y, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ssm_sim_get_y(get_base1(sims, i, "sims", 1), m, p, q, pstream__), 
                        "assigning variable y");
        }
        current_statement_begin__ = 2845;
        stan::math::assign(filter_plus, ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__));
        current_statement_begin__ = 2848;
        stan::math::assign(alpha_hat_plus, ssm_smooth_states_mean(filter_plus, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 2849;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2850;
            stan::model::assign(draws, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        add(subtract(ssm_sim_get_a(get_base1(sims, i, "sims", 1), m, p, q, pstream__), get_base1(alpha_hat_plus, i, "alpha_hat_plus", 1)), get_base1(alpha_hat, i, "alpha_hat", 1)), 
                        "assigning variable draws");
        }
        }
        current_statement_begin__ = 2855;
        return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_simsmo_states_miss_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const std::vector<int>& p_t,
                               const std::vector<std::vector<int> >& y_idx, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_miss_rng(filter, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, base_rng__, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
pacf_to_acf(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2880;
        validate_non_negative_index("x_new", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> x_new(num_elements(x));
        stan::math::initialize(x_new, DUMMY_VAR__);
        stan::math::fill(x_new, DUMMY_VAR__);
        current_statement_begin__ = 2881;
        validate_non_negative_index("work", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> work(num_elements(x));
        stan::math::initialize(work, DUMMY_VAR__);
        stan::math::fill(work, DUMMY_VAR__);
        current_statement_begin__ = 2882;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2883;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2884;
        stan::math::assign(p, num_elements(x));
        current_statement_begin__ = 2885;
        stan::math::assign(work, x);
        current_statement_begin__ = 2886;
        stan::math::assign(x_new, x);
        current_statement_begin__ = 2887;
        if (as_bool(logical_gt(p, 1))) {
            current_statement_begin__ = 2888;
            for (int j = 2; j <= p; ++j) {
                current_statement_begin__ = 2889;
                stan::math::assign(a, get_base1(x_new, j, "x_new", 1));
                current_statement_begin__ = 2890;
                for (int k = 1; k <= (j - 1); ++k) {
                    current_statement_begin__ = 2891;
                    stan::model::assign(work, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                (get_base1(work, k, "work", 1) - (a * get_base1(x_new, (j - k), "x_new", 1))), 
                                "assigning variable work");
                }
                current_statement_begin__ = 2893;
                for (int k = 1; k <= j; ++k) {
                    current_statement_begin__ = 2894;
                    stan::model::assign(x_new, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                get_base1(work, k, "work", 1), 
                                "assigning variable x_new");
                }
            }
        }
        current_statement_begin__ = 2898;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct pacf_to_acf_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return pacf_to_acf(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
constrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2938;
        validate_non_negative_index("r", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r(num_elements(x));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 2939;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2940;
        stan::math::assign(n, num_elements(x));
        current_statement_begin__ = 2942;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2943;
            stan::model::assign(r, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        stan::math::tanh(get_base1(x, i, "x", 1)), 
                        "assigning variable r");
        }
        current_statement_begin__ = 2946;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pacf_to_acf(r, pstream__));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct constrain_stationary_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return constrain_stationary(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
acf_to_pacf(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2967;
        validate_non_negative_index("x_new", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> x_new(num_elements(x));
        stan::math::initialize(x_new, DUMMY_VAR__);
        stan::math::fill(x_new, DUMMY_VAR__);
        current_statement_begin__ = 2968;
        validate_non_negative_index("work", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> work(num_elements(x));
        stan::math::initialize(work, DUMMY_VAR__);
        stan::math::fill(work, DUMMY_VAR__);
        current_statement_begin__ = 2969;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2970;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2971;
        stan::math::assign(p, num_elements(x));
        current_statement_begin__ = 2972;
        stan::math::assign(work, x);
        current_statement_begin__ = 2973;
        stan::math::assign(x_new, x);
        current_statement_begin__ = 2975;
        if (as_bool(logical_gt(p, 1))) {
            current_statement_begin__ = 2976;
            for (int i = 0; i <= (p - 2); ++i) {
                {
                current_statement_begin__ = 2977;
                int j(0);
                (void) j;  // dummy to suppress unused var warning
                stan::math::fill(j, std::numeric_limits<int>::min());
                current_statement_begin__ = 2978;
                stan::math::assign(j, (p - i));
                current_statement_begin__ = 2979;
                stan::math::assign(a, get_base1(x_new, j, "x_new", 1));
                current_statement_begin__ = 2980;
                for (int k = 1; k <= (j - 1); ++k) {
                    current_statement_begin__ = 2981;
                    stan::model::assign(work, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                ((get_base1(x_new, k, "x_new", 1) + (a * get_base1(x_new, (j - k), "x_new", 1))) / (1 - pow(a, 2))), 
                                "assigning variable work");
                }
                current_statement_begin__ = 2983;
                for (int k = 1; k <= j; ++k) {
                    current_statement_begin__ = 2984;
                    stan::model::assign(x_new, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                get_base1(work, k, "work", 1), 
                                "assigning variable x_new");
                }
                }
            }
        }
        current_statement_begin__ = 2988;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct acf_to_pacf_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return acf_to_pacf(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
unconstrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3005;
        validate_non_negative_index("y", "num_elements(x)", num_elements(x));
        validate_non_negative_index("y", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(num_elements(x), num_elements(x));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 3006;
        validate_non_negative_index("r", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r(num_elements(x));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 3007;
        validate_non_negative_index("z", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> z(num_elements(x));
        stan::math::initialize(z, DUMMY_VAR__);
        stan::math::fill(z, DUMMY_VAR__);
        current_statement_begin__ = 3008;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3009;
        stan::math::assign(n, num_elements(x));
        current_statement_begin__ = 3011;
        stan::math::assign(r, acf_to_pacf(x, pstream__));
        current_statement_begin__ = 3013;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 3014;
            stan::model::assign(z, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        stan::math::atanh(get_base1(r, i, "r", 1)), 
                        "assigning variable z");
        }
        current_statement_begin__ = 3016;
        return stan::math::promote_scalar<fun_return_scalar_t__>(z);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct unconstrain_stationary_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return unconstrain_stationary(x, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
kronecker_prod(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3043;
        validate_non_negative_index("C", "(rows(A) * rows(B))", (rows(A) * rows(B)));
        validate_non_negative_index("C", "(cols(A) * cols(B))", (cols(A) * cols(B)));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> C((rows(A) * rows(B)), (cols(A) * cols(B)));
        stan::math::initialize(C, DUMMY_VAR__);
        stan::math::fill(C, DUMMY_VAR__);
        current_statement_begin__ = 3044;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3045;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 3046;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 3047;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 3048;
        stan::math::assign(m, rows(A));
        current_statement_begin__ = 3049;
        stan::math::assign(n, cols(A));
        current_statement_begin__ = 3050;
        stan::math::assign(p, rows(B));
        current_statement_begin__ = 3051;
        stan::math::assign(q, cols(B));
        current_statement_begin__ = 3052;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 3053;
            for (int j = 1; j <= n; ++j) {
                {
                current_statement_begin__ = 3054;
                int row_start(0);
                (void) row_start;  // dummy to suppress unused var warning
                stan::math::fill(row_start, std::numeric_limits<int>::min());
                current_statement_begin__ = 3055;
                int row_end(0);
                (void) row_end;  // dummy to suppress unused var warning
                stan::math::fill(row_end, std::numeric_limits<int>::min());
                current_statement_begin__ = 3056;
                int col_start(0);
                (void) col_start;  // dummy to suppress unused var warning
                stan::math::fill(col_start, std::numeric_limits<int>::min());
                current_statement_begin__ = 3057;
                int col_end(0);
                (void) col_end;  // dummy to suppress unused var warning
                stan::math::fill(col_end, std::numeric_limits<int>::min());
                current_statement_begin__ = 3058;
                stan::math::assign(row_start, (((i - 1) * p) + 1));
                current_statement_begin__ = 3059;
                stan::math::assign(row_end, (((i - 1) * p) + p));
                current_statement_begin__ = 3060;
                stan::math::assign(col_start, (((j - 1) * q) + 1));
                current_statement_begin__ = 3061;
                stan::math::assign(col_end, (((j - 1) * q) + q));
                current_statement_begin__ = 3062;
                stan::model::assign(C, 
                            stan::model::cons_list(stan::model::index_min_max(row_start, row_end), stan::model::cons_list(stan::model::index_min_max(col_start, col_end), stan::model::nil_index_list())), 
                            multiply(get_base1(A, i, j, "A", 1), B), 
                            "assigning variable C");
                }
            }
        }
        current_statement_begin__ = 3065;
        return stan::math::promote_scalar<fun_return_scalar_t__>(C);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct kronecker_prod_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return kronecker_prod(A, B, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
stationary_cov(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& T,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 3107;
        validate_non_negative_index("P", "rows(T)", rows(T));
        validate_non_negative_index("P", "cols(T)", cols(T));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(rows(T), cols(T));
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 3108;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 3109;
        stan::math::assign(m, rows(T));
        current_statement_begin__ = 3112;
        if (as_bool(logical_eq(m, 1))) {
            current_statement_begin__ = 3113;
            stan::model::assign(P, 
                        stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        (get_base1(RQR, 1, 1, "RQR", 1) / (1.0 - pow(get_base1(T, 1, 1, "T", 1), 2))), 
                        "assigning variable P");
        } else {
            {
            current_statement_begin__ = 3115;
            validate_non_negative_index("TT", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            validate_non_negative_index("TT", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> TT((rows(T) * rows(T)), (rows(T) * rows(T)));
            stan::math::initialize(TT, DUMMY_VAR__);
            stan::math::fill(TT, DUMMY_VAR__);
            current_statement_begin__ = 3116;
            validate_non_negative_index("RQR_vec", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> RQR_vec((rows(T) * rows(T)));
            stan::math::initialize(RQR_vec, DUMMY_VAR__);
            stan::math::fill(RQR_vec, DUMMY_VAR__);
            current_statement_begin__ = 3117;
            int m2(0);
            (void) m2;  // dummy to suppress unused var warning
            stan::math::fill(m2, std::numeric_limits<int>::min());
            current_statement_begin__ = 3118;
            stan::math::assign(m2, (m * m));
            current_statement_begin__ = 3119;
            stan::math::assign(RQR_vec, to_vector(RQR));
            current_statement_begin__ = 3121;
            stan::math::assign(TT, minus(kronecker_prod(T, T, pstream__)));
            current_statement_begin__ = 3122;
            for (int i = 1; i <= m2; ++i) {
                current_statement_begin__ = 3123;
                stan::model::assign(TT, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            (1.0 + get_base1(TT, i, i, "TT", 1)), 
                            "assigning variable TT");
            }
            current_statement_begin__ = 3125;
            stan::math::assign(P, to_matrix_colwise(multiply(inverse(TT), RQR_vec), m, m, pstream__));
            }
        }
        current_statement_begin__ = 3127;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct stationary_cov_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& T,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) const {
        return stationary_cov(T, RQR, pstream__);
    }
};
#include <stan_meta_header.hpp>
class model_SARIMA_predict
  : public stan::model::model_base_crtp<model_SARIMA_predict> {
private:
        int n;
        int p;
        std::vector<vector_d> y;
        int p_ar;
        int q_ma;
        int P_ar;
        int Q_ma;
        int ts_frequency;
        int include_intercept;
        int horizon;
        int joint;
        vector_d phi_0;
        vector_d phi;
        vector_d phi_seasonal;
        vector_d theta;
        vector_d theta_seasonal;
        double var_zeta;
        int r;
        int m;
        vector_d a1;
        matrix_d Z;
        matrix_d H;
        vector_d c;
        vector_d d;
        matrix_d Q;
        matrix_d T;
        matrix_d R;
        matrix_d P1;
        vector_d dummy_phi;
        vector_d dummy_theta;
        int result_nrow;
        int result_ncol;
        int result_length;
public:
    model_SARIMA_predict(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, 0, pstream__);
    }
    model_SARIMA_predict(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, random_seed__, pstream__);
    }
    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning
        current_statement_begin__ = -1;
        static const char* function__ = "model_SARIMA_predict_namespace::model_SARIMA_predict";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        try {
            // initialize data block variables from context__
            current_statement_begin__ = 3133;
            context__.validate_dims("data initialization", "n", "int", context__.to_vec());
            n = int(0);
            vals_i__ = context__.vals_i("n");
            pos__ = 0;
            n = vals_i__[pos__++];
            check_greater_or_equal(function__, "n", n, 0);
            current_statement_begin__ = 3135;
            context__.validate_dims("data initialization", "p", "int", context__.to_vec());
            p = int(0);
            vals_i__ = context__.vals_i("p");
            pos__ = 0;
            p = vals_i__[pos__++];
            check_greater_or_equal(function__, "p", p, 0);
            current_statement_begin__ = 3137;
            validate_non_negative_index("y", "p", p);
            validate_non_negative_index("y", "n", n);
            context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(n,p));
            y = std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> >(n, Eigen::Matrix<double, Eigen::Dynamic, 1>(p));
            vals_r__ = context__.vals_r("y");
            pos__ = 0;
            size_t y_j_1_max__ = p;
            size_t y_k_0_max__ = n;
            for (size_t j_1__ = 0; j_1__ < y_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < y_k_0_max__; ++k_0__) {
                    y[k_0__](j_1__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 3139;
            context__.validate_dims("data initialization", "p_ar", "int", context__.to_vec());
            p_ar = int(0);
            vals_i__ = context__.vals_i("p_ar");
            pos__ = 0;
            p_ar = vals_i__[pos__++];
            check_greater_or_equal(function__, "p_ar", p_ar, 0);
            current_statement_begin__ = 3141;
            context__.validate_dims("data initialization", "q_ma", "int", context__.to_vec());
            q_ma = int(0);
            vals_i__ = context__.vals_i("q_ma");
            pos__ = 0;
            q_ma = vals_i__[pos__++];
            check_greater_or_equal(function__, "q_ma", q_ma, 0);
            current_statement_begin__ = 3143;
            context__.validate_dims("data initialization", "P_ar", "int", context__.to_vec());
            P_ar = int(0);
            vals_i__ = context__.vals_i("P_ar");
            pos__ = 0;
            P_ar = vals_i__[pos__++];
            check_greater_or_equal(function__, "P_ar", P_ar, 0);
            current_statement_begin__ = 3145;
            context__.validate_dims("data initialization", "Q_ma", "int", context__.to_vec());
            Q_ma = int(0);
            vals_i__ = context__.vals_i("Q_ma");
            pos__ = 0;
            Q_ma = vals_i__[pos__++];
            check_greater_or_equal(function__, "Q_ma", Q_ma, 0);
            current_statement_begin__ = 3148;
            context__.validate_dims("data initialization", "ts_frequency", "int", context__.to_vec());
            ts_frequency = int(0);
            vals_i__ = context__.vals_i("ts_frequency");
            pos__ = 0;
            ts_frequency = vals_i__[pos__++];
            check_greater_or_equal(function__, "ts_frequency", ts_frequency, 0);
            current_statement_begin__ = 3152;
            context__.validate_dims("data initialization", "include_intercept", "int", context__.to_vec());
            include_intercept = int(0);
            vals_i__ = context__.vals_i("include_intercept");
            pos__ = 0;
            include_intercept = vals_i__[pos__++];
            check_greater_or_equal(function__, "include_intercept", include_intercept, 0);
            check_less_or_equal(function__, "include_intercept", include_intercept, 1);
            current_statement_begin__ = 3155;
            context__.validate_dims("data initialization", "horizon", "int", context__.to_vec());
            horizon = int(0);
            vals_i__ = context__.vals_i("horizon");
            pos__ = 0;
            horizon = vals_i__[pos__++];
            check_greater_or_equal(function__, "horizon", horizon, 1);
            current_statement_begin__ = 3160;
            context__.validate_dims("data initialization", "joint", "int", context__.to_vec());
            joint = int(0);
            vals_i__ = context__.vals_i("joint");
            pos__ = 0;
            joint = vals_i__[pos__++];
            check_greater_or_equal(function__, "joint", joint, 0);
            check_less_or_equal(function__, "joint", joint, 1);
            current_statement_begin__ = 3163;
            validate_non_negative_index("phi_0", "include_intercept", include_intercept);
            context__.validate_dims("data initialization", "phi_0", "vector_d", context__.to_vec(include_intercept));
            phi_0 = Eigen::Matrix<double, Eigen::Dynamic, 1>(include_intercept);
            vals_r__ = context__.vals_r("phi_0");
            pos__ = 0;
            size_t phi_0_j_1_max__ = include_intercept;
            for (size_t j_1__ = 0; j_1__ < phi_0_j_1_max__; ++j_1__) {
                phi_0(j_1__) = vals_r__[pos__++];
            }
            current_statement_begin__ = 3166;
            validate_non_negative_index("phi", "p_ar", p_ar);
            context__.validate_dims("data initialization", "phi", "vector_d", context__.to_vec(p_ar));
            phi = Eigen::Matrix<double, Eigen::Dynamic, 1>(p_ar);
            vals_r__ = context__.vals_r("phi");
            pos__ = 0;
            size_t phi_j_1_max__ = p_ar;
            for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
                phi(j_1__) = vals_r__[pos__++];
            }
            current_statement_begin__ = 3168;
            validate_non_negative_index("phi_seasonal", "P_ar", P_ar);
            context__.validate_dims("data initialization", "phi_seasonal", "vector_d", context__.to_vec(P_ar));
            phi_seasonal = Eigen::Matrix<double, Eigen::Dynamic, 1>(P_ar);
            vals_r__ = context__.vals_r("phi_seasonal");
            pos__ = 0;
            size_t phi_seasonal_j_1_max__ = P_ar;
            for (size_t j_1__ = 0; j_1__ < phi_seasonal_j_1_max__; ++j_1__) {
                phi_seasonal(j_1__) = vals_r__[pos__++];
            }
            current_statement_begin__ = 3170;
            validate_non_negative_index("theta", "q_ma", q_ma);
            context__.validate_dims("data initialization", "theta", "vector_d", context__.to_vec(q_ma));
            theta = Eigen::Matrix<double, Eigen::Dynamic, 1>(q_ma);
            vals_r__ = context__.vals_r("theta");
            pos__ = 0;
            size_t theta_j_1_max__ = q_ma;
            for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
                theta(j_1__) = vals_r__[pos__++];
            }
            current_statement_begin__ = 3172;
            validate_non_negative_index("theta_seasonal", "Q_ma", Q_ma);
            context__.validate_dims("data initialization", "theta_seasonal", "vector_d", context__.to_vec(Q_ma));
            theta_seasonal = Eigen::Matrix<double, Eigen::Dynamic, 1>(Q_ma);
            vals_r__ = context__.vals_r("theta_seasonal");
            pos__ = 0;
            size_t theta_seasonal_j_1_max__ = Q_ma;
            for (size_t j_1__ = 0; j_1__ < theta_seasonal_j_1_max__; ++j_1__) {
                theta_seasonal(j_1__) = vals_r__[pos__++];
            }
            current_statement_begin__ = 3174;
            context__.validate_dims("data initialization", "var_zeta", "double", context__.to_vec());
            var_zeta = double(0);
            vals_r__ = context__.vals_r("var_zeta");
            pos__ = 0;
            var_zeta = vals_r__[pos__++];
            check_greater_or_equal(function__, "var_zeta", var_zeta, 0);
            current_statement_begin__ = 3177;
            context__.validate_dims("data initialization", "r", "int", context__.to_vec());
            r = int(0);
            vals_i__ = context__.vals_i("r");
            pos__ = 0;
            r = vals_i__[pos__++];
            check_greater_or_equal(function__, "r", r, 0);
            current_statement_begin__ = 3181;
            context__.validate_dims("data initialization", "m", "int", context__.to_vec());
            m = int(0);
            vals_i__ = context__.vals_i("m");
            pos__ = 0;
            m = vals_i__[pos__++];
            check_greater_or_equal(function__, "m", m, 0);
            current_statement_begin__ = 3184;
            validate_non_negative_index("a1", "m", m);
            context__.validate_dims("data initialization", "a1", "vector_d", context__.to_vec(m));
            a1 = Eigen::Matrix<double, Eigen::Dynamic, 1>(m);
            vals_r__ = context__.vals_r("a1");
            pos__ = 0;
            size_t a1_j_1_max__ = m;
            for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
                a1(j_1__) = vals_r__[pos__++];
            }
            // initialize transformed data variables
            current_statement_begin__ = 3189;
            validate_non_negative_index("Z", "p", p);
            validate_non_negative_index("Z", "m", m);
            Z = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(p, m);
            stan::math::fill(Z, DUMMY_VAR__);
            stan::math::assign(Z,append_col(stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<double, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).array())).array()), to_matrix(rep_row_vector(0, (m - 1)))));
            current_statement_begin__ = 3192;
            validate_non_negative_index("H", "p", p);
            validate_non_negative_index("H", "p", p);
            H = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(p, p);
            stan::math::fill(H, DUMMY_VAR__);
            stan::math::assign(H,stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<double, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<double >().add(0).array())).array()));
            current_statement_begin__ = 3195;
            validate_non_negative_index("c", "m", m);
            c = Eigen::Matrix<double, Eigen::Dynamic, 1>(m);
            stan::math::fill(c, DUMMY_VAR__);
            current_statement_begin__ = 3198;
            validate_non_negative_index("d", "p", p);
            d = Eigen::Matrix<double, Eigen::Dynamic, 1>(p);
            stan::math::fill(d, DUMMY_VAR__);
            stan::math::assign(d,rep_vector(0, p));
            current_statement_begin__ = 3203;
            validate_non_negative_index("Q", "1", 1);
            validate_non_negative_index("Q", "1", 1);
            Q = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(1, 1);
            stan::math::fill(Q, DUMMY_VAR__);
            stan::math::assign(Q,stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<double, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<double >().add(var_zeta).array())).array()));
            current_statement_begin__ = 3206;
            validate_non_negative_index("T", "m", m);
            validate_non_negative_index("T", "m", m);
            T = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(m, m);
            stan::math::fill(T, DUMMY_VAR__);
            current_statement_begin__ = 3207;
            validate_non_negative_index("R", "m", m);
            validate_non_negative_index("R", "1", 1);
            R = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(m, 1);
            stan::math::fill(R, DUMMY_VAR__);
            current_statement_begin__ = 3210;
            validate_non_negative_index("P1", "m", m);
            validate_non_negative_index("P1", "m", m);
            P1 = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(m, m);
            stan::math::fill(P1, DUMMY_VAR__);
            current_statement_begin__ = 3213;
            validate_non_negative_index("dummy_phi", "r", r);
            dummy_phi = Eigen::Matrix<double, Eigen::Dynamic, 1>(r);
            stan::math::fill(dummy_phi, DUMMY_VAR__);
            stan::math::assign(dummy_phi,rep_vector(0, r));
            current_statement_begin__ = 3216;
            validate_non_negative_index("dummy_theta", "(r - 1)", (r - 1));
            dummy_theta = Eigen::Matrix<double, Eigen::Dynamic, 1>((r - 1));
            stan::math::fill(dummy_theta, DUMMY_VAR__);
            stan::math::assign(dummy_theta,rep_vector(0, (r - 1)));
            current_statement_begin__ = 3219;
            result_nrow = int(0);
            stan::math::fill(result_nrow, std::numeric_limits<int>::min());
            current_statement_begin__ = 3220;
            result_ncol = int(0);
            stan::math::fill(result_ncol, std::numeric_limits<int>::min());
            current_statement_begin__ = 3221;
            result_length = int(0);
            stan::math::fill(result_length, std::numeric_limits<int>::min());
            // execute transformed data statements
            current_statement_begin__ = 3224;
            if (as_bool(logical_gt(p_ar, 0))) {
                current_statement_begin__ = 3225;
                stan::model::assign(dummy_phi, 
                            stan::model::cons_list(stan::model::index_min_max(1, p_ar), stan::model::nil_index_list()), 
                            phi, 
                            "assigning variable dummy_phi");
            }
            current_statement_begin__ = 3228;
            if (as_bool(logical_gt(P_ar, 0))) {
                current_statement_begin__ = 3229;
                for (int i = 1; i <= P_ar; ++i) {
                    current_statement_begin__ = 3230;
                    stan::model::assign(dummy_phi, 
                                stan::model::cons_list(stan::model::index_uni((i * ts_frequency)), stan::model::nil_index_list()), 
                                get_base1(phi_seasonal, i, "phi_seasonal", 1), 
                                "assigning variable dummy_phi");
                }
            }
            current_statement_begin__ = 3234;
            if (as_bool((primitive_value(logical_gt(p_ar, 0)) && primitive_value(logical_gt(P_ar, 0))))) {
                current_statement_begin__ = 3235;
                for (int i = 1; i <= p_ar; ++i) {
                    current_statement_begin__ = 3236;
                    for (int j = 1; j <= P_ar; ++j) {
                        current_statement_begin__ = 3237;
                        stan::model::assign(dummy_phi, 
                                    stan::model::cons_list(stan::model::index_uni((i + (j * ts_frequency))), stan::model::nil_index_list()), 
                                    (-(get_base1(phi, i, "phi", 1)) * get_base1(phi_seasonal, j, "phi_seasonal", 1)), 
                                    "assigning variable dummy_phi");
                    }
                }
            }
            current_statement_begin__ = 3243;
            if (as_bool(logical_gt(q_ma, 0))) {
                current_statement_begin__ = 3244;
                stan::model::assign(dummy_theta, 
                            stan::model::cons_list(stan::model::index_min_max(1, q_ma), stan::model::nil_index_list()), 
                            theta, 
                            "assigning variable dummy_theta");
            }
            current_statement_begin__ = 3247;
            if (as_bool(logical_gt(Q_ma, 0))) {
                current_statement_begin__ = 3248;
                for (int i = 1; i <= Q_ma; ++i) {
                    current_statement_begin__ = 3249;
                    stan::model::assign(dummy_theta, 
                                stan::model::cons_list(stan::model::index_uni((i * ts_frequency)), stan::model::nil_index_list()), 
                                get_base1(theta_seasonal, i, "theta_seasonal", 1), 
                                "assigning variable dummy_theta");
                }
            }
            current_statement_begin__ = 3253;
            if (as_bool((primitive_value(logical_gt(q_ma, 0)) && primitive_value(logical_gt(Q_ma, 0))))) {
                current_statement_begin__ = 3254;
                for (int i = 1; i <= q_ma; ++i) {
                    current_statement_begin__ = 3255;
                    for (int j = 1; j <= Q_ma; ++j) {
                        current_statement_begin__ = 3256;
                        stan::model::assign(dummy_theta, 
                                    stan::model::cons_list(stan::model::index_uni((i + (j * ts_frequency))), stan::model::nil_index_list()), 
                                    (-(get_base1(theta, i, "theta", 1)) * get_base1(theta_seasonal, j, "theta_seasonal", 1)), 
                                    "assigning variable dummy_theta");
                    }
                }
            }
            current_statement_begin__ = 3262;
            stan::math::assign(R, append_row(stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<double, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).array())).array()), to_matrix(dummy_theta)));
            current_statement_begin__ = 3265;
            stan::math::assign(T, append_col(dummy_phi, append_row(diag_matrix(rep_vector(1, (m - 1))), to_matrix(rep_row_vector(0, (m - 1))))));
            current_statement_begin__ = 3270;
            stan::math::assign(P1, multiply(var_zeta, stationary_cov(T, quad_form_sym(Q, transpose(R)), pstream__)));
            current_statement_begin__ = 3272;
            if (as_bool(include_intercept)) {
                current_statement_begin__ = 3273;
                stan::math::assign(c, append_row(phi_0, rep_vector(0, (m - 1))));
            } else {
                current_statement_begin__ = 3275;
                stan::math::assign(c, rep_vector(0, m));
            }
            current_statement_begin__ = 3278;
            if (as_bool(logical_eq(joint, 0))) {
                current_statement_begin__ = 3280;
                stan::math::assign(result_nrow, p);
                current_statement_begin__ = 3281;
                stan::math::assign(result_ncol, (p + 1));
                current_statement_begin__ = 3282;
                stan::math::assign(result_length, horizon);
            } else {
                current_statement_begin__ = 3285;
                stan::math::assign(result_nrow, (horizon * p));
                current_statement_begin__ = 3286;
                stan::math::assign(result_ncol, ((horizon * p) + 1));
                current_statement_begin__ = 3287;
                stan::math::assign(result_length, 1);
            }
            // validate transformed data
            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    ~model_SARIMA_predict() { }
    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        typedef double local_scalar_t__;
        stan::io::writer<double> writer__(params_r__, params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;
        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }
    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }
    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(std::vector<T__>& params_r__,
                 std::vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {
        typedef T__ local_scalar_t__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // dummy to suppress unused var warning
        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;
        try {
            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
            // model parameters
            // model body
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
        lp_accum__.add(lp__);
        return lp_accum__.sum();
    } // log_prob()
    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }
    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("forecasts");
    }
    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(result_length);
        dims__.push_back(result_nrow);
        dims__.push_back(result_ncol);
        dimss__.push_back(dims__);
    }
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;
        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
        static const char* function__ = "model_SARIMA_predict_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        if (!include_tparams__ && !include_gqs__) return;
        try {
            if (!include_gqs__ && !include_tparams__) return;
            if (!include_gqs__) return;
            // declare and define generated quantities
            current_statement_begin__ = 3296;
            validate_non_negative_index("forecasts", "result_nrow", result_nrow);
            validate_non_negative_index("forecasts", "result_ncol", result_ncol);
            validate_non_negative_index("forecasts", "result_length", result_length);
            std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > forecasts(result_length, Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(result_nrow, result_ncol));
            stan::math::initialize(forecasts, DUMMY_VAR__);
            stan::math::fill(forecasts, DUMMY_VAR__);
            // generated quantities statements
            current_statement_begin__ = 3297;
            if (as_bool(logical_eq(joint, 0))) {
                current_statement_begin__ = 3298;
                stan::math::assign(forecasts, predict(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__));
            } else {
                current_statement_begin__ = 3300;
                stan::model::assign(forecasts, 
                            stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                            ssm_constant_joint_predict(y, d, Z, H, c, T, R, Q, a1, P1, horizon, pstream__), 
                            "assigning variable forecasts");
            }
            // validate, write generated quantities
            current_statement_begin__ = 3296;
            size_t forecasts_j_2_max__ = result_ncol;
            size_t forecasts_j_1_max__ = result_nrow;
            size_t forecasts_k_0_max__ = result_length;
            for (size_t j_2__ = 0; j_2__ < forecasts_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < forecasts_j_1_max__; ++j_1__) {
                    for (size_t k_0__ = 0; k_0__ < forecasts_k_0_max__; ++k_0__) {
                        vars__.push_back(forecasts[k_0__](j_1__, j_2__));
                    }
                }
            }
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }
    std::string model_name() const {
        return "model_SARIMA_predict";
    }
    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
        }
        if (!include_gqs__) return;
        size_t forecasts_j_2_max__ = result_ncol;
        size_t forecasts_j_1_max__ = result_nrow;
        size_t forecasts_k_0_max__ = result_length;
        for (size_t j_2__ = 0; j_2__ < forecasts_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < forecasts_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < forecasts_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "forecasts" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }
    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
        }
        if (!include_gqs__) return;
        size_t forecasts_j_2_max__ = result_ncol;
        size_t forecasts_j_1_max__ = result_nrow;
        size_t forecasts_k_0_max__ = result_length;
        for (size_t j_2__ = 0; j_2__ < forecasts_j_2_max__; ++j_2__) {
            for (size_t j_1__ = 0; j_1__ < forecasts_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < forecasts_k_0_max__; ++k_0__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "forecasts" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
    }
}; // model
}  // namespace
typedef model_SARIMA_predict_namespace::model_SARIMA_predict stan_model;
#ifndef USING_R
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
#endif
#endif
