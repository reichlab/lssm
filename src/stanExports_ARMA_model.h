// Generated by rstantools.  Do not edit by hand.

/*
    lssm is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    lssm is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with lssm.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.21.0
#include <stan/model/model_header.hpp>
namespace model_ARMA_model_namespace {
using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;
static int current_statement_begin__;
stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_ARMA_model");
    reader.add_event(0, 0, "include", "functions.stan");
    reader.add_event(0, 0, "start", "functions.stan");
    reader.add_event(2932, 2932, "end", "functions.stan");
    reader.add_event(2932, 1, "restart", "model_ARMA_model");
    reader.add_event(3010, 77, "end", "model_ARMA_model");
    return reader;
}
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_symmetric_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        current_statement_begin__ = 12;
        return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(0.5, add(x, transpose(x))));
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_symmetric_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return to_symmetric_matrix(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
to_matrix_colwise(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 30;
        validate_non_negative_index("res", "m", m);
        validate_non_negative_index("res", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> res(m, n);
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 31;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 32;
        stan::math::assign(k, 1);
        current_statement_begin__ = 34;
        for (int j = 1; j <= n; ++j) {
            current_statement_begin__ = 36;
            for (int i = 1; i <= m; ++i) {
                current_statement_begin__ = 37;
                stan::model::assign(res, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            get_base1(v, k, "v", 1), 
                            "assigning variable res");
                current_statement_begin__ = 38;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 41;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct to_matrix_colwise_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const int& m,
                      const int& n, std::ostream* pstream__) const {
        return to_matrix_colwise(v, m, n, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
matrix_pow(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__);
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
matrix_pow(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 60;
        local_scalar_t__ nn(DUMMY_VAR__);
        (void) nn;  // dummy to suppress unused var warning
        stan::math::initialize(nn, DUMMY_VAR__);
        stan::math::fill(nn, DUMMY_VAR__);
        current_statement_begin__ = 61;
        stan::math::assign(nn, stan::math::floor(n));
        current_statement_begin__ = 62;
        if (as_bool(logical_eq(nn, 0))) {
            current_statement_begin__ = 63;
            return stan::math::promote_scalar<fun_return_scalar_t__>(diag_matrix(rep_vector(1., rows(A))));
        } else if (as_bool(logical_eq(nn, 1))) {
            current_statement_begin__ = 65;
            return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        } else if (as_bool(logical_gt(nn, 1))) {
            current_statement_begin__ = 68;
            if (as_bool(logical_gt(fmod(nn, 2.), 0))) {
                current_statement_begin__ = 70;
                return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(A, matrix_pow(A, (nn - 1), pstream__)));
            } else {
                current_statement_begin__ = 73;
                return stan::math::promote_scalar<fun_return_scalar_t__>(multiply(matrix_pow(A, (nn / 2), pstream__), matrix_pow(A, (nn / 2), pstream__)));
            }
        } else {
            current_statement_begin__ = 77;
            std::stringstream errmsg_stream__;
            errmsg_stream__ << "Only non-negative values of n are allowed";
            throw std::domain_error(errmsg_stream__.str());
            current_statement_begin__ = 78;
            return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct matrix_pow_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
               const T1__& n, std::ostream* pstream__) const {
        return matrix_pow(A, n, pstream__);
    }
};
int
symmat_size(const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 113;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 116;
        stan::math::assign(sz, 0);
        current_statement_begin__ = 117;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 118;
            stan::math::assign(sz, (sz + i));
        }
        current_statement_begin__ = 120;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct symmat_size_functor__ {
            int
    operator()(const int& n, std::ostream* pstream__) const {
        return symmat_size(n, pstream__);
    }
};
int
find_symmat_dim(const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 140;
        int i(0);
        (void) i;  // dummy to suppress unused var warning
        stan::math::fill(i, std::numeric_limits<int>::min());
        current_statement_begin__ = 141;
        int remainder(0);
        (void) remainder;  // dummy to suppress unused var warning
        stan::math::fill(remainder, std::numeric_limits<int>::min());
        current_statement_begin__ = 142;
        stan::math::assign(remainder, n);
        current_statement_begin__ = 143;
        stan::math::assign(i, 0);
        current_statement_begin__ = 144;
        while (as_bool(logical_gt(remainder, 0))) {
            current_statement_begin__ = 145;
            stan::math::assign(i, (i + 1));
            current_statement_begin__ = 146;
            stan::math::assign(remainder, (remainder - i));
        }
        current_statement_begin__ = 148;
        return stan::math::promote_scalar<fun_return_scalar_t__>(i);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct find_symmat_dim_functor__ {
            int
    operator()(const int& n, std::ostream* pstream__) const {
        return find_symmat_dim(n, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
vector_to_symmat(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& n, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 165;
        validate_non_negative_index("m", "n", n);
        validate_non_negative_index("m", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> m(n, n);
        stan::math::initialize(m, DUMMY_VAR__);
        stan::math::fill(m, DUMMY_VAR__);
        current_statement_begin__ = 166;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 167;
        stan::math::assign(k, 1);
        current_statement_begin__ = 169;
        for (int j = 1; j <= n; ++j) {
            current_statement_begin__ = 171;
            for (int i = j; i <= n; ++i) {
                current_statement_begin__ = 172;
                stan::model::assign(m, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                            get_base1(x, k, "x", 1), 
                            "assigning variable m");
                current_statement_begin__ = 173;
                if (as_bool(logical_neq(i, j))) {
                    current_statement_begin__ = 174;
                    stan::model::assign(m, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                                get_base1(m, i, j, "m", 1), 
                                "assigning variable m");
                }
                current_statement_begin__ = 176;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 179;
        return stan::math::promote_scalar<fun_return_scalar_t__>(m);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct vector_to_symmat_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& n, std::ostream* pstream__) const {
        return vector_to_symmat(x, n, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
symmat_to_vector(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 199;
        validate_non_negative_index("v", "symmat_size(std::min(rows(x), cols(x)), pstream__)", symmat_size(std::min(rows(x), cols(x)), pstream__));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(symmat_size(std::min(rows(x), cols(x)), pstream__));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 200;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 201;
        int k(0);
        (void) k;  // dummy to suppress unused var warning
        stan::math::fill(k, std::numeric_limits<int>::min());
        current_statement_begin__ = 202;
        stan::math::assign(k, 1);
        current_statement_begin__ = 203;
        stan::math::assign(m, std::min(rows(x), cols(x)));
        current_statement_begin__ = 206;
        for (int j = 1; j <= m; ++j) {
            current_statement_begin__ = 207;
            for (int i = j; i <= m; ++i) {
                current_statement_begin__ = 208;
                stan::model::assign(v, 
                            stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                            get_base1(x, i, j, "x", 1), 
                            "assigning variable v");
                current_statement_begin__ = 209;
                stan::math::assign(k, (k + 1));
            }
        }
        current_statement_begin__ = 212;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct symmat_to_vector_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x, std::ostream* pstream__) const {
        return symmat_to_vector(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_lower_triangular_matrix(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 236;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 237;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 238;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 239;
                if (as_bool(logical_gt(i, j))) {
                    current_statement_begin__ = 240;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                x, 
                                "assigning variable A");
                } else if (as_bool(logical_eq(i, j))) {
                    current_statement_begin__ = 242;
                    if (as_bool(diag)) {
                        current_statement_begin__ = 243;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    x, 
                                    "assigning variable A");
                    } else {
                        current_statement_begin__ = 245;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    0., 
                                    "assigning variable A");
                    }
                } else {
                    current_statement_begin__ = 248;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                0., 
                                "assigning variable A");
                }
            }
        }
        current_statement_begin__ = 252;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_lower_triangular_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) const {
        return rep_lower_triangular_matrix(x, m, n, diag, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_upper_triangular_matrix(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 276;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 277;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 278;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 280;
                if (as_bool(logical_lt(i, j))) {
                    current_statement_begin__ = 281;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                x, 
                                "assigning variable A");
                } else if (as_bool(logical_eq(i, j))) {
                    current_statement_begin__ = 283;
                    if (as_bool(diag)) {
                        current_statement_begin__ = 284;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    x, 
                                    "assigning variable A");
                    } else {
                        current_statement_begin__ = 286;
                        stan::model::assign(A, 
                                    stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                    0., 
                                    "assigning variable A");
                    }
                } else {
                    current_statement_begin__ = 289;
                    stan::model::assign(A, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                0., 
                                "assigning variable A");
                }
            }
        }
        current_statement_begin__ = 293;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_upper_triangular_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                                const int& m,
                                const int& n,
                                const int& diag, std::ostream* pstream__) const {
        return rep_upper_triangular_matrix(x, m, n, diag, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
rep_diagonal_matrix(const T0__& x,
                        const int& m,
                        const int& n,
                        const int& k, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 318;
        validate_non_negative_index("A", "m", m);
        validate_non_negative_index("A", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> A(m, n);
        stan::math::initialize(A, DUMMY_VAR__);
        stan::math::fill(A, DUMMY_VAR__);
        current_statement_begin__ = 319;
        int mn(0);
        (void) mn;  // dummy to suppress unused var warning
        stan::math::fill(mn, std::numeric_limits<int>::min());
        current_statement_begin__ = 320;
        stan::math::assign(A, rep_matrix(0., m, n));
        current_statement_begin__ = 321;
        stan::math::assign(mn, std::min(m, n));
        current_statement_begin__ = 322;
        if (as_bool(logical_gte(k, 0))) {
            current_statement_begin__ = 323;
            for (int i = 1; i <= std::min(m, (n - k)); ++i) {
                current_statement_begin__ = 324;
                stan::model::assign(A, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni((i + k)), stan::model::nil_index_list())), 
                            x, 
                            "assigning variable A");
            }
        } else {
            current_statement_begin__ = 327;
            for (int i = 1; i <= std::min((m + k), n); ++i) {
                current_statement_begin__ = 328;
                stan::model::assign(A, 
                            stan::model::cons_list(stan::model::index_uni((i - k)), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            x, 
                            "assigning variable A");
            }
        }
        current_statement_begin__ = 331;
        return stan::math::promote_scalar<fun_return_scalar_t__>(A);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct rep_diagonal_matrix_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const T0__& x,
                        const int& m,
                        const int& n,
                        const int& k, std::ostream* pstream__) const {
        return rep_diagonal_matrix(x, m, n, k, pstream__);
    }
};
template <typename T0__, typename T5__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T5__>::type, Eigen::Dynamic, Eigen::Dynamic>
fill_matrix(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x,
                const int& m,
                const int& n,
                const std::vector<int>& i,
                const std::vector<int>& j,
                const T5__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T5__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 368;
        validate_non_negative_index("ret", "m", m);
        validate_non_negative_index("ret", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> ret(m, n);
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 369;
        stan::math::assign(ret, rep_matrix(a, m, n));
        current_statement_begin__ = 370;
        stan::model::assign(ret, 
                    stan::model::cons_list(stan::model::index_multi(i), stan::model::cons_list(stan::model::index_multi(j), stan::model::nil_index_list())), 
                    x, 
                    "assigning variable ret");
        current_statement_begin__ = 371;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct fill_matrix_functor__ {
    template <typename T0__, typename T5__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T5__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& x,
                const int& m,
                const int& n,
                const std::vector<int>& i,
                const std::vector<int>& j,
                const T5__& a, std::ostream* pstream__) const {
        return fill_matrix(x, m, n, i, j, a, pstream__);
    }
};
template <typename T0__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T3__>::type, Eigen::Dynamic, 1>
fill_vector(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                const int& n,
                const std::vector<int>& i,
                const T3__& a, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 402;
        validate_non_negative_index("ret", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ret(n);
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 403;
        stan::math::assign(ret, rep_vector(a, n));
        current_statement_begin__ = 404;
        stan::model::assign(ret, 
                    stan::model::cons_list(stan::model::index_multi(i), stan::model::nil_index_list()), 
                    x, 
                    "assigning variable ret");
        current_statement_begin__ = 405;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct fill_vector_functor__ {
    template <typename T0__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                const int& n,
                const std::vector<int>& i,
                const T3__& a, std::ostream* pstream__) const {
        return fill_vector(x, n, i, a, pstream__);
    }
};
int
int_sum_true(const std::vector<int>& x, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 424;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 425;
        stan::math::assign(n, 0);
        current_statement_begin__ = 426;
        for (int i = 1; i <= num_elements(x); ++i) {
            current_statement_begin__ = 427;
            if (as_bool(int_step(get_base1(x, i, "x", 1)))) {
                current_statement_begin__ = 428;
                stan::math::assign(n, (n + 1));
            }
        }
        current_statement_begin__ = 431;
        return stan::math::promote_scalar<fun_return_scalar_t__>(n);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct int_sum_true_functor__ {
            int
    operator()(const std::vector<int>& x, std::ostream* pstream__) const {
        return int_sum_true(x, pstream__);
    }
};
int
int_sum_false(const std::vector<int>& x, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 450;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 451;
        stan::math::assign(n, 0);
        current_statement_begin__ = 452;
        for (int i = 1; i <= num_elements(x); ++i) {
            current_statement_begin__ = 453;
            if (as_bool(logical_negation(int_step(get_base1(x, i, "x", 1))))) {
                current_statement_begin__ = 454;
                stan::math::assign(n, (n + 1));
            }
        }
        current_statement_begin__ = 457;
        return stan::math::promote_scalar<fun_return_scalar_t__>(n);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct int_sum_false_functor__ {
            int
    operator()(const std::vector<int>& x, std::ostream* pstream__) const {
        return int_sum_false(x, pstream__);
    }
};
std::vector<int>
mask_indexes(const std::vector<int>& x,
                 const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 483;
        validate_non_negative_index("idx", "n", n);
        std::vector<int  > idx(n, int(0));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 484;
        int j(0);
        (void) j;  // dummy to suppress unused var warning
        stan::math::fill(j, std::numeric_limits<int>::min());
        current_statement_begin__ = 485;
        stan::math::assign(j, 1);
        current_statement_begin__ = 486;
        if (as_bool(logical_gt(n, 0))) {
            current_statement_begin__ = 487;
            for (int i = 1; i <= num_elements(x); ++i) {
                current_statement_begin__ = 488;
                if (as_bool((primitive_value(logical_negation(int_step(get_base1(x, i, "x", 1)))) && primitive_value(logical_lte(j, n))))) {
                    current_statement_begin__ = 489;
                    stan::model::assign(idx, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list()), 
                                i, 
                                "assigning variable idx");
                    current_statement_begin__ = 490;
                    stan::math::assign(j, (j + 1));
                }
            }
        }
        current_statement_begin__ = 494;
        return stan::math::promote_scalar<fun_return_scalar_t__>(idx);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct mask_indexes_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& x,
                 const int& n, std::ostream* pstream__) const {
        return mask_indexes(x, n, pstream__);
    }
};
std::vector<int>
select_indexes(const std::vector<int>& x,
                   const int& n, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 520;
        validate_non_negative_index("idx", "n", n);
        std::vector<int  > idx(n, int(0));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 521;
        int j(0);
        (void) j;  // dummy to suppress unused var warning
        stan::math::fill(j, std::numeric_limits<int>::min());
        current_statement_begin__ = 522;
        stan::math::assign(j, 1);
        current_statement_begin__ = 523;
        if (as_bool(logical_gt(n, 0))) {
            current_statement_begin__ = 524;
            for (int i = 1; i <= num_elements(x); ++i) {
                current_statement_begin__ = 525;
                if (as_bool((primitive_value(int_step(get_base1(x, i, "x", 1))) && primitive_value(logical_lte(j, n))))) {
                    current_statement_begin__ = 526;
                    stan::model::assign(idx, 
                                stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list()), 
                                i, 
                                "assigning variable idx");
                    current_statement_begin__ = 527;
                    stan::math::assign(j, (j + 1));
                }
            }
        }
        current_statement_begin__ = 531;
        return stan::math::promote_scalar<fun_return_scalar_t__>(idx);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct select_indexes_functor__ {
            std::vector<int>
    operator()(const std::vector<int>& x,
                   const int& n, std::ostream* pstream__) const {
        return select_indexes(x, n, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
typename boost::math::tools::promote_args<T0__, T1__>::type
normal2_rng(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 553;
        local_scalar_t__ y(DUMMY_VAR__);
        (void) y;  // dummy to suppress unused var warning
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 554;
        if (as_bool(logical_lte(sigma, 0))) {
            current_statement_begin__ = 555;
            stan::math::assign(y, mu);
        } else {
            current_statement_begin__ = 557;
            stan::math::assign(y, normal_rng(mu, sigma, base_rng__));
        }
        current_statement_begin__ = 559;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct normal2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const T0__& mu,
                const T1__& sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return normal2_rng(mu, sigma, base_rng__, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
cholesky_decompose2(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 578;
        validate_non_negative_index("L", "rows(A)", rows(A));
        validate_non_negative_index("L", "cols(A)", cols(A));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> L(rows(A), cols(A));
        stan::math::initialize(L, DUMMY_VAR__);
        stan::math::fill(L, DUMMY_VAR__);
        current_statement_begin__ = 579;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 580;
        validate_non_negative_index("nonzero", "rows(A)", rows(A));
        std::vector<int  > nonzero(rows(A), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 581;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 582;
        stan::math::assign(n, rows(A));
        current_statement_begin__ = 583;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 584;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(A, i, i, "A", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 586;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 587;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 588;
            stan::math::assign(L, cholesky_decompose(A));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 590;
            stan::math::assign(L, rep_matrix(0.0, n, n));
        } else {
            {
            current_statement_begin__ = 592;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 593;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 594;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 595;
            stan::math::assign(L, rep_matrix(0.0, n, n));
            current_statement_begin__ = 596;
            stan::model::assign(L, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), 
                        cholesky_decompose(stan::model::rvalue(A, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "A")), 
                        "assigning variable L");
            }
        }
        current_statement_begin__ = 598;
        return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct cholesky_decompose2_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A, std::ostream* pstream__) const {
        return cholesky_decompose2(A, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
multi_normal2_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Sigma, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 622;
        validate_non_negative_index("y", "num_elements(mu)", num_elements(mu));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(num_elements(mu));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 623;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 624;
        validate_non_negative_index("nonzero", "num_elements(mu)", num_elements(mu));
        std::vector<int  > nonzero(num_elements(mu), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 625;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 626;
        stan::math::assign(n, num_elements(mu));
        current_statement_begin__ = 627;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 628;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(Sigma, i, i, "Sigma", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 630;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 631;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 632;
            stan::math::assign(y, multi_normal_rng(mu, Sigma, base_rng__));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 634;
            stan::math::assign(y, mu);
        } else {
            {
            current_statement_begin__ = 636;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 637;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 638;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 639;
            stan::math::assign(eps, rep_vector(0.0, n));
            current_statement_begin__ = 640;
            stan::model::assign(eps, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                        multi_normal_rng(rep_vector(0.0, num_nonzero), stan::model::rvalue(Sigma, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "Sigma"), base_rng__), 
                        "assigning variable eps");
            current_statement_begin__ = 641;
            stan::math::assign(y, add(mu, eps));
            }
        }
        current_statement_begin__ = 643;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct multi_normal2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Sigma, RNG& base_rng__, std::ostream* pstream__) const {
        return multi_normal2_rng(mu, Sigma, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, class RNG>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
multi_normal_cholesky2_rng(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& L, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 666;
        validate_non_negative_index("y", "num_elements(mu)", num_elements(mu));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(num_elements(mu));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 667;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 668;
        validate_non_negative_index("nonzero", "num_elements(mu)", num_elements(mu));
        std::vector<int  > nonzero(num_elements(mu), int(0));
        stan::math::fill(nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 669;
        int num_nonzero(0);
        (void) num_nonzero;  // dummy to suppress unused var warning
        stan::math::fill(num_nonzero, std::numeric_limits<int>::min());
        current_statement_begin__ = 670;
        stan::math::assign(n, num_elements(mu));
        current_statement_begin__ = 671;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 672;
            stan::model::assign(nonzero, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        logical_gt(get_base1(L, i, i, "L", 1), 0), 
                        "assigning variable nonzero");
        }
        current_statement_begin__ = 674;
        stan::math::assign(num_nonzero, sum(nonzero));
        current_statement_begin__ = 675;
        if (as_bool(logical_eq(num_nonzero, n))) {
            current_statement_begin__ = 676;
            stan::math::assign(y, multi_normal_cholesky_rng(mu, L, base_rng__));
        } else if (as_bool(logical_eq(num_nonzero, 0))) {
            current_statement_begin__ = 678;
            stan::math::assign(y, mu);
        } else {
            {
            current_statement_begin__ = 680;
            validate_non_negative_index("idx", "num_nonzero", num_nonzero);
            std::vector<int  > idx(num_nonzero, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 681;
            validate_non_negative_index("eps", "n", n);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(n);
            stan::math::initialize(eps, DUMMY_VAR__);
            stan::math::fill(eps, DUMMY_VAR__);
            current_statement_begin__ = 682;
            stan::math::assign(idx, select_indexes(nonzero, num_nonzero, pstream__));
            current_statement_begin__ = 683;
            stan::math::assign(eps, rep_vector(0.0, n));
            current_statement_begin__ = 684;
            stan::model::assign(eps, 
                        stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                        multi_normal_cholesky_rng(rep_vector(0.0, num_nonzero), stan::model::rvalue(L, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "L"), base_rng__), 
                        "assigning variable eps");
            current_statement_begin__ = 686;
            stan::math::assign(y, add(mu, eps));
            }
        }
        current_statement_begin__ = 688;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct multi_normal_cholesky2_rng_functor__ {
    template <typename T0__, typename T1__, class RNG>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& mu,
                               const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& L, RNG& base_rng__, std::ostream* pstream__) const {
        return multi_normal_cholesky2_rng(mu, L, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, 1>
ssm_update_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& c,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& v,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 726;
        validate_non_negative_index("a_new", "num_elements(a)", num_elements(a));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a_new(num_elements(a));
        stan::math::initialize(a_new, DUMMY_VAR__);
        stan::math::fill(a_new, DUMMY_VAR__);
        current_statement_begin__ = 727;
        stan::math::assign(a_new, add(add(multiply(T, a), multiply(K, v)), c));
        current_statement_begin__ = 728;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_a_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& c,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, 1>& v,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_a(a, c, T, v, K, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_P(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& RQR,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 759;
        validate_non_negative_index("P_new", "rows(P)", rows(P));
        validate_non_negative_index("P_new", "cols(P)", cols(P));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_new(rows(P), cols(P));
        stan::math::initialize(P_new, DUMMY_VAR__);
        stan::math::fill(P_new, DUMMY_VAR__);
        current_statement_begin__ = 760;
        stan::math::assign(P_new, to_symmetric_matrix(add(multiply(multiply(T, P), transpose(subtract(T, multiply(K, Z)))), RQR), pstream__));
        current_statement_begin__ = 761;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_P_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& RQR,
                 const Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_P(P, Z, T, RQR, K, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
ssm_update_v(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 790;
        validate_non_negative_index("v", "num_elements(y)", num_elements(y));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(num_elements(y));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 791;
        stan::math::assign(v, subtract(subtract(y, multiply(Z, a)), d));
        current_statement_begin__ = 792;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_v_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z, std::ostream* pstream__) const {
        return ssm_update_v(y, a, d, Z, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
ssm_update_v_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const int& p_t,
                      const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 832;
        validate_non_negative_index("v", "num_elements(y)", num_elements(y));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(num_elements(y));
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 833;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 834;
        stan::math::assign(p, num_elements(y));
        current_statement_begin__ = 835;
        if (as_bool(logical_lt(p_t, p))) {
            current_statement_begin__ = 836;
            stan::math::assign(v, rep_vector(0., p));
            current_statement_begin__ = 837;
            if (as_bool(logical_gt(p_t, 0))) {
                {
                current_statement_begin__ = 838;
                validate_non_negative_index("idx", "p_t", p_t);
                std::vector<int  > idx(p_t, int(0));
                stan::math::fill(idx, std::numeric_limits<int>::min());
                current_statement_begin__ = 839;
                validate_non_negative_index("y_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y_star(p_t);
                stan::math::initialize(y_star, DUMMY_VAR__);
                stan::math::fill(y_star, DUMMY_VAR__);
                current_statement_begin__ = 840;
                validate_non_negative_index("d_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_star(p_t);
                stan::math::initialize(d_star, DUMMY_VAR__);
                stan::math::fill(d_star, DUMMY_VAR__);
                current_statement_begin__ = 841;
                validate_non_negative_index("Z_star", "p_t", p_t);
                validate_non_negative_index("Z_star", "cols(Z)", cols(Z));
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_star(p_t, cols(Z));
                stan::math::initialize(Z_star, DUMMY_VAR__);
                stan::math::fill(Z_star, DUMMY_VAR__);
                current_statement_begin__ = 842;
                stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
                current_statement_begin__ = 843;
                stan::math::assign(y_star, stan::model::rvalue(y, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "y"));
                current_statement_begin__ = 844;
                stan::math::assign(d_star, stan::model::rvalue(d, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "d"));
                current_statement_begin__ = 845;
                stan::math::assign(Z_star, stan::model::rvalue(Z, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "Z"));
                current_statement_begin__ = 846;
                stan::model::assign(v, 
                            stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), 
                            ssm_update_v(y_star, a, d_star, Z_star, pstream__), 
                            "assigning variable v");
                }
            }
        } else {
            current_statement_begin__ = 849;
            stan::math::assign(v, ssm_update_v(y, a, d, Z, pstream__));
        }
        current_statement_begin__ = 851;
        return stan::math::promote_scalar<fun_return_scalar_t__>(v);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_v_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& a,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const int& p_t,
                      const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_v_miss(y, a, d, Z, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_F(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 878;
        validate_non_negative_index("F", "rows(H)", rows(H));
        validate_non_negative_index("F", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> F(rows(H), cols(H));
        stan::math::initialize(F, DUMMY_VAR__);
        stan::math::fill(F, DUMMY_VAR__);
        current_statement_begin__ = 879;
        stan::math::assign(F, to_symmetric_matrix(add(quad_form(P, transpose(Z)), H), pstream__));
        current_statement_begin__ = 880;
        return stan::math::promote_scalar<fun_return_scalar_t__>(F);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_F_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_F(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                    const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                    const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 904;
        validate_non_negative_index("Finv", "rows(H)", rows(H));
        validate_non_negative_index("Finv", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(rows(H), cols(H));
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 906;
        stan::math::assign(Finv, inverse_spd(to_symmetric_matrix(add(quad_form(P, transpose(Z)), H), pstream__)));
        current_statement_begin__ = 908;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_Finv_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                    const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                    const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H, std::ostream* pstream__) const {
        return ssm_update_Finv(P, Z, H, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_Finv_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                         const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                         const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H,
                         const int& p_t,
                         const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 941;
        validate_non_negative_index("Finv", "rows(H)", rows(H));
        validate_non_negative_index("Finv", "cols(H)", cols(H));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(rows(H), cols(H));
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 942;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 943;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 944;
        stan::math::assign(p, rows(H));
        current_statement_begin__ = 945;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 946;
        if (as_bool(logical_lt(p_t, p))) {
            current_statement_begin__ = 947;
            stan::math::assign(Finv, rep_matrix(0., p, p));
            current_statement_begin__ = 948;
            if (as_bool(logical_gt(p_t, 0))) {
                {
                current_statement_begin__ = 949;
                validate_non_negative_index("Z_star", "p_t", p_t);
                validate_non_negative_index("Z_star", "m", m);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_star(p_t, m);
                stan::math::initialize(Z_star, DUMMY_VAR__);
                stan::math::fill(Z_star, DUMMY_VAR__);
                current_statement_begin__ = 950;
                validate_non_negative_index("H_star", "p_t", p_t);
                validate_non_negative_index("H_star", "p_t", p_t);
                Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_star(p_t, p_t);
                stan::math::initialize(H_star, DUMMY_VAR__);
                stan::math::fill(H_star, DUMMY_VAR__);
                current_statement_begin__ = 951;
                validate_non_negative_index("idx", "p_t", p_t);
                std::vector<int  > idx(p_t, int(0));
                stan::math::fill(idx, std::numeric_limits<int>::min());
                current_statement_begin__ = 952;
                stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
                current_statement_begin__ = 953;
                stan::math::assign(Z_star, stan::model::rvalue(Z, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "Z"));
                current_statement_begin__ = 954;
                stan::math::assign(H_star, stan::model::rvalue(H, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "H"));
                current_statement_begin__ = 955;
                stan::model::assign(Finv, 
                            stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), 
                            ssm_update_Finv(P, Z_star, H_star, pstream__), 
                            "assigning variable Finv");
                }
            }
        } else {
            current_statement_begin__ = 958;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
        }
        current_statement_begin__ = 960;
        return stan::math::promote_scalar<fun_return_scalar_t__>(Finv);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_Finv_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                         const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                         const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& H,
                         const int& p_t,
                         const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_Finv_miss(P, Z, H, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_K(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 989;
        validate_non_negative_index("K", "cols(Z)", cols(Z));
        validate_non_negative_index("K", "rows(Z)", rows(Z));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(cols(Z), rows(Z));
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 990;
        stan::math::assign(K, multiply(multiply(multiply(T, P), transpose(Z)), Finv));
        current_statement_begin__ = 991;
        return stan::math::promote_scalar<fun_return_scalar_t__>(K);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_K_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& P,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_update_K(P, Z, T, Finv, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_update_L(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1018;
        validate_non_negative_index("L", "rows(T)", rows(T));
        validate_non_negative_index("L", "cols(T)", cols(T));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> L(rows(T), cols(T));
        stan::math::initialize(L, DUMMY_VAR__);
        stan::math::fill(L, DUMMY_VAR__);
        current_statement_begin__ = 1019;
        stan::math::assign(L, subtract(T, multiply(K, Z)));
        current_statement_begin__ = 1020;
        return stan::math::promote_scalar<fun_return_scalar_t__>(L);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_L_functor__ {
    template <typename T0__, typename T1__, typename T2__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                 const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& T,
                 const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& K, std::ostream* pstream__) const {
        return ssm_update_L(Z, T, K, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_update_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1046;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1047;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1048;
        stan::math::assign(p, num_elements(v));
        current_statement_begin__ = 1050;
        stan::math::assign(ll, (-(0.5) * (((p * stan::math::log((2 * stan::math::pi()))) - log_determinant(Finv)) + quad_form_sym(Finv, v))));
        current_statement_begin__ = 1055;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_loglik_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv, std::ostream* pstream__) const {
        return ssm_update_loglik(v, Finv, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
ssm_update_loglik_miss(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv,
                           const int& p_t,
                           const std::vector<int>& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1082;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1083;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1084;
        stan::math::assign(p, num_elements(v));
        current_statement_begin__ = 1085;
        if (as_bool(logical_eq(p_t, 0))) {
            current_statement_begin__ = 1086;
            stan::math::assign(ll, 0.);
        } else if (as_bool(logical_eq(p_t, p))) {
            current_statement_begin__ = 1088;
            stan::math::assign(ll, ssm_update_loglik(v, Finv, pstream__));
        } else {
            {
            current_statement_begin__ = 1090;
            validate_non_negative_index("idx", "p_t", p_t);
            std::vector<int  > idx(p_t, int(0));
            stan::math::fill(idx, std::numeric_limits<int>::min());
            current_statement_begin__ = 1091;
            validate_non_negative_index("Finv_star", "p_t", p_t);
            validate_non_negative_index("Finv_star", "p_t", p_t);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv_star(p_t, p_t);
            stan::math::initialize(Finv_star, DUMMY_VAR__);
            stan::math::fill(Finv_star, DUMMY_VAR__);
            current_statement_begin__ = 1092;
            validate_non_negative_index("v_star", "p_t", p_t);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v_star(p_t);
            stan::math::initialize(v_star, DUMMY_VAR__);
            stan::math::fill(v_star, DUMMY_VAR__);
            current_statement_begin__ = 1093;
            stan::math::assign(idx, stan::model::rvalue(y_idx, stan::model::cons_list(stan::model::index_min_max(1, p_t), stan::model::nil_index_list()), "y_idx"));
            current_statement_begin__ = 1094;
            stan::math::assign(Finv_star, stan::model::rvalue(Finv, stan::model::cons_list(stan::model::index_multi(idx), stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list())), "Finv"));
            current_statement_begin__ = 1095;
            stan::math::assign(v_star, stan::model::rvalue(v, stan::model::cons_list(stan::model::index_multi(idx), stan::model::nil_index_list()), "v"));
            current_statement_begin__ = 1096;
            stan::math::assign(ll, ssm_update_loglik(v_star, Finv_star, pstream__));
            }
        }
        current_statement_begin__ = 1098;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_update_loglik_miss_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& v,
                           const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& Finv,
                           const int& p_t,
                           const std::vector<int>& y_idx, std::ostream* pstream__) const {
        return ssm_update_loglik_miss(v, Finv, p_t, y_idx, pstream__);
    }
};
std::vector<std::vector<int> >
ssm_filter_idx(const int& m,
                   const int& p, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1137;
        validate_non_negative_index("sz", "6", 6);
        validate_non_negative_index("sz", "3", 3);
        std::vector<std::vector<int  >  > sz(6, std::vector<int>(3, int(0)));
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 1139;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 1141;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    p, 
                    "assigning variable sz");
        current_statement_begin__ = 1143;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(3), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    symmat_size(p, pstream__), 
                    "assigning variable sz");
        current_statement_begin__ = 1145;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(4), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    (m * p), 
                    "assigning variable sz");
        current_statement_begin__ = 1147;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(5), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    m, 
                    "assigning variable sz");
        current_statement_begin__ = 1149;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(6), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    symmat_size(m, pstream__), 
                    "assigning variable sz");
        current_statement_begin__ = 1151;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 1152;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 1, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 1, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 1153;
        for (int i = 2; i <= 6; ++i) {
            current_statement_begin__ = 1154;
            stan::model::assign(sz, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                        (get_base1(get_base1(sz, (i - 1), "sz", 1), 3, "sz", 2) + 1), 
                        "assigning variable sz");
            current_statement_begin__ = 1155;
            stan::model::assign(sz, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                        ((get_base1(get_base1(sz, i, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, i, "sz", 1), 1, "sz", 2)) - 1), 
                        "assigning variable sz");
        }
        current_statement_begin__ = 1157;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_idx_functor__ {
            std::vector<std::vector<int> >
    operator()(const int& m,
                   const int& p, std::ostream* pstream__) const {
        return ssm_filter_idx(m, p, pstream__);
    }
};
int
ssm_filter_size(const int& m,
                    const int& p, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1177;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 1178;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1179;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1180;
        stan::math::assign(sz, get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2));
        current_statement_begin__ = 1181;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_size_functor__ {
            int
    operator()(const int& m,
                    const int& p, std::ostream* pstream__) const {
        return ssm_filter_size(m, p, pstream__);
    }
};
template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
ssm_filter_get_loglik(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1203;
        local_scalar_t__ y(DUMMY_VAR__);
        (void) y;  // dummy to suppress unused var warning
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1204;
        stan::math::assign(y, get_base1(x, 1, "x", 1));
        current_statement_begin__ = 1205;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_loglik_functor__ {
    template <typename T0__>
        typename boost::math::tools::promote_args<T0__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                          const int& m,
                          const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_loglik(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_filter_get_v(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1227;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1228;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1229;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1230;
        stan::math::assign(y, segment(x, get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 1, "idx", 2)));
        current_statement_begin__ = 1231;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_v_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_v(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_Finv(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1253;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(p, p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1254;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1255;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1256;
        stan::math::assign(y, vector_to_symmat(segment(x, get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 1, "idx", 2)), p, pstream__));
        current_statement_begin__ = 1257;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_Finv_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                        const int& m,
                        const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_Finv(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_K(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1279;
        validate_non_negative_index("y", "m", m);
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(m, p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1280;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1281;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1282;
        stan::math::assign(y, to_matrix_colwise(segment(x, get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 1, "idx", 2)), m, p, pstream__));
        current_statement_begin__ = 1283;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_K_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_K(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_filter_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1305;
        validate_non_negative_index("y", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(m);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1306;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1307;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1308;
        stan::math::assign(y, segment(x, get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 1, "idx", 2)));
        current_statement_begin__ = 1309;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_a_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_a(x, m, p, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
ssm_filter_get_P(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1331;
        validate_non_negative_index("y", "m", m);
        validate_non_negative_index("y", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(m, m);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 1332;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1333;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1334;
        stan::math::assign(y, vector_to_symmat(segment(x, get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 1, "idx", 2)), m, pstream__));
        current_statement_begin__ = 1335;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_get_P_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                     const int& m,
                     const int& p, std::ostream* pstream__) const {
        return ssm_filter_get_P(x, m, p, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_filter(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1395;
        validate_non_negative_index("res", "ssm_filter_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), pstream__)", ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__));
        validate_non_negative_index("res", "size(y)", size(y));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > res(size(y), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__)));
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 1396;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1397;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1398;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1399;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1402;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1403;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1404;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1405;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1410;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1411;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1412;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1413;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1414;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1415;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1416;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1417;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1419;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1420;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1421;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1422;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1423;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1424;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1425;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1427;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1429;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1430;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1431;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1432;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1433;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1434;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1435;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1436;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1437;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1438;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1439;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1440;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1441;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1442;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1444;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1445;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1447;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1448;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1450;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 1451;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 1453;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 1454;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 1456;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 1457;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 1459;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 1460;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                }
                current_statement_begin__ = 1462;
                if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                    current_statement_begin__ = 1463;
                    stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                }
            }
            current_statement_begin__ = 1467;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d_t, Z_t, pstream__));
            current_statement_begin__ = 1468;
            stan::math::assign(Finv, ssm_update_Finv(P, Z_t, H_t, pstream__));
            current_statement_begin__ = 1469;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1470;
            stan::math::assign(ll, ssm_update_loglik(v, Finv, pstream__));
            current_statement_begin__ = 1472;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        ll, 
                        "assigning variable res");
            current_statement_begin__ = 1473;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        v, 
                        "assigning variable res");
            current_statement_begin__ = 1474;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(Finv, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1475;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        to_vector(K), 
                        "assigning variable res");
            current_statement_begin__ = 1476;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable res");
            current_statement_begin__ = 1477;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(P, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1479;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1480;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1481;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        }
        current_statement_begin__ = 1485;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_filter_miss(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                    const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                    const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                    const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                    const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                    const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                    const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                    const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                    const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                    const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                    const std::vector<int>& p_t,
                    const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1548;
        validate_non_negative_index("res", "ssm_filter_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), pstream__)", ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__));
        validate_non_negative_index("res", "size(y)", size(y));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > res(size(y), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), pstream__)));
        stan::math::initialize(res, DUMMY_VAR__);
        stan::math::fill(res, DUMMY_VAR__);
        current_statement_begin__ = 1549;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1550;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1551;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1552;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1555;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1556;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1557;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1558;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1563;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1564;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1565;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1566;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1567;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1568;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1569;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1570;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1572;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1573;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1574;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1575;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1576;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1577;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1578;
        validate_non_negative_index("idx", "6", 6);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(6, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 1579;
        stan::math::assign(idx, ssm_filter_idx(m, p, pstream__));
        current_statement_begin__ = 1580;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1581;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1582;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1583;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1584;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1585;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1586;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1587;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1588;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1589;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1590;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1591;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1592;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1593;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1595;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1596;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1598;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1599;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1601;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 1602;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 1604;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 1605;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 1607;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 1608;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 1610;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 1611;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                }
                current_statement_begin__ = 1613;
                if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                    current_statement_begin__ = 1614;
                    stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                }
            }
            current_statement_begin__ = 1618;
            stan::math::assign(v, ssm_update_v_miss(get_base1(y, t, "y", 1), a, d_t, Z_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1619;
            stan::math::assign(Finv, ssm_update_Finv_miss(P, Z_t, H_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1620;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1621;
            stan::math::assign(ll, ssm_update_loglik_miss(v, Finv, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1623;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        ll, 
                        "assigning variable res");
            current_statement_begin__ = 1624;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        v, 
                        "assigning variable res");
            current_statement_begin__ = 1625;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 3, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 3, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(Finv, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1626;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 4, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 4, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        to_vector(K), 
                        "assigning variable res");
            current_statement_begin__ = 1627;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 5, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 5, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable res");
            current_statement_begin__ = 1628;
            stan::model::assign(res, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 6, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 6, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        symmat_to_vector(P, pstream__), 
                        "assigning variable res");
            current_statement_begin__ = 1630;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1631;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1632;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        }
        current_statement_begin__ = 1636;
        return stan::math::promote_scalar<fun_return_scalar_t__>(res);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_filter_miss_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                    const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                    const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                    const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                    const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                    const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                    const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                    const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                    const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                    const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                    const std::vector<int>& p_t,
                    const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) const {
        return ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1694;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1695;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1696;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1697;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1698;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1699;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1700;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1701;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1702;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1705;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1706;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1707;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1708;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1709;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1710;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1711;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1712;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1714;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1715;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1716;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1717;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1718;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1719;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1721;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1722;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1723;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1724;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1725;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1726;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1727;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1728;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1730;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1731;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1732;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1733;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1734;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1735;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1737;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1738;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1740;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1741;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1743;
                if (as_bool(logical_lt(t, n))) {
                    current_statement_begin__ = 1744;
                    if (as_bool(logical_gt(size(c), 1))) {
                        current_statement_begin__ = 1745;
                        stan::math::assign(c_t, get_base1(c, t, "c", 1));
                    }
                    current_statement_begin__ = 1747;
                    if (as_bool(logical_gt(size(T), 1))) {
                        current_statement_begin__ = 1748;
                        stan::math::assign(T_t, get_base1(T, t, "T", 1));
                    }
                    current_statement_begin__ = 1750;
                    if (as_bool(logical_gt(size(R), 1))) {
                        current_statement_begin__ = 1751;
                        stan::math::assign(R_t, get_base1(R, t, "R", 1));
                    }
                    current_statement_begin__ = 1753;
                    if (as_bool(logical_gt(size(Q), 1))) {
                        current_statement_begin__ = 1754;
                        stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    }
                    current_statement_begin__ = 1756;
                    if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                        current_statement_begin__ = 1757;
                        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                    }
                }
            }
            current_statement_begin__ = 1761;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d_t, Z_t, pstream__));
            current_statement_begin__ = 1762;
            stan::math::assign(Finv, ssm_update_Finv(P, Z_t, H_t, pstream__));
            current_statement_begin__ = 1763;
            stan::math::assign(K, ssm_update_K(P, T_t, Z_t, Finv, pstream__));
            current_statement_begin__ = 1764;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik(v, Finv, pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 1766;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1767;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1768;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        current_statement_begin__ = 1771;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 1773;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}
struct ssm_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
             const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
             const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
             const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
             const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
             const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
             const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
             const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
             const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_miss_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1812;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1813;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1814;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1815;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1816;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 1817;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1818;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 1819;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 1820;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 1823;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 1824;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 1825;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 1826;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 1827;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 1828;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 1829;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 1830;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 1832;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1833;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1834;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 1835;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 1836;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 1837;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 1839;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 1840;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 1841;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 1842;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 1843;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 1844;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 1845;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 1846;
        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
        current_statement_begin__ = 1848;
        stan::math::assign(a, a1);
        current_statement_begin__ = 1849;
        stan::math::assign(P, P1);
        current_statement_begin__ = 1850;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 1851;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 1852;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 1853;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 1855;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 1856;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 1858;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 1859;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                }
                current_statement_begin__ = 1861;
                if (as_bool(logical_lt(t, n))) {
                    current_statement_begin__ = 1862;
                    if (as_bool(logical_gt(size(c), 1))) {
                        current_statement_begin__ = 1863;
                        stan::math::assign(c_t, get_base1(c, t, "c", 1));
                    }
                    current_statement_begin__ = 1865;
                    if (as_bool(logical_gt(size(T), 1))) {
                        current_statement_begin__ = 1866;
                        stan::math::assign(T_t, get_base1(T, t, "T", 1));
                    }
                    current_statement_begin__ = 1868;
                    if (as_bool(logical_gt(size(R), 1))) {
                        current_statement_begin__ = 1869;
                        stan::math::assign(R_t, get_base1(R, t, "R", 1));
                    }
                    current_statement_begin__ = 1871;
                    if (as_bool(logical_gt(size(Q), 1))) {
                        current_statement_begin__ = 1872;
                        stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    }
                    current_statement_begin__ = 1874;
                    if (as_bool((primitive_value(logical_gt(size(R), 1)) || primitive_value(logical_gt(size(Q), 1))))) {
                        current_statement_begin__ = 1875;
                        stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
                    }
                }
            }
            current_statement_begin__ = 1879;
            stan::math::assign(v, ssm_update_v_miss(get_base1(y, t, "y", 1), a, d_t, Z_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1880;
            stan::math::assign(Finv, ssm_update_Finv_miss(P, Z_t, H_t, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__));
            current_statement_begin__ = 1881;
            stan::math::assign(K, ssm_update_K(P, Z_t, T_t, Finv, pstream__));
            current_statement_begin__ = 1882;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik_miss(v, Finv, get_base1(p_t, t, "p_t", 1), get_base1(y_idx, t, "y_idx", 1), pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 1884;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 1885;
                stan::math::assign(a, ssm_update_a(a, c_t, T_t, v, K, pstream__));
                current_statement_begin__ = 1886;
                stan::math::assign(P, ssm_update_P(P, Z_t, T_t, RQR, K, pstream__));
            }
        }
        current_statement_begin__ = 1889;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 1891;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_miss_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) {
    return ssm_miss_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1,p_t,y_idx, pstream__);
}
struct ssm_miss_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                  const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                  const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                  const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                  const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                  const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                  const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                  const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                  const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                  const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                  const std::vector<int>& p_t,
                  const std::vector<std::vector<int> >& y_idx, std::ostream* pstream__) const {
        return ssm_miss_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__);
    }
};
template <typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__, T1__>::type
matrix_diff(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1919;
        local_scalar_t__ eps(DUMMY_VAR__);
        (void) eps;  // dummy to suppress unused var warning
        stan::math::initialize(eps, DUMMY_VAR__);
        stan::math::fill(eps, DUMMY_VAR__);
        current_statement_begin__ = 1920;
        local_scalar_t__ norm_AB(DUMMY_VAR__);
        (void) norm_AB;  // dummy to suppress unused var warning
        stan::math::initialize(norm_AB, DUMMY_VAR__);
        stan::math::fill(norm_AB, DUMMY_VAR__);
        current_statement_begin__ = 1921;
        local_scalar_t__ norm_A(DUMMY_VAR__);
        (void) norm_A;  // dummy to suppress unused var warning
        stan::math::initialize(norm_A, DUMMY_VAR__);
        stan::math::fill(norm_A, DUMMY_VAR__);
        current_statement_begin__ = 1922;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 1923;
        local_scalar_t__ ab(DUMMY_VAR__);
        (void) ab;  // dummy to suppress unused var warning
        stan::math::initialize(ab, DUMMY_VAR__);
        stan::math::fill(ab, DUMMY_VAR__);
        current_statement_begin__ = 1924;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1925;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1926;
        stan::math::assign(m, rows(A));
        current_statement_begin__ = 1927;
        stan::math::assign(n, cols(A));
        current_statement_begin__ = 1928;
        stan::math::assign(eps, 0.0);
        current_statement_begin__ = 1929;
        stan::math::assign(norm_A, 0.0);
        current_statement_begin__ = 1930;
        stan::math::assign(norm_AB, 0.0);
        current_statement_begin__ = 1931;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 1932;
            for (int j = 1; j <= n; ++j) {
                current_statement_begin__ = 1933;
                stan::math::assign(a, stan::math::fabs(get_base1(A, i, j, "A", 1)));
                current_statement_begin__ = 1934;
                stan::math::assign(ab, stan::math::fabs((get_base1(A, i, j, "A", 1) - get_base1(B, i, j, "B", 1))));
                current_statement_begin__ = 1935;
                if (as_bool(logical_gt(a, norm_A))) {
                    current_statement_begin__ = 1936;
                    stan::math::assign(norm_A, a);
                }
                current_statement_begin__ = 1938;
                if (as_bool(logical_gt(ab, norm_AB))) {
                    current_statement_begin__ = 1939;
                    stan::math::assign(norm_AB, ab);
                }
            }
        }
        current_statement_begin__ = 1943;
        stan::math::assign(eps, (norm_AB / norm_A));
        current_statement_begin__ = 1944;
        return stan::math::promote_scalar<fun_return_scalar_t__>(eps);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct matrix_diff_functor__ {
    template <typename T0__, typename T1__>
        typename boost::math::tools::promote_args<T0__, T1__>::type
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return matrix_diff(A, B, pstream__);
    }
};
template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 1989;
        local_scalar_t__ ll(DUMMY_VAR__);
        (void) ll;  // dummy to suppress unused var warning
        stan::math::initialize(ll, DUMMY_VAR__);
        stan::math::fill(ll, DUMMY_VAR__);
        current_statement_begin__ = 1990;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 1991;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 1992;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 1994;
        stan::math::assign(n, size(y));
        current_statement_begin__ = 1995;
        stan::math::assign(m, cols(Z));
        current_statement_begin__ = 1996;
        stan::math::assign(p, rows(Z));
        {
        current_statement_begin__ = 1998;
        validate_non_negative_index("ll_obs", "n", n);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> ll_obs(n);
        stan::math::initialize(ll_obs, DUMMY_VAR__);
        stan::math::fill(ll_obs, DUMMY_VAR__);
        current_statement_begin__ = 1999;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2000;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2001;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2002;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2003;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2004;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2007;
        int converged(0);
        (void) converged;  // dummy to suppress unused var warning
        stan::math::fill(converged, std::numeric_limits<int>::min());
        current_statement_begin__ = 2008;
        validate_non_negative_index("P_old", "m", m);
        validate_non_negative_index("P_old", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P_old(m, m);
        stan::math::initialize(P_old, DUMMY_VAR__);
        stan::math::fill(P_old, DUMMY_VAR__);
        current_statement_begin__ = 2009;
        local_scalar_t__ tol(DUMMY_VAR__);
        (void) tol;  // dummy to suppress unused var warning
        stan::math::initialize(tol, DUMMY_VAR__);
        stan::math::fill(tol, DUMMY_VAR__);
        current_statement_begin__ = 2010;
        local_scalar_t__ matdiff(DUMMY_VAR__);
        (void) matdiff;  // dummy to suppress unused var warning
        stan::math::initialize(matdiff, DUMMY_VAR__);
        stan::math::fill(matdiff, DUMMY_VAR__);
        current_statement_begin__ = 2011;
        stan::math::assign(converged, 0);
        current_statement_begin__ = 2012;
        stan::math::assign(tol, 1e-7);
        current_statement_begin__ = 2014;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2015;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2016;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2017;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2018;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2019;
            if (as_bool(logical_lt(converged, 1))) {
                current_statement_begin__ = 2020;
                stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
                current_statement_begin__ = 2021;
                stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            }
            current_statement_begin__ = 2023;
            stan::model::assign(ll_obs, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        ssm_update_loglik(v, Finv, pstream__), 
                        "assigning variable ll_obs");
            current_statement_begin__ = 2025;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 2026;
                stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
                current_statement_begin__ = 2029;
                if (as_bool(logical_lt(converged, 1))) {
                    current_statement_begin__ = 2030;
                    stan::math::assign(P_old, P);
                    current_statement_begin__ = 2031;
                    stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
                    current_statement_begin__ = 2032;
                    stan::math::assign(matdiff, matrix_diff(P, P_old, pstream__));
                    current_statement_begin__ = 2033;
                    if (as_bool(logical_lt(matdiff, tol))) {
                        current_statement_begin__ = 2034;
                        stan::math::assign(converged, 1);
                    }
                }
            }
        }
        current_statement_begin__ = 2039;
        stan::math::assign(ll, sum(ll_obs));
        }
        current_statement_begin__ = 2041;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ll);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
ssm_constant_lpdf(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) {
    return ssm_constant_lpdf<false>(y,d,Z,H,c,T,R,Q,a1,P1, pstream__);
}
struct ssm_constant_lpdf_functor__ {
    template <bool propto, typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
                      const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
                      const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
                      const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
                      const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
                      const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
                      const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
                      const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
                      const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                      const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, std::ostream* pstream__) const {
        return ssm_constant_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
predict(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
            const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
            const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
            const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
            const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
            const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
            const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
            const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
            const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
            const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
            const int& steps_ahead, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2049;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        stan::math::assign(m,cols(Z));
        current_statement_begin__ = 2050;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        stan::math::assign(n,size(y));
        current_statement_begin__ = 2051;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        stan::math::assign(p,rows(Z));
        current_statement_begin__ = 2053;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2054;
        validate_non_negative_index("F", "p", p);
        validate_non_negative_index("F", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> F(p, p);
        stan::math::initialize(F, DUMMY_VAR__);
        stan::math::fill(F, DUMMY_VAR__);
        current_statement_begin__ = 2055;
        validate_non_negative_index("P", "m", m);
        validate_non_negative_index("P", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(m, m);
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        {
        current_statement_begin__ = 2057;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2058;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2059;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2060;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2062;
        stan::math::assign(RQR, quad_form_sym(Q, transpose(R)));
        current_statement_begin__ = 2063;
        stan::math::assign(a, a1);
        current_statement_begin__ = 2064;
        stan::math::assign(P, P1);
        current_statement_begin__ = 2065;
        for (int t = 1; t <= ((n + steps_ahead) - 1); ++t) {
            current_statement_begin__ = 2066;
            stan::math::assign(v, ssm_update_v(get_base1(y, t, "y", 1), a, d, Z, pstream__));
            current_statement_begin__ = 2067;
            stan::math::assign(Finv, ssm_update_Finv(P, Z, H, pstream__));
            current_statement_begin__ = 2068;
            stan::math::assign(K, ssm_update_K(P, Z, T, Finv, pstream__));
            current_statement_begin__ = 2069;
            stan::math::assign(a, ssm_update_a(a, c, T, v, K, pstream__));
            current_statement_begin__ = 2070;
            stan::math::assign(P, ssm_update_P(P, Z, T, RQR, K, pstream__));
        }
        current_statement_begin__ = 2072;
        stan::math::assign(F, ssm_update_F(P, Z, H, pstream__));
        }
        current_statement_begin__ = 2076;
        return stan::math::promote_scalar<fun_return_scalar_t__>(append_col(to_matrix(multiply(Z, a)), F));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct predict_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& y,
            const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& d,
            const Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic>& Z,
            const Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic>& H,
            const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& c,
            const Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic>& T,
            const Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic>& R,
            const Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic>& Q,
            const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
            const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
            const int& steps_ahead, std::ostream* pstream__) const {
        return predict(y, d, Z, H, c, T, R, Q, a1, P1, steps_ahead, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic, 1> >
ssm_smooth_states_mean(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                           const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                           const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, 1> >& c,
                           const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                           const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                           const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& Q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2123;
        validate_non_negative_index("alpha", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("alpha", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(alpha, DUMMY_VAR__);
        stan::math::fill(alpha, DUMMY_VAR__);
        current_statement_begin__ = 2124;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2125;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2126;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2127;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2128;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 2129;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2130;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2131;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2133;
        validate_non_negative_index("r", "m", m);
        validate_non_negative_index("r", "(n + 1)", (n + 1));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > r((n + 1), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 2134;
        validate_non_negative_index("u", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> u(p);
        stan::math::initialize(u, DUMMY_VAR__);
        stan::math::fill(u, DUMMY_VAR__);
        current_statement_begin__ = 2135;
        validate_non_negative_index("a1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a1(m);
        stan::math::initialize(a1, DUMMY_VAR__);
        stan::math::fill(a1, DUMMY_VAR__);
        current_statement_begin__ = 2136;
        validate_non_negative_index("P1", "m", m);
        validate_non_negative_index("P1", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
        stan::math::initialize(P1, DUMMY_VAR__);
        stan::math::fill(P1, DUMMY_VAR__);
        current_statement_begin__ = 2138;
        validate_non_negative_index("v", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> v(p);
        stan::math::initialize(v, DUMMY_VAR__);
        stan::math::fill(v, DUMMY_VAR__);
        current_statement_begin__ = 2139;
        validate_non_negative_index("K", "m", m);
        validate_non_negative_index("K", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> K(m, p);
        stan::math::initialize(K, DUMMY_VAR__);
        stan::math::fill(K, DUMMY_VAR__);
        current_statement_begin__ = 2140;
        validate_non_negative_index("Finv", "p", p);
        validate_non_negative_index("Finv", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Finv(p, p);
        stan::math::initialize(Finv, DUMMY_VAR__);
        stan::math::fill(Finv, DUMMY_VAR__);
        current_statement_begin__ = 2142;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 2143;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 2144;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 2145;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 2146;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 2147;
        validate_non_negative_index("RQR", "m", m);
        validate_non_negative_index("RQR", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> RQR(m, m);
        stan::math::initialize(RQR, DUMMY_VAR__);
        stan::math::fill(RQR, DUMMY_VAR__);
        current_statement_begin__ = 2149;
        if (as_bool(logical_eq(size(c), 1))) {
            current_statement_begin__ = 2150;
            stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        }
        current_statement_begin__ = 2152;
        if (as_bool(logical_eq(size(Z), 1))) {
            current_statement_begin__ = 2153;
            stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        }
        current_statement_begin__ = 2155;
        if (as_bool(logical_eq(size(T), 1))) {
            current_statement_begin__ = 2156;
            stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        }
        current_statement_begin__ = 2158;
        if (as_bool(logical_eq(size(R), 1))) {
            current_statement_begin__ = 2159;
            stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        }
        current_statement_begin__ = 2161;
        if (as_bool(logical_eq(size(Q), 1))) {
            current_statement_begin__ = 2162;
            stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        }
        current_statement_begin__ = 2164;
        if (as_bool((primitive_value(logical_eq(size(Q), 1)) && primitive_value(logical_eq(size(R), 1))))) {
            current_statement_begin__ = 2165;
            stan::math::assign(RQR, quad_form_sym(get_base1(Q, 1, "Q", 1), transpose(get_base1(R, 1, "R", 1))));
        }
        current_statement_begin__ = 2174;
        stan::model::assign(r, 
                    stan::model::cons_list(stan::model::index_uni((n + 1)), stan::model::nil_index_list()), 
                    rep_vector(0.0, m), 
                    "assigning variable r");
        current_statement_begin__ = 2175;
        for (int s = 0; s <= (n - 1); ++s) {
            {
            current_statement_begin__ = 2176;
            int t(0);
            (void) t;  // dummy to suppress unused var warning
            stan::math::fill(t, std::numeric_limits<int>::min());
            current_statement_begin__ = 2178;
            stan::math::assign(t, (n - s));
            current_statement_begin__ = 2180;
            if (as_bool(logical_gt(size(Z), 1))) {
                current_statement_begin__ = 2181;
                stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
            }
            current_statement_begin__ = 2183;
            if (as_bool(logical_gt(size(T), 1))) {
                current_statement_begin__ = 2184;
                stan::math::assign(T_t, get_base1(T, t, "T", 1));
            }
            current_statement_begin__ = 2187;
            stan::math::assign(K, ssm_filter_get_K(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2188;
            stan::math::assign(v, ssm_filter_get_v(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2189;
            stan::math::assign(Finv, ssm_filter_get_Finv(get_base1(filter, t, "filter", 1), m, p, pstream__));
            current_statement_begin__ = 2191;
            stan::math::assign(u, subtract(multiply(Finv, v), multiply(transpose(K), get_base1(r, (t + 1), "r", 1))));
            current_statement_begin__ = 2193;
            stan::model::assign(r, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::nil_index_list()), 
                        add(multiply(transpose(Z_t), u), multiply(transpose(T_t), get_base1(r, (t + 1), "r", 1))), 
                        "assigning variable r");
            }
        }
        current_statement_begin__ = 2196;
        stan::math::assign(a1, ssm_filter_get_a(get_base1(filter, 1, "filter", 1), m, p, pstream__));
        current_statement_begin__ = 2197;
        stan::math::assign(P1, ssm_filter_get_P(get_base1(filter, 1, "filter", 1), m, p, pstream__));
        current_statement_begin__ = 2199;
        stan::model::assign(alpha, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list()), 
                    add(a1, multiply(P1, get_base1(r, 1, "r", 1))), 
                    "assigning variable alpha");
        current_statement_begin__ = 2201;
        for (int t = 1; t <= (n - 1); ++t) {
            current_statement_begin__ = 2202;
            if (as_bool(logical_gt(size(c), 1))) {
                current_statement_begin__ = 2203;
                stan::math::assign(c_t, get_base1(c, t, "c", 1));
            }
            current_statement_begin__ = 2205;
            if (as_bool(logical_gt(size(T), 1))) {
                current_statement_begin__ = 2206;
                stan::math::assign(T_t, get_base1(T, t, "T", 1));
            }
            current_statement_begin__ = 2208;
            if (as_bool(logical_gt(size(Q), 1))) {
                current_statement_begin__ = 2209;
                stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
            }
            current_statement_begin__ = 2211;
            if (as_bool(logical_gt(size(R), 1))) {
                current_statement_begin__ = 2212;
                stan::math::assign(R_t, get_base1(R, t, "R", 1));
            }
            current_statement_begin__ = 2214;
            if (as_bool((primitive_value(logical_gt(size(Q), 1)) || primitive_value(logical_gt(size(R), 1))))) {
                current_statement_begin__ = 2215;
                stan::math::assign(RQR, quad_form_sym(Q_t, transpose(R_t)));
            }
            current_statement_begin__ = 2219;
            stan::model::assign(alpha, 
                        stan::model::cons_list(stan::model::index_uni((t + 1)), stan::model::nil_index_list()), 
                        add(add(c_t, multiply(T_t, get_base1(alpha, t, "alpha", 1))), multiply(RQR, get_base1(r, (t + 1), "r", 1))), 
                        "assigning variable alpha");
        }
        }
        current_statement_begin__ = 2222;
        return stan::math::promote_scalar<fun_return_scalar_t__>(alpha);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_smooth_states_mean_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                           const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                           const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, 1> >& c,
                           const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                           const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                           const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& Q, std::ostream* pstream__) const {
        return ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__);
    }
};
std::vector<std::vector<int> >
ssm_sim_idx(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2253;
        validate_non_negative_index("sz", "2", 2);
        validate_non_negative_index("sz", "3", 3);
        std::vector<std::vector<int  >  > sz(2, std::vector<int>(3, int(0)));
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 2255;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    p, 
                    "assigning variable sz");
        current_statement_begin__ = 2257;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                    m, 
                    "assigning variable sz");
        current_statement_begin__ = 2259;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    1, 
                    "assigning variable sz");
        current_statement_begin__ = 2260;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 1, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 1, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2261;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(2), stan::model::nil_index_list())), 
                    (get_base1(get_base1(sz, (2 - 1), "sz", 1), 3, "sz", 2) + 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2262;
        stan::model::assign(sz, 
                    stan::model::cons_list(stan::model::index_uni(2), stan::model::cons_list(stan::model::index_uni(3), stan::model::nil_index_list())), 
                    ((get_base1(get_base1(sz, 2, "sz", 1), 2, "sz", 2) + get_base1(get_base1(sz, 2, "sz", 1), 1, "sz", 2)) - 1), 
                    "assigning variable sz");
        current_statement_begin__ = 2263;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_idx_functor__ {
            std::vector<std::vector<int> >
    operator()(const int& m,
                const int& p,
                const int& q, std::ostream* pstream__) const {
        return ssm_sim_idx(m, p, q, pstream__);
    }
};
int
ssm_sim_size(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) {
    typedef double local_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2286;
        int sz(0);
        (void) sz;  // dummy to suppress unused var warning
        stan::math::fill(sz, std::numeric_limits<int>::min());
        current_statement_begin__ = 2287;
        stan::math::assign(sz, get_base1(get_base1(ssm_sim_idx(m, p, q, pstream__), 2, "ssm_sim_idx(m, p, q, pstream__)", 1), 3, "ssm_sim_idx(m, p, q, pstream__)", 2));
        current_statement_begin__ = 2288;
        return stan::math::promote_scalar<fun_return_scalar_t__>(sz);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_size_functor__ {
            int
    operator()(const int& m,
                 const int& p,
                 const int& q, std::ostream* pstream__) const {
        return ssm_sim_size(m, p, q, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_sim_get_y(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2311;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2312;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2313;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2314;
        stan::math::assign(y, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 1, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 1, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list()), "x"));
        current_statement_begin__ = 2315;
        return stan::math::promote_scalar<fun_return_scalar_t__>(y);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_get_y_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_y(x, m, p, q, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
ssm_sim_get_a(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2338;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2339;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2340;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2341;
        stan::math::assign(a, stan::model::rvalue(x, stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list()), "x"));
        current_statement_begin__ = 2342;
        return stan::math::promote_scalar<fun_return_scalar_t__>(a);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_get_a_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x,
                  const int& m,
                  const int& p,
                  const int& q, std::ostream* pstream__) const {
        return ssm_sim_get_a(x, m, p, q, pstream__);
    }
};
template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_sim_rng(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2408;
        validate_non_negative_index("ret", "ssm_sim_size(get_base1(dims(Z), 3, \"dims(Z)\", 1), get_base1(dims(Z), 2, \"dims(Z)\", 1), get_base1(dims(Q), 2, \"dims(Q)\", 1), pstream__)", ssm_sim_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), get_base1(dims(Q), 2, "dims(Q)", 1), pstream__));
        validate_non_negative_index("ret", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > ret(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(get_base1(dims(Z), 3, "dims(Z)", 1), get_base1(dims(Z), 2, "dims(Z)", 1), get_base1(dims(Q), 2, "dims(Q)", 1), pstream__)));
        stan::math::initialize(ret, DUMMY_VAR__);
        stan::math::fill(ret, DUMMY_VAR__);
        current_statement_begin__ = 2409;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2410;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2411;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2412;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2413;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2414;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2417;
        validate_non_negative_index("d_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> d_t(p);
        stan::math::initialize(d_t, DUMMY_VAR__);
        stan::math::fill(d_t, DUMMY_VAR__);
        current_statement_begin__ = 2418;
        validate_non_negative_index("Z_t", "p", p);
        validate_non_negative_index("Z_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Z_t(p, m);
        stan::math::initialize(Z_t, DUMMY_VAR__);
        stan::math::fill(Z_t, DUMMY_VAR__);
        current_statement_begin__ = 2419;
        validate_non_negative_index("H_t", "p", p);
        validate_non_negative_index("H_t", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H_t(p, p);
        stan::math::initialize(H_t, DUMMY_VAR__);
        stan::math::fill(H_t, DUMMY_VAR__);
        current_statement_begin__ = 2420;
        validate_non_negative_index("HL", "p", p);
        validate_non_negative_index("HL", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> HL(p, p);
        stan::math::initialize(HL, DUMMY_VAR__);
        stan::math::fill(HL, DUMMY_VAR__);
        current_statement_begin__ = 2421;
        validate_non_negative_index("c_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> c_t(m);
        stan::math::initialize(c_t, DUMMY_VAR__);
        stan::math::fill(c_t, DUMMY_VAR__);
        current_statement_begin__ = 2422;
        validate_non_negative_index("T_t", "m", m);
        validate_non_negative_index("T_t", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T_t(m, m);
        stan::math::initialize(T_t, DUMMY_VAR__);
        stan::math::fill(T_t, DUMMY_VAR__);
        current_statement_begin__ = 2423;
        validate_non_negative_index("R_t", "m", m);
        validate_non_negative_index("R_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R_t(m, q);
        stan::math::initialize(R_t, DUMMY_VAR__);
        stan::math::fill(R_t, DUMMY_VAR__);
        current_statement_begin__ = 2424;
        validate_non_negative_index("Q_t", "q", q);
        validate_non_negative_index("Q_t", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q_t(q, q);
        stan::math::initialize(Q_t, DUMMY_VAR__);
        stan::math::fill(Q_t, DUMMY_VAR__);
        current_statement_begin__ = 2425;
        validate_non_negative_index("QL", "q", q);
        validate_non_negative_index("QL", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> QL(q, q);
        stan::math::initialize(QL, DUMMY_VAR__);
        stan::math::fill(QL, DUMMY_VAR__);
        current_statement_begin__ = 2427;
        validate_non_negative_index("y", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> y(p);
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2428;
        validate_non_negative_index("eps", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eps(p);
        stan::math::initialize(eps, DUMMY_VAR__);
        stan::math::fill(eps, DUMMY_VAR__);
        current_statement_begin__ = 2429;
        validate_non_negative_index("a", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a(m);
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2430;
        validate_non_negative_index("eta", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> eta(q);
        stan::math::initialize(eta, DUMMY_VAR__);
        stan::math::fill(eta, DUMMY_VAR__);
        current_statement_begin__ = 2432;
        validate_non_negative_index("zero_p", "p", p);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_p(p);
        stan::math::initialize(zero_p, DUMMY_VAR__);
        stan::math::fill(zero_p, DUMMY_VAR__);
        current_statement_begin__ = 2433;
        validate_non_negative_index("zero_q", "q", q);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_q(q);
        stan::math::initialize(zero_q, DUMMY_VAR__);
        stan::math::fill(zero_q, DUMMY_VAR__);
        current_statement_begin__ = 2434;
        validate_non_negative_index("zero_m", "m", m);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> zero_m(m);
        stan::math::initialize(zero_m, DUMMY_VAR__);
        stan::math::fill(zero_m, DUMMY_VAR__);
        current_statement_begin__ = 2435;
        validate_non_negative_index("idx", "2", 2);
        validate_non_negative_index("idx", "3", 3);
        std::vector<std::vector<int  >  > idx(2, std::vector<int>(3, int(0)));
        stan::math::fill(idx, std::numeric_limits<int>::min());
        current_statement_begin__ = 2437;
        stan::math::assign(d_t, get_base1(d, 1, "d", 1));
        current_statement_begin__ = 2438;
        stan::math::assign(Z_t, get_base1(Z, 1, "Z", 1));
        current_statement_begin__ = 2439;
        stan::math::assign(H_t, get_base1(H, 1, "H", 1));
        current_statement_begin__ = 2440;
        stan::math::assign(HL, cholesky_decompose2(H_t, pstream__));
        current_statement_begin__ = 2441;
        stan::math::assign(c_t, get_base1(c, 1, "c", 1));
        current_statement_begin__ = 2442;
        stan::math::assign(T_t, get_base1(T, 1, "T", 1));
        current_statement_begin__ = 2443;
        stan::math::assign(R_t, get_base1(R, 1, "R", 1));
        current_statement_begin__ = 2444;
        stan::math::assign(Q_t, get_base1(Q, 1, "Q", 1));
        current_statement_begin__ = 2445;
        stan::math::assign(QL, cholesky_decompose2(Q_t, pstream__));
        current_statement_begin__ = 2447;
        stan::math::assign(idx, ssm_sim_idx(m, p, q, pstream__));
        current_statement_begin__ = 2448;
        stan::math::assign(zero_p, rep_vector(0.0, p));
        current_statement_begin__ = 2449;
        stan::math::assign(zero_q, rep_vector(0.0, q));
        current_statement_begin__ = 2450;
        stan::math::assign(zero_m, rep_vector(0.0, m));
        current_statement_begin__ = 2451;
        stan::math::assign(a, multi_normal2_rng(a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 2452;
        for (int t = 1; t <= n; ++t) {
            current_statement_begin__ = 2454;
            stan::model::assign(ret, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 2, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 2, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        a, 
                        "assigning variable ret");
            current_statement_begin__ = 2456;
            if (as_bool(logical_gt(t, 1))) {
                current_statement_begin__ = 2457;
                if (as_bool(logical_gt(size(d), 1))) {
                    current_statement_begin__ = 2458;
                    stan::math::assign(d_t, get_base1(d, t, "d", 1));
                }
                current_statement_begin__ = 2460;
                if (as_bool(logical_gt(size(Z), 1))) {
                    current_statement_begin__ = 2461;
                    stan::math::assign(Z_t, get_base1(Z, t, "Z", 1));
                }
                current_statement_begin__ = 2463;
                if (as_bool(logical_gt(size(H), 1))) {
                    current_statement_begin__ = 2464;
                    stan::math::assign(H_t, get_base1(H, t, "H", 1));
                    current_statement_begin__ = 2465;
                    stan::math::assign(HL, cholesky_decompose2(H_t, pstream__));
                }
            }
            current_statement_begin__ = 2469;
            stan::math::assign(eps, multi_normal_cholesky2_rng(zero_p, HL, base_rng__, pstream__));
            current_statement_begin__ = 2470;
            stan::math::assign(y, add(add(d_t, multiply(Z_t, a)), eps));
            current_statement_begin__ = 2472;
            stan::model::assign(ret, 
                        stan::model::cons_list(stan::model::index_uni(t), stan::model::cons_list(stan::model::index_min_max(get_base1(get_base1(idx, 1, "idx", 1), 2, "idx", 2), get_base1(get_base1(idx, 1, "idx", 1), 3, "idx", 2)), stan::model::nil_index_list())), 
                        y, 
                        "assigning variable ret");
            current_statement_begin__ = 2474;
            if (as_bool(logical_lt(t, n))) {
                current_statement_begin__ = 2475;
                if (as_bool(logical_gt(size(c), 1))) {
                    current_statement_begin__ = 2476;
                    stan::math::assign(c_t, get_base1(c, t, "c", 1));
                }
                current_statement_begin__ = 2478;
                if (as_bool(logical_gt(size(T), 1))) {
                    current_statement_begin__ = 2479;
                    stan::math::assign(T_t, get_base1(T, t, "T", 1));
                }
                current_statement_begin__ = 2481;
                if (as_bool(logical_gt(size(R), 1))) {
                    current_statement_begin__ = 2482;
                    stan::math::assign(R_t, get_base1(R, t, "R", 1));
                }
                current_statement_begin__ = 2484;
                if (as_bool(logical_gt(size(Q), 1))) {
                    current_statement_begin__ = 2485;
                    stan::math::assign(Q_t, get_base1(Q, t, "Q", 1));
                    current_statement_begin__ = 2486;
                    stan::math::assign(QL, cholesky_decompose2(Q_t, pstream__));
                }
                current_statement_begin__ = 2488;
                stan::math::assign(eta, multi_normal_cholesky2_rng(zero_q, QL, base_rng__, pstream__));
                current_statement_begin__ = 2489;
                stan::math::assign(a, add(add(c_t, multiply(T_t, a)), multiply(R_t, eta)));
            }
        }
        }
        current_statement_begin__ = 2493;
        return stan::math::promote_scalar<fun_return_scalar_t__>(ret);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_sim_rng_functor__ {
    template <typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T1__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const int& n,
                const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_simsmo_states_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2547;
        validate_non_negative_index("draws", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("draws", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > draws(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(draws, DUMMY_VAR__);
        stan::math::fill(draws, DUMMY_VAR__);
        current_statement_begin__ = 2548;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2549;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2550;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2551;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2552;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 2553;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2554;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2555;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2557;
        validate_non_negative_index("filter_plus", "ssm_filter_size(m, p, pstream__)", ssm_filter_size(m, p, pstream__));
        validate_non_negative_index("filter_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > filter_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(m, p, pstream__)));
        stan::math::initialize(filter_plus, DUMMY_VAR__);
        stan::math::fill(filter_plus, DUMMY_VAR__);
        current_statement_begin__ = 2558;
        validate_non_negative_index("sims", "ssm_sim_size(m, p, q, pstream__)", ssm_sim_size(m, p, q, pstream__));
        validate_non_negative_index("sims", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > sims(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(m, p, q, pstream__)));
        stan::math::initialize(sims, DUMMY_VAR__);
        stan::math::fill(sims, DUMMY_VAR__);
        current_statement_begin__ = 2559;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > y(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(p));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2560;
        validate_non_negative_index("alpha_hat_plus", "m", m);
        validate_non_negative_index("alpha_hat_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat_plus, DUMMY_VAR__);
        stan::math::fill(alpha_hat_plus, DUMMY_VAR__);
        current_statement_begin__ = 2561;
        validate_non_negative_index("alpha_hat", "m", m);
        validate_non_negative_index("alpha_hat", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat, DUMMY_VAR__);
        stan::math::fill(alpha_hat, DUMMY_VAR__);
        current_statement_begin__ = 2563;
        stan::math::assign(alpha_hat, ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 2565;
        stan::math::assign(sims, ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 2566;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2567;
            stan::model::assign(y, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ssm_sim_get_y(get_base1(sims, i, "sims", 1), m, p, q, pstream__), 
                        "assigning variable y");
        }
        current_statement_begin__ = 2570;
        stan::math::assign(filter_plus, ssm_filter(y, d, Z, H, c, T, R, Q, a1, P1, pstream__));
        current_statement_begin__ = 2572;
        stan::math::assign(alpha_hat_plus, ssm_smooth_states_mean(filter_plus, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 2573;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2574;
            stan::model::assign(draws, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        add(subtract(ssm_sim_get_a(get_base1(sims, i, "sims", 1), m, p, q, pstream__), get_base1(alpha_hat_plus, i, "alpha_hat_plus", 1)), get_base1(alpha_hat, i, "alpha_hat", 1)), 
                        "assigning variable draws");
        }
        }
        current_statement_begin__ = 2579;
        return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_simsmo_states_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                          const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                          const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                          const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                          const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                          const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                          const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                          const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                          const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                          const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_rng(filter, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__);
    }
};
template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
ssm_simsmo_states_miss_rng(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const std::vector<int>& p_t,
                               const std::vector<std::vector<int> >& y_idx, RNG& base_rng__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2625;
        validate_non_negative_index("draws", "get_base1(dims(Z), 3, \"dims(Z)\", 1)", get_base1(dims(Z), 3, "dims(Z)", 1));
        validate_non_negative_index("draws", "size(filter)", size(filter));
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > draws(size(filter), Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(get_base1(dims(Z), 3, "dims(Z)", 1)));
        stan::math::initialize(draws, DUMMY_VAR__);
        stan::math::fill(draws, DUMMY_VAR__);
        current_statement_begin__ = 2626;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2627;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2628;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2629;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2630;
        stan::math::assign(n, size(filter));
        current_statement_begin__ = 2631;
        stan::math::assign(m, get_base1(dims(Z), 3, "dims(Z)", 1));
        current_statement_begin__ = 2632;
        stan::math::assign(p, get_base1(dims(Z), 2, "dims(Z)", 1));
        current_statement_begin__ = 2633;
        stan::math::assign(q, get_base1(dims(Q), 2, "dims(Q)", 1));
        {
        current_statement_begin__ = 2635;
        validate_non_negative_index("filter_plus", "ssm_filter_size(m, p, pstream__)", ssm_filter_size(m, p, pstream__));
        validate_non_negative_index("filter_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > filter_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_filter_size(m, p, pstream__)));
        stan::math::initialize(filter_plus, DUMMY_VAR__);
        stan::math::fill(filter_plus, DUMMY_VAR__);
        current_statement_begin__ = 2636;
        validate_non_negative_index("sims", "ssm_sim_size(m, p, q, pstream__)", ssm_sim_size(m, p, q, pstream__));
        validate_non_negative_index("sims", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > sims(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(ssm_sim_size(m, p, q, pstream__)));
        stan::math::initialize(sims, DUMMY_VAR__);
        stan::math::fill(sims, DUMMY_VAR__);
        current_statement_begin__ = 2637;
        validate_non_negative_index("y", "p", p);
        validate_non_negative_index("y", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > y(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(p));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2638;
        validate_non_negative_index("alpha_hat_plus", "m", m);
        validate_non_negative_index("alpha_hat_plus", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat_plus(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat_plus, DUMMY_VAR__);
        stan::math::fill(alpha_hat_plus, DUMMY_VAR__);
        current_statement_begin__ = 2639;
        validate_non_negative_index("alpha_hat", "m", m);
        validate_non_negative_index("alpha_hat", "n", n);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>  > alpha_hat(n, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1>(m));
        stan::math::initialize(alpha_hat, DUMMY_VAR__);
        stan::math::fill(alpha_hat, DUMMY_VAR__);
        current_statement_begin__ = 2641;
        stan::math::assign(alpha_hat, ssm_smooth_states_mean(filter, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 2643;
        stan::math::assign(sims, ssm_sim_rng(n, d, Z, H, c, T, R, Q, a1, P1, base_rng__, pstream__));
        current_statement_begin__ = 2644;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2645;
            stan::model::assign(y, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        ssm_sim_get_y(get_base1(sims, i, "sims", 1), m, p, q, pstream__), 
                        "assigning variable y");
        }
        current_statement_begin__ = 2648;
        stan::math::assign(filter_plus, ssm_filter_miss(y, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, pstream__));
        current_statement_begin__ = 2651;
        stan::math::assign(alpha_hat_plus, ssm_smooth_states_mean(filter_plus, Z, c, T, R, Q, pstream__));
        current_statement_begin__ = 2652;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2653;
            stan::model::assign(draws, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        add(subtract(ssm_sim_get_a(get_base1(sims, i, "sims", 1), m, p, q, pstream__), get_base1(alpha_hat_plus, i, "alpha_hat_plus", 1)), get_base1(alpha_hat, i, "alpha_hat", 1)), 
                        "assigning variable draws");
        }
        }
        current_statement_begin__ = 2658;
        return stan::math::promote_scalar<fun_return_scalar_t__>(draws);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct ssm_simsmo_states_miss_rng_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, class RNG>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T5__, T6__, T7__, typename boost::math::tools::promote_args<T8__, T9__>::type>::type>::type, Eigen::Dynamic, 1> >
    operator()(const std::vector<Eigen::Matrix<T0__, Eigen::Dynamic, 1> >& filter,
                               const std::vector<Eigen::Matrix<T1__, Eigen::Dynamic, 1> >& d,
                               const std::vector<Eigen::Matrix<T2__, Eigen::Dynamic, Eigen::Dynamic> >& Z,
                               const std::vector<Eigen::Matrix<T3__, Eigen::Dynamic, Eigen::Dynamic> >& H,
                               const std::vector<Eigen::Matrix<T4__, Eigen::Dynamic, 1> >& c,
                               const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& T,
                               const std::vector<Eigen::Matrix<T6__, Eigen::Dynamic, Eigen::Dynamic> >& R,
                               const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic, Eigen::Dynamic> >& Q,
                               const Eigen::Matrix<T8__, Eigen::Dynamic, 1>& a1,
                               const Eigen::Matrix<T9__, Eigen::Dynamic, Eigen::Dynamic>& P1,
                               const std::vector<int>& p_t,
                               const std::vector<std::vector<int> >& y_idx, RNG& base_rng__, std::ostream* pstream__) const {
        return ssm_simsmo_states_miss_rng(filter, d, Z, H, c, T, R, Q, a1, P1, p_t, y_idx, base_rng__, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
pacf_to_acf(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2683;
        validate_non_negative_index("x_new", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> x_new(num_elements(x));
        stan::math::initialize(x_new, DUMMY_VAR__);
        stan::math::fill(x_new, DUMMY_VAR__);
        current_statement_begin__ = 2684;
        validate_non_negative_index("work", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> work(num_elements(x));
        stan::math::initialize(work, DUMMY_VAR__);
        stan::math::fill(work, DUMMY_VAR__);
        current_statement_begin__ = 2685;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2686;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2687;
        stan::math::assign(p, num_elements(x));
        current_statement_begin__ = 2688;
        stan::math::assign(work, x);
        current_statement_begin__ = 2689;
        stan::math::assign(x_new, x);
        current_statement_begin__ = 2690;
        if (as_bool(logical_gt(p, 1))) {
            current_statement_begin__ = 2691;
            for (int j = 2; j <= p; ++j) {
                current_statement_begin__ = 2692;
                stan::math::assign(a, get_base1(x_new, j, "x_new", 1));
                current_statement_begin__ = 2693;
                for (int k = 1; k <= (j - 1); ++k) {
                    current_statement_begin__ = 2694;
                    stan::model::assign(work, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                (get_base1(work, k, "work", 1) - (a * get_base1(x_new, (j - k), "x_new", 1))), 
                                "assigning variable work");
                }
                current_statement_begin__ = 2696;
                for (int k = 1; k <= j; ++k) {
                    current_statement_begin__ = 2697;
                    stan::model::assign(x_new, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                get_base1(work, k, "work", 1), 
                                "assigning variable x_new");
                }
            }
        }
        current_statement_begin__ = 2701;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct pacf_to_acf_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return pacf_to_acf(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
constrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2741;
        validate_non_negative_index("r", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r(num_elements(x));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 2742;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2743;
        stan::math::assign(n, num_elements(x));
        current_statement_begin__ = 2745;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2746;
            stan::model::assign(r, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        stan::math::tanh(get_base1(x, i, "x", 1)), 
                        "assigning variable r");
        }
        current_statement_begin__ = 2749;
        return stan::math::promote_scalar<fun_return_scalar_t__>(pacf_to_acf(r, pstream__));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct constrain_stationary_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return constrain_stationary(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
acf_to_pacf(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2770;
        validate_non_negative_index("x_new", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> x_new(num_elements(x));
        stan::math::initialize(x_new, DUMMY_VAR__);
        stan::math::fill(x_new, DUMMY_VAR__);
        current_statement_begin__ = 2771;
        validate_non_negative_index("work", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> work(num_elements(x));
        stan::math::initialize(work, DUMMY_VAR__);
        stan::math::fill(work, DUMMY_VAR__);
        current_statement_begin__ = 2772;
        local_scalar_t__ a(DUMMY_VAR__);
        (void) a;  // dummy to suppress unused var warning
        stan::math::initialize(a, DUMMY_VAR__);
        stan::math::fill(a, DUMMY_VAR__);
        current_statement_begin__ = 2773;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2774;
        stan::math::assign(p, num_elements(x));
        current_statement_begin__ = 2775;
        stan::math::assign(work, x);
        current_statement_begin__ = 2776;
        stan::math::assign(x_new, x);
        current_statement_begin__ = 2778;
        if (as_bool(logical_gt(p, 1))) {
            current_statement_begin__ = 2779;
            for (int i = 0; i <= (p - 2); ++i) {
                {
                current_statement_begin__ = 2780;
                int j(0);
                (void) j;  // dummy to suppress unused var warning
                stan::math::fill(j, std::numeric_limits<int>::min());
                current_statement_begin__ = 2781;
                stan::math::assign(j, (p - i));
                current_statement_begin__ = 2782;
                stan::math::assign(a, get_base1(x_new, j, "x_new", 1));
                current_statement_begin__ = 2783;
                for (int k = 1; k <= (j - 1); ++k) {
                    current_statement_begin__ = 2784;
                    stan::model::assign(work, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                ((get_base1(x_new, k, "x_new", 1) + (a * get_base1(x_new, (j - k), "x_new", 1))) / (1 - pow(a, 2))), 
                                "assigning variable work");
                }
                current_statement_begin__ = 2786;
                for (int k = 1; k <= j; ++k) {
                    current_statement_begin__ = 2787;
                    stan::model::assign(x_new, 
                                stan::model::cons_list(stan::model::index_uni(k), stan::model::nil_index_list()), 
                                get_base1(work, k, "work", 1), 
                                "assigning variable x_new");
                }
                }
            }
        }
        current_statement_begin__ = 2791;
        return stan::math::promote_scalar<fun_return_scalar_t__>(x_new);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct acf_to_pacf_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return acf_to_pacf(x, pstream__);
    }
};
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
unconstrain_stationary(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2808;
        validate_non_negative_index("y", "num_elements(x)", num_elements(x));
        validate_non_negative_index("y", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> y(num_elements(x), num_elements(x));
        stan::math::initialize(y, DUMMY_VAR__);
        stan::math::fill(y, DUMMY_VAR__);
        current_statement_begin__ = 2809;
        validate_non_negative_index("r", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> r(num_elements(x));
        stan::math::initialize(r, DUMMY_VAR__);
        stan::math::fill(r, DUMMY_VAR__);
        current_statement_begin__ = 2810;
        validate_non_negative_index("z", "num_elements(x)", num_elements(x));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> z(num_elements(x));
        stan::math::initialize(z, DUMMY_VAR__);
        stan::math::fill(z, DUMMY_VAR__);
        current_statement_begin__ = 2811;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2812;
        stan::math::assign(n, num_elements(x));
        current_statement_begin__ = 2814;
        stan::math::assign(r, acf_to_pacf(x, pstream__));
        current_statement_begin__ = 2816;
        for (int i = 1; i <= n; ++i) {
            current_statement_begin__ = 2817;
            stan::model::assign(z, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        stan::math::atanh(get_base1(r, i, "r", 1)), 
                        "assigning variable z");
        }
        current_statement_begin__ = 2819;
        return stan::math::promote_scalar<fun_return_scalar_t__>(z);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct unconstrain_stationary_functor__ {
    template <typename T0__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, 1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& x, std::ostream* pstream__) const {
        return unconstrain_stationary(x, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
kronecker_prod(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2846;
        validate_non_negative_index("C", "(rows(A) * rows(B))", (rows(A) * rows(B)));
        validate_non_negative_index("C", "(cols(A) * cols(B))", (cols(A) * cols(B)));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> C((rows(A) * rows(B)), (cols(A) * cols(B)));
        stan::math::initialize(C, DUMMY_VAR__);
        stan::math::fill(C, DUMMY_VAR__);
        current_statement_begin__ = 2847;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2848;
        int n(0);
        (void) n;  // dummy to suppress unused var warning
        stan::math::fill(n, std::numeric_limits<int>::min());
        current_statement_begin__ = 2849;
        int p(0);
        (void) p;  // dummy to suppress unused var warning
        stan::math::fill(p, std::numeric_limits<int>::min());
        current_statement_begin__ = 2850;
        int q(0);
        (void) q;  // dummy to suppress unused var warning
        stan::math::fill(q, std::numeric_limits<int>::min());
        current_statement_begin__ = 2851;
        stan::math::assign(m, rows(A));
        current_statement_begin__ = 2852;
        stan::math::assign(n, cols(A));
        current_statement_begin__ = 2853;
        stan::math::assign(p, rows(B));
        current_statement_begin__ = 2854;
        stan::math::assign(q, cols(B));
        current_statement_begin__ = 2855;
        for (int i = 1; i <= m; ++i) {
            current_statement_begin__ = 2856;
            for (int j = 1; j <= n; ++j) {
                {
                current_statement_begin__ = 2857;
                int row_start(0);
                (void) row_start;  // dummy to suppress unused var warning
                stan::math::fill(row_start, std::numeric_limits<int>::min());
                current_statement_begin__ = 2858;
                int row_end(0);
                (void) row_end;  // dummy to suppress unused var warning
                stan::math::fill(row_end, std::numeric_limits<int>::min());
                current_statement_begin__ = 2859;
                int col_start(0);
                (void) col_start;  // dummy to suppress unused var warning
                stan::math::fill(col_start, std::numeric_limits<int>::min());
                current_statement_begin__ = 2860;
                int col_end(0);
                (void) col_end;  // dummy to suppress unused var warning
                stan::math::fill(col_end, std::numeric_limits<int>::min());
                current_statement_begin__ = 2861;
                stan::math::assign(row_start, (((i - 1) * p) + 1));
                current_statement_begin__ = 2862;
                stan::math::assign(row_end, (((i - 1) * p) + p));
                current_statement_begin__ = 2863;
                stan::math::assign(col_start, (((j - 1) * q) + 1));
                current_statement_begin__ = 2864;
                stan::math::assign(col_end, (((j - 1) * q) + q));
                current_statement_begin__ = 2865;
                stan::model::assign(C, 
                            stan::model::cons_list(stan::model::index_min_max(row_start, row_end), stan::model::cons_list(stan::model::index_min_max(col_start, col_end), stan::model::nil_index_list())), 
                            multiply(get_base1(A, i, j, "A", 1), B), 
                            "assigning variable C");
                }
            }
        }
        current_statement_begin__ = 2868;
        return stan::math::promote_scalar<fun_return_scalar_t__>(C);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct kronecker_prod_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& A,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& B, std::ostream* pstream__) const {
        return kronecker_prod(A, B, pstream__);
    }
};
template <typename T0__, typename T1__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
stationary_cov(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& T,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 2910;
        validate_non_negative_index("P", "rows(T)", rows(T));
        validate_non_negative_index("P", "cols(T)", cols(T));
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P(rows(T), cols(T));
        stan::math::initialize(P, DUMMY_VAR__);
        stan::math::fill(P, DUMMY_VAR__);
        current_statement_begin__ = 2911;
        int m(0);
        (void) m;  // dummy to suppress unused var warning
        stan::math::fill(m, std::numeric_limits<int>::min());
        current_statement_begin__ = 2912;
        stan::math::assign(m, rows(T));
        current_statement_begin__ = 2915;
        if (as_bool(logical_eq(m, 1))) {
            current_statement_begin__ = 2916;
            stan::model::assign(P, 
                        stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_uni(1), stan::model::nil_index_list())), 
                        (get_base1(RQR, 1, 1, "RQR", 1) / (1.0 - pow(get_base1(T, 1, 1, "T", 1), 2))), 
                        "assigning variable P");
        } else {
            {
            current_statement_begin__ = 2918;
            validate_non_negative_index("TT", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            validate_non_negative_index("TT", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> TT((rows(T) * rows(T)), (rows(T) * rows(T)));
            stan::math::initialize(TT, DUMMY_VAR__);
            stan::math::fill(TT, DUMMY_VAR__);
            current_statement_begin__ = 2919;
            validate_non_negative_index("RQR_vec", "(rows(T) * rows(T))", (rows(T) * rows(T)));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> RQR_vec((rows(T) * rows(T)));
            stan::math::initialize(RQR_vec, DUMMY_VAR__);
            stan::math::fill(RQR_vec, DUMMY_VAR__);
            current_statement_begin__ = 2920;
            int m2(0);
            (void) m2;  // dummy to suppress unused var warning
            stan::math::fill(m2, std::numeric_limits<int>::min());
            current_statement_begin__ = 2921;
            stan::math::assign(m2, (m * m));
            current_statement_begin__ = 2922;
            stan::math::assign(RQR_vec, to_vector(RQR));
            current_statement_begin__ = 2924;
            stan::math::assign(TT, minus(kronecker_prod(T, T, pstream__)));
            current_statement_begin__ = 2925;
            for (int i = 1; i <= m2; ++i) {
                current_statement_begin__ = 2926;
                stan::model::assign(TT, 
                            stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list())), 
                            (1.0 + get_base1(TT, i, i, "TT", 1)), 
                            "assigning variable TT");
            }
            current_statement_begin__ = 2928;
            stan::math::assign(P, to_matrix_colwise(multiply(inverse(TT), RQR_vec), m, m, pstream__));
            }
        }
        current_statement_begin__ = 2930;
        return stan::math::promote_scalar<fun_return_scalar_t__>(P);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}
struct stationary_cov_functor__ {
    template <typename T0__, typename T1__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__>::type, Eigen::Dynamic, Eigen::Dynamic>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& T,
                   const Eigen::Matrix<T1__, Eigen::Dynamic, Eigen::Dynamic>& RQR, std::ostream* pstream__) const {
        return stationary_cov(T, RQR, pstream__);
    }
};
#include <stan_meta_header.hpp>
class model_ARMA_model
  : public stan::model::model_base_crtp<model_ARMA_model> {
private:
        int n;
        int p;
        std::vector<vector_d> y;
        int p_ar;
        int q_ma;
        int r;
        int m;
        vector_d d;
        matrix_d Z;
        matrix_d H;
        vector_d c;
public:
    model_ARMA_model(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, 0, pstream__);
    }
    model_ARMA_model(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : model_base_crtp(0) {
        ctor_body(context__, random_seed__, pstream__);
    }
    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning
        current_statement_begin__ = -1;
        static const char* function__ = "model_ARMA_model_namespace::model_ARMA_model";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        try {
            // initialize data block variables from context__
            current_statement_begin__ = 2936;
            context__.validate_dims("data initialization", "n", "int", context__.to_vec());
            n = int(0);
            vals_i__ = context__.vals_i("n");
            pos__ = 0;
            n = vals_i__[pos__++];
            check_greater_or_equal(function__, "n", n, 0);
            current_statement_begin__ = 2938;
            context__.validate_dims("data initialization", "p", "int", context__.to_vec());
            p = int(0);
            vals_i__ = context__.vals_i("p");
            pos__ = 0;
            p = vals_i__[pos__++];
            check_greater_or_equal(function__, "p", p, 0);
            current_statement_begin__ = 2940;
            validate_non_negative_index("y", "p", p);
            validate_non_negative_index("y", "n", n);
            context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(n,p));
            y = std::vector<Eigen::Matrix<double, Eigen::Dynamic, 1> >(n, Eigen::Matrix<double, Eigen::Dynamic, 1>(p));
            vals_r__ = context__.vals_r("y");
            pos__ = 0;
            size_t y_j_1_max__ = p;
            size_t y_k_0_max__ = n;
            for (size_t j_1__ = 0; j_1__ < y_j_1_max__; ++j_1__) {
                for (size_t k_0__ = 0; k_0__ < y_k_0_max__; ++k_0__) {
                    y[k_0__](j_1__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 2942;
            context__.validate_dims("data initialization", "p_ar", "int", context__.to_vec());
            p_ar = int(0);
            vals_i__ = context__.vals_i("p_ar");
            pos__ = 0;
            p_ar = vals_i__[pos__++];
            check_greater_or_equal(function__, "p_ar", p_ar, 0);
            current_statement_begin__ = 2944;
            context__.validate_dims("data initialization", "q_ma", "int", context__.to_vec());
            q_ma = int(0);
            vals_i__ = context__.vals_i("q_ma");
            pos__ = 0;
            q_ma = vals_i__[pos__++];
            check_greater_or_equal(function__, "q_ma", q_ma, 0);
            // initialize transformed data variables
            current_statement_begin__ = 2949;
            r = int(0);
            stan::math::fill(r, std::numeric_limits<int>::min());
            stan::math::assign(r,std::max(p_ar, (q_ma + 1)));
            current_statement_begin__ = 2952;
            m = int(0);
            stan::math::fill(m, std::numeric_limits<int>::min());
            stan::math::assign(m,r);
            current_statement_begin__ = 2955;
            validate_non_negative_index("d", "p", p);
            d = Eigen::Matrix<double, Eigen::Dynamic, 1>(p);
            stan::math::fill(d, DUMMY_VAR__);
            stan::math::assign(d,rep_vector(0, p));
            current_statement_begin__ = 2958;
            validate_non_negative_index("Z", "p", p);
            validate_non_negative_index("Z", "m", m);
            Z = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(p, m);
            stan::math::fill(Z, DUMMY_VAR__);
            stan::math::assign(Z,append_col(stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<double, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).array())).array()), to_matrix(rep_row_vector(0, (m - 1)))));
            current_statement_begin__ = 2961;
            validate_non_negative_index("H", "p", p);
            validate_non_negative_index("H", "p", p);
            H = Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(p, p);
            stan::math::fill(H, DUMMY_VAR__);
            stan::math::assign(H,stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<double, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<double >().add(0).array())).array()));
            current_statement_begin__ = 2964;
            validate_non_negative_index("c", "m", m);
            c = Eigen::Matrix<double, Eigen::Dynamic, 1>(m);
            stan::math::fill(c, DUMMY_VAR__);
            stan::math::assign(c,rep_vector(0, m));
            // execute transformed data statements
            // validate transformed data
            current_statement_begin__ = 2949;
            check_greater_or_equal(function__, "r", r, 0);
            current_statement_begin__ = 2952;
            check_greater_or_equal(function__, "m", m, 0);
            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 2971;
            validate_non_negative_index("phi", "p_ar", p_ar);
            num_params_r__ += p_ar;
            current_statement_begin__ = 2974;
            validate_non_negative_index("theta", "q_ma", q_ma);
            num_params_r__ += q_ma;
            current_statement_begin__ = 2976;
            num_params_r__ += 1;
            current_statement_begin__ = 2979;
            validate_non_negative_index("a1", "m", m);
            num_params_r__ += m;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    ~model_ARMA_model() { }
    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        typedef double local_scalar_t__;
        stan::io::writer<double> writer__(params_r__, params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;
        current_statement_begin__ = 2971;
        if (!(context__.contains_r("phi")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable phi missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("phi");
        pos__ = 0U;
        validate_non_negative_index("phi", "p_ar", p_ar);
        context__.validate_dims("parameter initialization", "phi", "vector_d", context__.to_vec(p_ar));
        Eigen::Matrix<double, Eigen::Dynamic, 1> phi(p_ar);
        size_t phi_j_1_max__ = p_ar;
        for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
            phi(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(phi);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable phi: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 2974;
        if (!(context__.contains_r("theta")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable theta missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("theta");
        pos__ = 0U;
        validate_non_negative_index("theta", "q_ma", q_ma);
        context__.validate_dims("parameter initialization", "theta", "vector_d", context__.to_vec(q_ma));
        Eigen::Matrix<double, Eigen::Dynamic, 1> theta(q_ma);
        size_t theta_j_1_max__ = q_ma;
        for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
            theta(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(theta);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable theta: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 2976;
        if (!(context__.contains_r("var_zeta")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable var_zeta missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("var_zeta");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "var_zeta", "double", context__.to_vec());
        double var_zeta(0);
        var_zeta = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(0, var_zeta);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable var_zeta: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        current_statement_begin__ = 2979;
        if (!(context__.contains_r("a1")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable a1 missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("a1");
        pos__ = 0U;
        validate_non_negative_index("a1", "m", m);
        context__.validate_dims("parameter initialization", "a1", "vector_d", context__.to_vec(m));
        Eigen::Matrix<double, Eigen::Dynamic, 1> a1(m);
        size_t a1_j_1_max__ = m;
        for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
            a1(j_1__) = vals_r__[pos__++];
        }
        try {
            writer__.vector_unconstrain(a1);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable a1: ") + e.what()), current_statement_begin__, prog_reader__());
        }
        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }
    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }
    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(std::vector<T__>& params_r__,
                 std::vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {
        typedef T__ local_scalar_t__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // dummy to suppress unused var warning
        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;
        try {
            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
            // model parameters
            current_statement_begin__ = 2971;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> phi;
            (void) phi;  // dummy to suppress unused var warning
            if (jacobian__)
                phi = in__.vector_constrain(p_ar, lp__);
            else
                phi = in__.vector_constrain(p_ar);
            current_statement_begin__ = 2974;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> theta;
            (void) theta;  // dummy to suppress unused var warning
            if (jacobian__)
                theta = in__.vector_constrain(q_ma, lp__);
            else
                theta = in__.vector_constrain(q_ma);
            current_statement_begin__ = 2976;
            local_scalar_t__ var_zeta;
            (void) var_zeta;  // dummy to suppress unused var warning
            if (jacobian__)
                var_zeta = in__.scalar_lb_constrain(0, lp__);
            else
                var_zeta = in__.scalar_lb_constrain(0);
            current_statement_begin__ = 2979;
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> a1;
            (void) a1;  // dummy to suppress unused var warning
            if (jacobian__)
                a1 = in__.vector_constrain(m, lp__);
            else
                a1 = in__.vector_constrain(m);
            // transformed parameters
            current_statement_begin__ = 2985;
            validate_non_negative_index("dummy_theta", "(r - 1)", (r - 1));
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> dummy_theta((r - 1));
            stan::math::initialize(dummy_theta, DUMMY_VAR__);
            stan::math::fill(dummy_theta, DUMMY_VAR__);
            stan::math::assign(dummy_theta,append_row(theta, rep_vector(0, ((r - 1) - q_ma))));
            current_statement_begin__ = 2987;
            validate_non_negative_index("dummy_phi", "r", r);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> dummy_phi(r);
            stan::math::initialize(dummy_phi, DUMMY_VAR__);
            stan::math::fill(dummy_phi, DUMMY_VAR__);
            stan::math::assign(dummy_phi,append_row(phi, rep_vector(0, (r - p_ar))));
            current_statement_begin__ = 2989;
            validate_non_negative_index("Q", "1", 1);
            validate_non_negative_index("Q", "1", 1);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Q(1, 1);
            stan::math::initialize(Q, DUMMY_VAR__);
            stan::math::fill(Q, DUMMY_VAR__);
            stan::math::assign(Q,stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<local_scalar_t__ >().add(var_zeta).array())).array()));
            current_statement_begin__ = 2992;
            validate_non_negative_index("R", "m", m);
            validate_non_negative_index("R", "1", 1);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R(m, 1);
            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R, DUMMY_VAR__);
            stan::math::assign(R,append_row(stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<double, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).array())).array()), to_matrix(dummy_theta)));
            current_statement_begin__ = 2995;
            validate_non_negative_index("T", "m", m);
            validate_non_negative_index("T", "m", m);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> T(m, m);
            stan::math::initialize(T, DUMMY_VAR__);
            stan::math::fill(T, DUMMY_VAR__);
            stan::math::assign(T,append_col(dummy_phi, append_row(diag_matrix(rep_vector(1, (m - 1))), to_matrix(rep_row_vector(0, (m - 1))))));
            current_statement_begin__ = 3001;
            validate_non_negative_index("P1", "m", m);
            validate_non_negative_index("P1", "m", m);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
            stan::math::initialize(P1, DUMMY_VAR__);
            stan::math::fill(P1, DUMMY_VAR__);
            stan::math::assign(P1,multiply(var_zeta, stationary_cov(T, quad_form_sym(Q, transpose(R)), pstream__)));
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 2985;
            size_t dummy_theta_j_1_max__ = (r - 1);
            for (size_t j_1__ = 0; j_1__ < dummy_theta_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(dummy_theta(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: dummy_theta" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable dummy_theta: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 2987;
            size_t dummy_phi_j_1_max__ = r;
            for (size_t j_1__ = 0; j_1__ < dummy_phi_j_1_max__; ++j_1__) {
                if (stan::math::is_uninitialized(dummy_phi(j_1__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: dummy_phi" << "(" << j_1__ << ")";
                    stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable dummy_phi: ") + msg__.str()), current_statement_begin__, prog_reader__());
                }
            }
            current_statement_begin__ = 2989;
            size_t Q_j_1_max__ = 1;
            size_t Q_j_2_max__ = 1;
            for (size_t j_1__ = 0; j_1__ < Q_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < Q_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(Q(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: Q" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable Q: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            current_statement_begin__ = 2992;
            size_t R_j_1_max__ = m;
            size_t R_j_2_max__ = 1;
            for (size_t j_1__ = 0; j_1__ < R_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < R_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(R(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: R" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable R: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            current_statement_begin__ = 2995;
            size_t T_j_1_max__ = m;
            size_t T_j_2_max__ = m;
            for (size_t j_1__ = 0; j_1__ < T_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < T_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(T(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: T" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable T: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            current_statement_begin__ = 3001;
            size_t P1_j_1_max__ = m;
            size_t P1_j_2_max__ = m;
            for (size_t j_1__ = 0; j_1__ < P1_j_1_max__; ++j_1__) {
                for (size_t j_2__ = 0; j_2__ < P1_j_2_max__; ++j_2__) {
                    if (stan::math::is_uninitialized(P1(j_1__, j_2__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: P1" << "(" << j_1__ << ", " << j_2__ << ")";
                        stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable P1: ") + msg__.str()), current_statement_begin__, prog_reader__());
                    }
                }
            }
            // model body
            current_statement_begin__ = 3006;
            lp_accum__.add(ssm_constant_lpdf(y, d, Z, H, c, T, R, Q, a1, P1, pstream__));
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
        lp_accum__.add(lp__);
        return lp_accum__.sum();
    } // log_prob()
    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }
    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("phi");
        names__.push_back("theta");
        names__.push_back("var_zeta");
        names__.push_back("a1");
        names__.push_back("dummy_theta");
        names__.push_back("dummy_phi");
        names__.push_back("Q");
        names__.push_back("R");
        names__.push_back("T");
        names__.push_back("P1");
    }
    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(p_ar);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(q_ma);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((r - 1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(r);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(1);
        dims__.push_back(1);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(1);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(m);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(m);
        dims__.push_back(m);
        dimss__.push_back(dims__);
    }
    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;
        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
        static const char* function__ = "model_ARMA_model_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        Eigen::Matrix<double, Eigen::Dynamic, 1> phi = in__.vector_constrain(p_ar);
        size_t phi_j_1_max__ = p_ar;
        for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
            vars__.push_back(phi(j_1__));
        }
        Eigen::Matrix<double, Eigen::Dynamic, 1> theta = in__.vector_constrain(q_ma);
        size_t theta_j_1_max__ = q_ma;
        for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
            vars__.push_back(theta(j_1__));
        }
        double var_zeta = in__.scalar_lb_constrain(0);
        vars__.push_back(var_zeta);
        Eigen::Matrix<double, Eigen::Dynamic, 1> a1 = in__.vector_constrain(m);
        size_t a1_j_1_max__ = m;
        for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
            vars__.push_back(a1(j_1__));
        }
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning
        if (!include_tparams__ && !include_gqs__) return;
        try {
            // declare and define transformed parameters
            current_statement_begin__ = 2985;
            validate_non_negative_index("dummy_theta", "(r - 1)", (r - 1));
            Eigen::Matrix<double, Eigen::Dynamic, 1> dummy_theta((r - 1));
            stan::math::initialize(dummy_theta, DUMMY_VAR__);
            stan::math::fill(dummy_theta, DUMMY_VAR__);
            stan::math::assign(dummy_theta,append_row(theta, rep_vector(0, ((r - 1) - q_ma))));
            current_statement_begin__ = 2987;
            validate_non_negative_index("dummy_phi", "r", r);
            Eigen::Matrix<double, Eigen::Dynamic, 1> dummy_phi(r);
            stan::math::initialize(dummy_phi, DUMMY_VAR__);
            stan::math::fill(dummy_phi, DUMMY_VAR__);
            stan::math::assign(dummy_phi,append_row(phi, rep_vector(0, (r - p_ar))));
            current_statement_begin__ = 2989;
            validate_non_negative_index("Q", "1", 1);
            validate_non_negative_index("Q", "1", 1);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> Q(1, 1);
            stan::math::initialize(Q, DUMMY_VAR__);
            stan::math::fill(Q, DUMMY_VAR__);
            stan::math::assign(Q,stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<local_scalar_t__ >().add(var_zeta).array())).array()));
            current_statement_begin__ = 2992;
            validate_non_negative_index("R", "m", m);
            validate_non_negative_index("R", "1", 1);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> R(m, 1);
            stan::math::initialize(R, DUMMY_VAR__);
            stan::math::fill(R, DUMMY_VAR__);
            stan::math::assign(R,append_row(stan::math::to_matrix(stan::math::array_builder<Eigen::Matrix<double, 1, Eigen::Dynamic> >().add(stan::math::to_row_vector(stan::math::array_builder<double >().add(1).array())).array()), to_matrix(dummy_theta)));
            current_statement_begin__ = 2995;
            validate_non_negative_index("T", "m", m);
            validate_non_negative_index("T", "m", m);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> T(m, m);
            stan::math::initialize(T, DUMMY_VAR__);
            stan::math::fill(T, DUMMY_VAR__);
            stan::math::assign(T,append_col(dummy_phi, append_row(diag_matrix(rep_vector(1, (m - 1))), to_matrix(rep_row_vector(0, (m - 1))))));
            current_statement_begin__ = 3001;
            validate_non_negative_index("P1", "m", m);
            validate_non_negative_index("P1", "m", m);
            Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> P1(m, m);
            stan::math::initialize(P1, DUMMY_VAR__);
            stan::math::fill(P1, DUMMY_VAR__);
            stan::math::assign(P1,multiply(var_zeta, stationary_cov(T, quad_form_sym(Q, transpose(R)), pstream__)));
            if (!include_gqs__ && !include_tparams__) return;
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            // write transformed parameters
            if (include_tparams__) {
                size_t dummy_theta_j_1_max__ = (r - 1);
                for (size_t j_1__ = 0; j_1__ < dummy_theta_j_1_max__; ++j_1__) {
                    vars__.push_back(dummy_theta(j_1__));
                }
                size_t dummy_phi_j_1_max__ = r;
                for (size_t j_1__ = 0; j_1__ < dummy_phi_j_1_max__; ++j_1__) {
                    vars__.push_back(dummy_phi(j_1__));
                }
                size_t Q_j_2_max__ = 1;
                size_t Q_j_1_max__ = 1;
                for (size_t j_2__ = 0; j_2__ < Q_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < Q_j_1_max__; ++j_1__) {
                        vars__.push_back(Q(j_1__, j_2__));
                    }
                }
                size_t R_j_2_max__ = 1;
                size_t R_j_1_max__ = m;
                for (size_t j_2__ = 0; j_2__ < R_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < R_j_1_max__; ++j_1__) {
                        vars__.push_back(R(j_1__, j_2__));
                    }
                }
                size_t T_j_2_max__ = m;
                size_t T_j_1_max__ = m;
                for (size_t j_2__ = 0; j_2__ < T_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < T_j_1_max__; ++j_1__) {
                        vars__.push_back(T(j_1__, j_2__));
                    }
                }
                size_t P1_j_2_max__ = m;
                size_t P1_j_1_max__ = m;
                for (size_t j_2__ = 0; j_2__ < P1_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < P1_j_1_max__; ++j_1__) {
                        vars__.push_back(P1(j_1__, j_2__));
                    }
                }
            }
            if (!include_gqs__) return;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }
    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }
    std::string model_name() const {
        return "model_ARMA_model";
    }
    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        size_t phi_j_1_max__ = p_ar;
        for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t theta_j_1_max__ = q_ma;
        for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "theta" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "var_zeta";
        param_names__.push_back(param_name_stream__.str());
        size_t a1_j_1_max__ = m;
        for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
            size_t dummy_theta_j_1_max__ = (r - 1);
            for (size_t j_1__ = 0; j_1__ < dummy_theta_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "dummy_theta" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t dummy_phi_j_1_max__ = r;
            for (size_t j_1__ = 0; j_1__ < dummy_phi_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "dummy_phi" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t Q_j_2_max__ = 1;
            size_t Q_j_1_max__ = 1;
            for (size_t j_2__ = 0; j_2__ < Q_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < Q_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "Q" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t R_j_2_max__ = 1;
            size_t R_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < R_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < R_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "R" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t T_j_2_max__ = m;
            size_t T_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < T_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < T_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "T" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t P1_j_2_max__ = m;
            size_t P1_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < P1_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < P1_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "P1" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        if (!include_gqs__) return;
    }
    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        size_t phi_j_1_max__ = p_ar;
        for (size_t j_1__ = 0; j_1__ < phi_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "phi" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        size_t theta_j_1_max__ = q_ma;
        for (size_t j_1__ = 0; j_1__ < theta_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "theta" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        param_name_stream__.str(std::string());
        param_name_stream__ << "var_zeta";
        param_names__.push_back(param_name_stream__.str());
        size_t a1_j_1_max__ = m;
        for (size_t j_1__ = 0; j_1__ < a1_j_1_max__; ++j_1__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "a1" << '.' << j_1__ + 1;
            param_names__.push_back(param_name_stream__.str());
        }
        if (!include_gqs__ && !include_tparams__) return;
        if (include_tparams__) {
            size_t dummy_theta_j_1_max__ = (r - 1);
            for (size_t j_1__ = 0; j_1__ < dummy_theta_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "dummy_theta" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t dummy_phi_j_1_max__ = r;
            for (size_t j_1__ = 0; j_1__ < dummy_phi_j_1_max__; ++j_1__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "dummy_phi" << '.' << j_1__ + 1;
                param_names__.push_back(param_name_stream__.str());
            }
            size_t Q_j_2_max__ = 1;
            size_t Q_j_1_max__ = 1;
            for (size_t j_2__ = 0; j_2__ < Q_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < Q_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "Q" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t R_j_2_max__ = 1;
            size_t R_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < R_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < R_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "R" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t T_j_2_max__ = m;
            size_t T_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < T_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < T_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "T" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
            size_t P1_j_2_max__ = m;
            size_t P1_j_1_max__ = m;
            for (size_t j_2__ = 0; j_2__ < P1_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < P1_j_1_max__; ++j_1__) {
                    param_name_stream__.str(std::string());
                    param_name_stream__ << "P1" << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                    param_names__.push_back(param_name_stream__.str());
                }
            }
        }
        if (!include_gqs__) return;
    }
}; // model
}  // namespace
typedef model_ARMA_model_namespace::model_ARMA_model stan_model;
#ifndef USING_R
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}
#endif
#endif
